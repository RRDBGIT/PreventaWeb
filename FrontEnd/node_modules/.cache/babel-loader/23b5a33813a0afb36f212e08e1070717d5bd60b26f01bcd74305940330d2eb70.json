{"ast":null,"code":"import _objectWithoutProperties from \"C:/PreventaWeb/FrontEnd/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"C:/PreventaWeb/FrontEnd/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nconst _excluded = [\"style\", \"children\"];\nimport { upperFirst, capitalize, parseFloat as parseFloat$1, without, pick, compose, evolve, mapValues, matchPercent, castArray, isNil, omit, asyncCompose } from '@react-pdf/fns';\nimport * as P from '@react-pdf/primitives';\nimport resolveStyle, { transformColor, flatten } from '@react-pdf/stylesheet';\nimport layoutEngine, { fontSubstitution, wordHyphenation, scriptItemizer, textDecoration, justification, linebreaker, bidi, fromFragments } from '@react-pdf/textkit';\nimport * as Yoga from 'yoga-layout/load';\nimport { loadYoga as loadYoga$1 } from 'yoga-layout/load';\nimport emojiRegex from 'emoji-regex-xs';\nimport resolveImage from '@react-pdf/image';\n\n/**\n * Apply transformation to text string\n *\n * @param {string} text\n * @param {string} transformation type\n * @returns {string} transformed text\n */\nconst transformText = (text, transformation) => {\n  switch (transformation) {\n    case 'uppercase':\n      return text.toUpperCase();\n    case 'lowercase':\n      return text.toLowerCase();\n    case 'capitalize':\n      return capitalize(text);\n    case 'upperfirst':\n      return upperFirst(text);\n    default:\n      return text;\n  }\n};\nconst isTspan = node => node.type === P.Tspan;\nconst isTextInstance$4 = node => node.type === P.TextInstance;\nconst engines$1 = {\n  bidi,\n  linebreaker,\n  justification,\n  textDecoration,\n  scriptItemizer,\n  wordHyphenation,\n  fontSubstitution\n};\nconst engine$1 = layoutEngine(engines$1);\nconst getFragments$1 = (fontStore, instance) => {\n  if (!instance) return [{\n    string: ''\n  }];\n  const fragments = [];\n  const {\n    fill = 'black',\n    fontFamily = 'Helvetica',\n    fontWeight,\n    fontStyle,\n    fontSize = 18,\n    textDecorationColor,\n    textDecorationStyle,\n    textTransform,\n    opacity\n  } = instance.props;\n  const _textDecoration = instance.props.textDecoration;\n  const fontFamilies = typeof fontFamily === 'string' ? [fontFamily] : [...(fontFamily || [])];\n  // Fallback font\n  fontFamilies.push('Helvetica');\n  const font = fontFamilies.map(fontFamilyName => {\n    const opts = {\n      fontFamily: fontFamilyName,\n      fontWeight,\n      fontStyle\n    };\n    const obj = fontStore.getFont(opts);\n    return obj === null || obj === void 0 ? void 0 : obj.data;\n  });\n  const attributes = {\n    font,\n    opacity,\n    fontSize,\n    color: fill,\n    underlineStyle: textDecorationStyle,\n    underline: _textDecoration === 'underline' || _textDecoration === 'underline line-through' || _textDecoration === 'line-through underline',\n    underlineColor: textDecorationColor || fill,\n    strike: _textDecoration === 'line-through' || _textDecoration === 'underline line-through' || _textDecoration === 'line-through underline',\n    strikeStyle: textDecorationStyle,\n    strikeColor: textDecorationColor || fill\n  };\n  for (let i = 0; i < instance.children.length; i += 1) {\n    const child = instance.children[i];\n    if (isTextInstance$4(child)) {\n      fragments.push({\n        string: transformText(child.value, textTransform),\n        attributes\n      });\n    } else if (child) {\n      fragments.push(...getFragments$1(fontStore, child));\n    }\n  }\n  return fragments;\n};\nconst getAttributedString$1 = (fontStore, instance) => fromFragments(getFragments$1(fontStore, instance));\nconst AlmostInfinity = 999999999999;\nconst shrinkWhitespaceFactor = {\n  before: -0.5,\n  after: -0.5\n};\nconst layoutTspan = fontStore => (node, xOffset) => {\n  var _node$props;\n  const attributedString = getAttributedString$1(fontStore, node);\n  const x = node.props.x === undefined ? xOffset : node.props.x;\n  const y = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.y) || 0;\n  const container = {\n    x,\n    y,\n    width: AlmostInfinity,\n    height: AlmostInfinity\n  };\n  const hyphenationCallback = node.props.hyphenationCallback || (fontStore === null || fontStore === void 0 ? void 0 : fontStore.getHyphenationCallback()) || null;\n  const layoutOptions = {\n    hyphenationCallback,\n    shrinkWhitespaceFactor\n  };\n  const lines = engine$1(attributedString, container, layoutOptions).flat();\n  return Object.assign({}, node, {\n    lines\n  });\n};\n// Consecutive TSpan elements should be joined with a space\nconst joinTSpanLines = node => {\n  const children = node.children.map((child, index) => {\n    if (!isTspan(child)) return child;\n    const textInstance = child.children[0];\n    if (child.props.x === undefined && index < node.children.length - 1 && textInstance !== null && textInstance !== void 0 && textInstance.value) {\n      return Object.assign({}, child, {\n        children: [_objectSpread(_objectSpread({}, textInstance), {}, {\n          value: \"\".concat(textInstance.value, \" \")\n        })]\n      });\n    }\n    return child;\n  }, []);\n  return Object.assign({}, node, {\n    children\n  });\n};\nconst layoutText$1 = (fontStore, node) => {\n  var _node$props2;\n  if (!node.children) return node;\n  let currentXOffset = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.x) || 0;\n  const layoutFn = layoutTspan(fontStore);\n  const joinedNode = joinTSpanLines(node);\n  const children = joinedNode.children.map(child => {\n    const childWithLayout = layoutFn(child, currentXOffset);\n    currentXOffset += childWithLayout.lines[0].xAdvance;\n    return childWithLayout;\n  });\n  return Object.assign({}, node, {\n    children\n  });\n};\nconst isDefs = node => node.type === P.Defs;\nconst getDefs = node => {\n  const children = node.children || [];\n  const defs = children.find(isDefs);\n  const values = (defs === null || defs === void 0 ? void 0 : defs.children) || [];\n  return values.reduce((acc, value) => {\n    var _value$props;\n    const id = (_value$props = value.props) === null || _value$props === void 0 ? void 0 : _value$props.id;\n    if (id) acc[id] = value;\n    return acc;\n  }, {});\n};\nconst isNotDefs = node => node.type !== P.Defs;\nconst detachDefs = node => {\n  if (!node.children) return node;\n  const children = node.children.filter(isNotDefs);\n  return Object.assign({}, node, {\n    children\n  });\n};\nconst URL_REGEX = /url\\(['\"]?#([^'\"]+)['\"]?\\)/;\nconst replaceDef = (defs, value) => {\n  if (!value) return undefined;\n  if (!URL_REGEX.test(value)) return value;\n  const match = value.match(URL_REGEX);\n  return defs[match[1]];\n};\nconst parseNodeDefs = defs => node => {\n  const props = node.props;\n  const fill = \"fill\" in props ? replaceDef(defs, props === null || props === void 0 ? void 0 : props.fill) : undefined;\n  const clipPath = \"clipPath\" in props ? replaceDef(defs, props === null || props === void 0 ? void 0 : props.clipPath) : undefined;\n  const newProps = Object.assign({}, node.props, {\n    fill,\n    clipPath\n  });\n  const children = node.children ? node.children.map(parseNodeDefs(defs)) : undefined;\n  return Object.assign({}, node, {\n    props: newProps,\n    children\n  });\n};\nconst parseDefs = root => {\n  if (!root.children) return root;\n  const defs = getDefs(root);\n  const children = root.children.map(parseNodeDefs(defs));\n  return Object.assign({}, root, {\n    children\n  });\n};\nconst replaceDefs = node => {\n  return detachDefs(parseDefs(node));\n};\nconst parseViewbox = value => {\n  if (!value) return null;\n  if (typeof value !== 'string') return value;\n  const values = value.split(/[,\\s]+/).map(parseFloat$1);\n  if (values.length !== 4) return null;\n  return {\n    minX: values[0],\n    minY: values[1],\n    maxX: values[2],\n    maxY: values[3]\n  };\n};\nconst getContainer$1 = node => {\n  const viewbox = parseViewbox(node.props.viewBox);\n  if (viewbox) {\n    return {\n      width: viewbox.maxX,\n      height: viewbox.maxY\n    };\n  }\n  if (node.props.width && node.props.height) {\n    return {\n      width: parseFloat$1(node.props.width),\n      height: parseFloat$1(node.props.height)\n    };\n  }\n  return {\n    width: 0,\n    height: 0\n  };\n};\nconst BASE_SVG_INHERITED_PROPS = ['x', 'y', 'clipPath', 'clipRule', 'opacity', 'fill', 'fillOpacity', 'fillRule', 'stroke', 'strokeLinecap', 'strokeLinejoin', 'strokeOpacity', 'strokeWidth', 'textAnchor', 'dominantBaseline', 'color', 'fontFamily', 'fontSize', 'fontStyle', 'fontWeight', 'letterSpacing', 'opacity', 'textDecoration', 'lineHeight', 'textAlign', 'visibility', 'wordSpacing'];\n// Do not inherit \"x\" for <tspan> elements from <text> parent\nconst TEXT_SVG_INHERITED_PROPS = without(['x'], BASE_SVG_INHERITED_PROPS);\nconst SVG_INHERITED_PROPS = {\n  [P.Text]: TEXT_SVG_INHERITED_PROPS\n};\nconst getInheritProps = node => {\n  var _SVG_INHERITED_PROPS$;\n  const props = node.props || {};\n  const svgInheritedProps = (_SVG_INHERITED_PROPS$ = SVG_INHERITED_PROPS[node.type]) !== null && _SVG_INHERITED_PROPS$ !== void 0 ? _SVG_INHERITED_PROPS$ : BASE_SVG_INHERITED_PROPS;\n  return pick(svgInheritedProps, props);\n};\nconst inheritProps = node => {\n  if (!node.children) return node;\n  const inheritedProps = getInheritProps(node);\n  const children = node.children.map(child => {\n    const props = Object.assign({}, inheritedProps, child.props || {});\n    const newChild = Object.assign({}, child, {\n      props\n    });\n    return inheritProps(newChild);\n  });\n  return Object.assign({}, node, {\n    children\n  });\n};\nconst parseAspectRatio = value => {\n  if (typeof value !== 'string') return value;\n  const match = value.replace(/[\\s\\r\\t\\n]+/gm, ' ').replace(/^defer\\s/, '').split(' ');\n  const align = match[0] || 'xMidYMid';\n  const meetOrSlice = match[1] || 'meet';\n  return {\n    align,\n    meetOrSlice\n  };\n};\nconst STYLE_PROPS = ['width', 'height', 'color', 'stroke', 'strokeWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'fill', 'fillRule', 'clipPath', 'offset', 'transform', 'strokeLinejoin', 'strokeLinecap', 'strokeDasharray', 'gradientUnits', 'gradientTransform'];\nconst VERTICAL_PROPS = ['y', 'y1', 'y2', 'height', 'cy', 'ry'];\nconst HORIZONTAL_PROPS = ['x', 'x1', 'x2', 'width', 'cx', 'rx'];\nconst isSvg$3 = node => node.type === P.Svg;\nconst isText$5 = node => node.type === P.Text;\nconst isTextInstance$3 = node => node.type === P.TextInstance;\nconst transformPercent = container => props => mapValues(props, (value, key) => {\n  const match = matchPercent(value);\n  if (match && VERTICAL_PROPS.includes(key)) {\n    return match.percent * container.height;\n  }\n  if (match && HORIZONTAL_PROPS.includes(key)) {\n    return match.percent * container.width;\n  }\n  return value;\n});\nconst parsePercent = value => {\n  const match = matchPercent(value);\n  return match ? match.percent : parseFloat$1(value);\n};\nconst parseTransform = container => value => {\n  return resolveStyle(container, {\n    transform: value\n  }).transform;\n};\nconst parseProps = container => node => {\n  let props = transformPercent(container)(node.props);\n  props = evolve({\n    x: parseFloat$1,\n    x1: parseFloat$1,\n    x2: parseFloat$1,\n    y: parseFloat$1,\n    y1: parseFloat$1,\n    y2: parseFloat$1,\n    r: parseFloat$1,\n    rx: parseFloat$1,\n    ry: parseFloat$1,\n    cx: parseFloat$1,\n    cy: parseFloat$1,\n    width: parseFloat$1,\n    height: parseFloat$1,\n    offset: parsePercent,\n    fill: transformColor,\n    opacity: parsePercent,\n    stroke: transformColor,\n    stopOpacity: parsePercent,\n    stopColor: transformColor,\n    transform: parseTransform(container),\n    gradientTransform: parseTransform(container)\n  }, props);\n  return Object.assign({}, node, {\n    props\n  });\n};\nconst mergeStyles$1 = node => {\n  const style = node.style || {};\n  const props = Object.assign({}, style, node.props);\n  return Object.assign({}, node, {\n    props\n  });\n};\nconst removeNoneValues = node => {\n  const removeNone = value => value === 'none' ? null : value;\n  const props = mapValues(node.props, removeNone);\n  return Object.assign({}, node, {\n    props\n  });\n};\nconst pickStyleProps = node => {\n  const props = node.props || {};\n  const styleProps = pick(STYLE_PROPS, props);\n  const style = Object.assign({}, styleProps, node.style || {});\n  return Object.assign({}, node, {\n    style\n  });\n};\nconst parseSvgProps = node => {\n  const props = evolve({\n    width: parseFloat$1,\n    height: parseFloat$1,\n    viewBox: parseViewbox,\n    preserveAspectRatio: parseAspectRatio\n  }, node.props);\n  return Object.assign({}, node, {\n    props\n  });\n};\nconst wrapBetweenTspan = node => ({\n  type: P.Tspan,\n  props: {},\n  style: {},\n  children: [node]\n});\nconst addMissingTspan = node => {\n  if (!isText$5(node)) return node;\n  if (!node.children) return node;\n  const resolveChild = child => isTextInstance$3(child) ? wrapBetweenTspan(child) : child;\n  const children = node.children.map(resolveChild);\n  return Object.assign({}, node, {\n    children\n  });\n};\nconst parseText = fontStore => node => {\n  if (isText$5(node)) return layoutText$1(fontStore, node);\n  if (!node.children) return node;\n  const children = node.children.map(parseText(fontStore));\n  return Object.assign({}, node, {\n    children\n  });\n};\nconst resolveSvgNode = container => compose(parseProps(container), addMissingTspan, removeNoneValues, mergeStyles$1);\nconst resolveChildren = container => node => {\n  if (!node.children) return node;\n  const resolveChild = compose(resolveChildren(container), resolveSvgNode(container));\n  const children = node.children.map(resolveChild);\n  return Object.assign({}, node, {\n    children\n  });\n};\nconst buildXLinksIndex = node => {\n  var _node$children;\n  const idIndex = {};\n  const listToExplore = ((_node$children = node.children) === null || _node$children === void 0 ? void 0 : _node$children.slice(0)) || [];\n  while (listToExplore.length > 0) {\n    const child = listToExplore.shift();\n    if (child.props && 'id' in child.props) {\n      idIndex[child.props.id] = child;\n    }\n    if (child.children) listToExplore.push(...child.children);\n  }\n  return idIndex;\n};\nconst replaceXLinks = (node, idIndex) => {\n  var _node$children2;\n  if (node.props && 'xlinkHref' in node.props) {\n    const linkedNode = idIndex[node.props.xlinkHref.replace(/^#/, '')];\n    // No node to extend from\n    if (!linkedNode) return node;\n    const newProps = Object.assign({}, linkedNode.props, node.props);\n    delete newProps.xlinkHref;\n    return Object.assign({}, linkedNode, {\n      props: newProps\n    });\n  }\n  const children = (_node$children2 = node.children) === null || _node$children2 === void 0 ? void 0 : _node$children2.map(child => replaceXLinks(child, idIndex));\n  return Object.assign({}, node, {\n    children\n  });\n};\nconst resolveXLinks = node => {\n  const idIndex = buildXLinksIndex(node);\n  return replaceXLinks(node, idIndex);\n};\nconst resolveSvgRoot = (node, fontStore) => {\n  const container = getContainer$1(node);\n  return compose(replaceDefs, parseText(fontStore), parseSvgProps, pickStyleProps, inheritProps, resolveChildren(container), resolveXLinks)(node);\n};\n/**\n * Pre-process SVG nodes so they can be rendered in the next steps\n *\n * @param node - Root node\n * @param fontStore - Font store\n * @returns Root node\n */\nconst resolveSvg = (node, fontStore) => {\n  var _root$children;\n  if (!('children' in node)) return node;\n  const resolveChild = child => resolveSvg(child, fontStore);\n  const root = isSvg$3(node) ? resolveSvgRoot(node, fontStore) : node;\n  const children = (_root$children = root.children) === null || _root$children === void 0 ? void 0 : _root$children.map(resolveChild);\n  return Object.assign({}, root, {\n    children\n  });\n};\nlet instancePromise;\nconst loadYoga = async () => {\n  // Yoga WASM binaries must be asynchronously compiled and loaded\n  // to prevent Event emitter memory leak warnings, Yoga must be loaded only once\n  const instance = await (instancePromise !== null && instancePromise !== void 0 ? instancePromise : instancePromise = loadYoga$1());\n  const config = instance.Config.create();\n  config.setPointScaleFactor(0);\n  const node = {\n    create: () => instance.Node.createWithConfig(config)\n  };\n  return {\n    node\n  };\n};\nconst resolveYoga = async root => {\n  const yoga = await loadYoga();\n  return Object.assign({}, root, {\n    yoga\n  });\n};\nconst getZIndex = node => node.style.zIndex;\nconst shouldSort = node => node.type !== P.Document && node.type !== P.Svg;\nconst sortZIndex = (a, b) => {\n  const za = getZIndex(a);\n  const zb = getZIndex(b);\n  if (!za && !zb) return 0;\n  if (!za) return 1;\n  if (!zb) return -1;\n  return zb - za;\n};\n/**\n * Sort children by zIndex value\n *\n * @param node\n * @returns Node\n */\nconst resolveNodeZIndex = node => {\n  if (!node.children) return node;\n  const sortedChildren = shouldSort(node) ? node.children.sort(sortZIndex) : node.children;\n  const children = sortedChildren.map(resolveNodeZIndex);\n  return Object.assign({}, node, {\n    children\n  });\n};\n/**\n * Sort children by zIndex value\n *\n * @param node\n * @returns Node\n */\nconst resolveZIndex = root => resolveNodeZIndex(root);\n\n/* eslint-disable no-console */\n// Caches emoji images data\nconst emojis = {};\nconst regex = emojiRegex();\n/**\n * When an emoji as no variations, it might still have 2 parts,\n * the canonical emoji and an empty string.\n * ex.\n *   (no color) Array.from('â¤ï¸') => [\"â¤\", \"ï¸\"]\n *   (w/ color) Array.from('ðŸ‘ðŸ¿') => [\"ðŸ‘\", \"ðŸ¿\"]\n *\n * The empty string needs to be removed otherwise the generated\n * url will be incorect.\n */\nconst removeVariationSelectors = x => x !== 'ï¸';\nconst getCodePoints = function (string) {\n  let withVariationSelectors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return Array.from(string).filter(withVariationSelectors ? () => true : removeVariationSelectors).map(char => char.codePointAt(0).toString(16)).join('-');\n};\nconst buildEmojiUrl = (emoji, source) => {\n  if ('builder' in source) {\n    return source.builder(getCodePoints(emoji, source.withVariationSelectors));\n  }\n  const {\n    url,\n    format = 'png',\n    withVariationSelectors\n  } = source;\n  return \"\".concat(url).concat(getCodePoints(emoji, withVariationSelectors), \".\").concat(format);\n};\nconst fetchEmojis = (string, source) => {\n  if (!source) return [];\n  const promises = [];\n  Array.from(string.matchAll(regex)).forEach(match => {\n    const emoji = match[0];\n    if (!emojis[emoji] || emojis[emoji].loading) {\n      const emojiUrl = buildEmojiUrl(emoji, source);\n      emojis[emoji] = {\n        loading: true\n      };\n      promises.push(resolveImage({\n        uri: emojiUrl\n      }).then(image => {\n        emojis[emoji].loading = false;\n        emojis[emoji].data = image.data;\n      }).catch(e => {\n        console.warn(e, 'Failed to load emoji image');\n        emojis[emoji].loading = false;\n      }));\n    }\n  });\n  return promises;\n};\nconst embedEmojis = fragments => {\n  const result = [];\n  for (let i = 0; i < fragments.length; i += 1) {\n    const fragment = fragments[i];\n    let lastIndex = 0;\n    Array.from(fragment.string.matchAll(regex)).forEach(match => {\n      const {\n        index\n      } = match;\n      const emoji = match[0];\n      const emojiSize = fragment.attributes.fontSize;\n      const chunk = fragment.string.slice(lastIndex, index + match[0].length);\n      // If emoji image was found, we create a new fragment with the\n      // correct attachment and object substitution character;\n      if (emojis[emoji] && emojis[emoji].data) {\n        result.push({\n          string: chunk.replace(match[0], String.fromCharCode(0xfffc)),\n          attributes: _objectSpread(_objectSpread({}, fragment.attributes), {}, {\n            attachment: {\n              width: emojiSize,\n              height: emojiSize,\n              yOffset: Math.floor(emojiSize * 0.1),\n              image: emojis[emoji].data\n            }\n          })\n        });\n      } else {\n        // If no emoji data, we try to use emojis in the font\n        result.push({\n          string: chunk,\n          attributes: fragment.attributes\n        });\n      }\n      lastIndex = index + emoji.length;\n    });\n    if (lastIndex < fragment.string.length) {\n      result.push({\n        string: fragment.string.slice(lastIndex),\n        attributes: fragment.attributes\n      });\n    }\n  }\n  return result;\n};\n\n/**\n * Get image source\n *\n * @param node - Image node\n * @returns Image src\n */\nconst getSource = node => {\n  if (node.props.src) return node.props.src;\n  if (node.props.source) return node.props.source;\n};\n\n/**\n * Resolves `src` to `@react-pdf/image` interface.\n *\n * Also it handles factories and async sources.\n *\n * @param src\n * @returns Resolved src\n */\nconst resolveSource = async src => {\n  const source = typeof src === 'function' ? await src() : await src;\n  return typeof source === 'string' ? {\n    uri: source\n  } : source;\n};\n\n/**\n * Fetches image and append data to node\n * Ideally this fn should be immutable.\n *\n * @param node\n */\nconst fetchImage = async node => {\n  const src = getSource(node);\n  const {\n    cache\n  } = node.props;\n  if (!src) {\n    console.warn(false, 'Image should receive either a \"src\" or \"source\" prop');\n    return;\n  }\n  try {\n    const source = await resolveSource(src);\n    if (!source) {\n      throw new Error(\"Image's \\\"src\\\" or \\\"source\\\" prop returned \".concat(source));\n    }\n    node.image = await resolveImage(source, {\n      cache\n    });\n    if (Buffer.isBuffer(source) || source instanceof Blob) return;\n    node.image.key = 'data' in source ? source.data.toString() : source.uri;\n  } catch (e) {\n    console.warn(e.message);\n  }\n};\nconst isImage$2 = node => node.type === P.Image;\n/**\n * Get all asset promises that need to be resolved\n *\n * @param fontStore - Font store\n * @param node - Root node\n * @returns Asset promises\n */\nconst fetchAssets = (fontStore, node) => {\n  var _node$children3;\n  const promises = [];\n  const listToExplore = ((_node$children3 = node.children) === null || _node$children3 === void 0 ? void 0 : _node$children3.slice(0)) || [];\n  const emojiSource = fontStore ? fontStore.getEmojiSource() : null;\n  while (listToExplore.length > 0) {\n    var _n$style;\n    const n = listToExplore.shift();\n    if (isImage$2(n)) {\n      promises.push(fetchImage(n));\n    }\n    if (fontStore && (_n$style = n.style) !== null && _n$style !== void 0 && _n$style.fontFamily) {\n      const fontFamilies = castArray(n.style.fontFamily);\n      promises.push(...fontFamilies.map(fontFamily => fontStore.load({\n        fontFamily,\n        fontStyle: n.style.fontStyle,\n        fontWeight: n.style.fontWeight\n      })));\n    }\n    if (typeof n === 'string') {\n      promises.push(...fetchEmojis(n, emojiSource));\n    }\n    if ('value' in n && typeof n.value === 'string') {\n      promises.push(...fetchEmojis(n.value, emojiSource));\n    }\n    if (n.children) {\n      n.children.forEach(childNode => {\n        listToExplore.push(childNode);\n      });\n    }\n  }\n  return promises;\n};\n/**\n * Fetch image, font and emoji assets in parallel.\n * Layout process will not be resumed until promise resolves.\n *\n * @param node root node\n * @param fontStore font store\n * @returns Root node\n */\nconst resolveAssets = async (node, fontStore) => {\n  const promises = fetchAssets(fontStore, node);\n  await Promise.all(promises);\n  return node;\n};\nconst isLink$1 = node => node.type === P.Link;\nconst DEFAULT_LINK_STYLES = {\n  color: 'blue',\n  textDecoration: 'underline'\n};\n/**\n * Computes styles using stylesheet\n *\n * @param container\n * @param node - Document node\n * @returns Computed styles\n */\nconst computeStyle = (container, node) => {\n  let baseStyle = [node.style];\n  if (isLink$1(node)) {\n    baseStyle = Array.isArray(node.style) ? [DEFAULT_LINK_STYLES, ...node.style] : [DEFAULT_LINK_STYLES, node.style];\n  }\n  return resolveStyle(container, baseStyle);\n};\n/**\n * Resolves node styles\n *\n * @param container\n * @returns Resolve node styles\n */\nconst resolveNodeStyles = container => node => {\n  const style = computeStyle(container, node);\n  if (!node.children) return Object.assign({}, node, {\n    style\n  });\n  const children = node.children.map(resolveNodeStyles(container));\n  return Object.assign({}, node, {\n    style,\n    children\n  });\n};\n/**\n * Resolves page styles\n *\n * @param page Document page\n * @returns Document page with resolved styles\n */\nconst resolvePageStyles = page => {\n  var _page$props, _page$box, _page$box2, _page$props2;\n  const dpi = ((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.dpi) || 72;\n  const style = page.style;\n  const width = ((_page$box = page.box) === null || _page$box === void 0 ? void 0 : _page$box.width) || style.width;\n  const height = ((_page$box2 = page.box) === null || _page$box2 === void 0 ? void 0 : _page$box2.height) || style.height;\n  const orientation = ((_page$props2 = page.props) === null || _page$props2 === void 0 ? void 0 : _page$props2.orientation) || 'portrait';\n  const remBase = (style === null || style === void 0 ? void 0 : style.fontSize) || 18;\n  const container = {\n    width,\n    height,\n    orientation,\n    dpi,\n    remBase\n  };\n  return resolveNodeStyles(container)(page);\n};\n/**\n * Resolves document styles\n *\n * @param root - Document root\n * @returns Document root with resolved styles\n */\nconst resolveStyles = root => {\n  if (!root.children) return root;\n  const children = root.children.map(resolvePageStyles);\n  return Object.assign({}, root, {\n    children\n  });\n};\nconst getTransformStyle = s => node => {\n  var _node$style, _node$style$s, _node$style2;\n  return isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style[s]) ? '50%' : (_node$style$s = (_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2[s]) !== null && _node$style$s !== void 0 ? _node$style$s : null;\n};\n/**\n * Get node origin\n *\n * @param node\n * @returns {{ left?: number, top?: number }} node origin\n */\nconst getOrigin = node => {\n  if (!node.box) return null;\n  const {\n    left,\n    top,\n    width,\n    height\n  } = node.box;\n  const transformOriginX = getTransformStyle('transformOriginX')(node);\n  const transformOriginY = getTransformStyle('transformOriginY')(node);\n  const percentX = matchPercent(transformOriginX);\n  const percentY = matchPercent(transformOriginY);\n  const offsetX = percentX ? width * percentX.percent : transformOriginX;\n  const offsetY = percentY ? height * percentY.percent : transformOriginY;\n  if (isNil(offsetX) || typeof offsetX === 'string') throw new Error(\"Invalid origin offsetX: \".concat(offsetX));\n  if (isNil(offsetY) || typeof offsetY === 'string') throw new Error(\"Invalid origin offsetY: \".concat(offsetY));\n  return {\n    left: left + offsetX,\n    top: top + offsetY\n  };\n};\n\n/**\n * Resolve node origin\n *\n * @param node\n * @returns Node with origin attribute\n */\nconst resolveNodeOrigin = node => {\n  const origin = getOrigin(node);\n  const newNode = Object.assign({}, node, {\n    origin\n  });\n  if (!node.children) return newNode;\n  const children = node.children.map(resolveNodeOrigin);\n  return Object.assign({}, newNode, {\n    children\n  });\n};\n/**\n * Resolve document origins\n *\n * @param root - Document root\n * @returns Document root\n */\nconst resolveOrigin = root => {\n  if (!root.children) return root;\n  const children = root.children.map(resolveNodeOrigin);\n  return Object.assign({}, root, {\n    children\n  });\n};\nconst getBookmarkValue = bookmark => {\n  return typeof bookmark === 'string' ? {\n    title: bookmark,\n    fit: false,\n    expanded: false\n  } : bookmark;\n};\nconst resolveBookmarks = node => {\n  let refs = 0;\n  const children = (node.children || []).slice(0);\n  const listToExplore = children.map(value => ({\n    value,\n    parent: null\n  }));\n  while (listToExplore.length > 0) {\n    const element = listToExplore.shift();\n    if (!element) break;\n    const child = element.value;\n    let parent = element.parent;\n    if (child.props && 'bookmark' in child.props && child.props.bookmark) {\n      var _parent;\n      const bookmark = getBookmarkValue(child.props.bookmark);\n      const ref = refs++;\n      const newHierarchy = _objectSpread({\n        ref,\n        parent: (_parent = parent) === null || _parent === void 0 ? void 0 : _parent.ref\n      }, bookmark);\n      child.props.bookmark = newHierarchy;\n      parent = newHierarchy;\n    }\n    if (child.children) {\n      child.children.forEach(childNode => {\n        listToExplore.push({\n          value: childNode,\n          parent\n        });\n      });\n    }\n  }\n  return node;\n};\nconst VALID_ORIENTATIONS = ['portrait', 'landscape'];\n/**\n * Get page orientation. Defaults to portrait\n *\n * @param page - Page object\n * @returns Page orientation\n */\nconst getOrientation = page => {\n  var _page$props3;\n  const value = ((_page$props3 = page.props) === null || _page$props3 === void 0 ? void 0 : _page$props3.orientation) || 'portrait';\n  return VALID_ORIENTATIONS.includes(value) ? value : 'portrait';\n};\n\n/**\n * Return true if page is landscape\n *\n * @param page - Page instance\n * @returns Is page landscape\n */\nconst isLandscape = page => getOrientation(page) === 'landscape';\n\n// Page sizes for 72dpi. 72dpi is used internally by pdfkit.\nconst PAGE_SIZES = {\n  '4A0': [4767.87, 6740.79],\n  '2A0': [3370.39, 4767.87],\n  A0: [2383.94, 3370.39],\n  A1: [1683.78, 2383.94],\n  A2: [1190.55, 1683.78],\n  A3: [841.89, 1190.55],\n  A4: [595.28, 841.89],\n  A5: [419.53, 595.28],\n  A6: [297.64, 419.53],\n  A7: [209.76, 297.64],\n  A8: [147.4, 209.76],\n  A9: [104.88, 147.4],\n  A10: [73.7, 104.88],\n  B0: [2834.65, 4008.19],\n  B1: [2004.09, 2834.65],\n  B2: [1417.32, 2004.09],\n  B3: [1000.63, 1417.32],\n  B4: [708.66, 1000.63],\n  B5: [498.9, 708.66],\n  B6: [354.33, 498.9],\n  B7: [249.45, 354.33],\n  B8: [175.75, 249.45],\n  B9: [124.72, 175.75],\n  B10: [87.87, 124.72],\n  C0: [2599.37, 3676.54],\n  C1: [1836.85, 2599.37],\n  C2: [1298.27, 1836.85],\n  C3: [918.43, 1298.27],\n  C4: [649.13, 918.43],\n  C5: [459.21, 649.13],\n  C6: [323.15, 459.21],\n  C7: [229.61, 323.15],\n  C8: [161.57, 229.61],\n  C9: [113.39, 161.57],\n  C10: [79.37, 113.39],\n  RA0: [2437.8, 3458.27],\n  RA1: [1729.13, 2437.8],\n  RA2: [1218.9, 1729.13],\n  RA3: [864.57, 1218.9],\n  RA4: [609.45, 864.57],\n  SRA0: [2551.18, 3628.35],\n  SRA1: [1814.17, 2551.18],\n  SRA2: [1275.59, 1814.17],\n  SRA3: [907.09, 1275.59],\n  SRA4: [637.8, 907.09],\n  EXECUTIVE: [521.86, 756.0],\n  FOLIO: [612.0, 936.0],\n  LEGAL: [612.0, 1008.0],\n  LETTER: [612.0, 792.0],\n  TABLOID: [792.0, 1224.0],\n  ID1: [153, 243]\n};\n/**\n * Parses scalar value in value and unit pairs\n *\n * @param value - Scalar value\n * @returns Parsed value\n */\nconst parseValue = value => {\n  if (typeof value === 'number') return {\n    value,\n    unit: undefined\n  };\n  const match = /^(-?\\d*\\.?\\d+)(in|mm|cm|pt|px)?$/g.exec(value);\n  return match ? {\n    value: parseFloat(match[1]),\n    unit: match[2] || 'pt'\n  } : {\n    value,\n    unit: undefined\n  };\n};\n/**\n * Transform given scalar value to 72dpi equivalent of size\n *\n * @param value - Styles value\n * @param inputDpi - User defined dpi\n * @returns Transformed value\n */\nconst transformUnit = (value, inputDpi) => {\n  if (!value) return 0;\n  const scalar = parseValue(value);\n  const outputDpi = 72;\n  const mmFactor = 1 / 25.4 * outputDpi;\n  const cmFactor = 1 / 2.54 * outputDpi;\n  if (typeof scalar.value === 'string') throw new Error(\"Invalid page size: \".concat(value));\n  switch (scalar.unit) {\n    case 'in':\n      return scalar.value * outputDpi;\n    case 'mm':\n      return scalar.value * mmFactor;\n    case 'cm':\n      return scalar.value * cmFactor;\n    case 'px':\n      return Math.round(scalar.value * (outputDpi / inputDpi));\n    default:\n      return scalar.value;\n  }\n};\nconst transformUnits = (_ref, dpi) => {\n  let {\n    width,\n    height\n  } = _ref;\n  return {\n    width: transformUnit(width, dpi),\n    height: transformUnit(height, dpi)\n  };\n};\n/**\n * Transforms array into size object\n *\n * @param v - Values array\n * @returns Size object with width and height\n */\nconst toSizeObject = v => ({\n  width: v[0],\n  height: v[1]\n});\n/**\n * Flip size object\n *\n * @param v - Size object\n * @returns Flipped size object\n */\nconst flipSizeObject = v => ({\n  width: v.height,\n  height: v.width\n});\n/**\n * Returns size object from a given string\n *\n * @param v - Page size string\n * @returns Size object with width and height\n */\nconst getStringSize = v => {\n  return toSizeObject(PAGE_SIZES[v.toUpperCase()]);\n};\n/**\n * Returns size object from a single number\n *\n * @param n - Page size number\n * @returns Size object with width and height\n */\nconst getNumberSize = n => toSizeObject([n, n]);\n/**\n * Return page size in an object { width, height }\n *\n * @param page - Page node\n * @returns Size object with width and height\n */\nconst getSize = page => {\n  var _page$props4, _page$props5;\n  const value = ((_page$props4 = page.props) === null || _page$props4 === void 0 ? void 0 : _page$props4.size) || 'A4';\n  const dpi = ((_page$props5 = page.props) === null || _page$props5 === void 0 ? void 0 : _page$props5.dpi) || 72;\n  let size;\n  if (typeof value === 'string') {\n    size = getStringSize(value);\n  } else if (Array.isArray(value)) {\n    size = transformUnits(toSizeObject(value), dpi);\n  } else if (typeof value === 'number') {\n    size = transformUnits(getNumberSize(value), dpi);\n  } else {\n    size = transformUnits(value, dpi);\n  }\n  return isLandscape(page) ? flipSizeObject(size) : size;\n};\n\n/**\n * Resolves page size\n *\n * @param page\n * @returns Page with resolved size in style attribute\n */\nconst resolvePageSize = page => {\n  const size = getSize(page);\n  const style = flatten(page.style || {});\n  return _objectSpread(_objectSpread({}, page), {}, {\n    style: _objectSpread(_objectSpread({}, style), size)\n  });\n};\n/**\n * Resolves page sizes\n *\n * @param root  -Document root\n * @returns Document root with resolved page sizes\n */\nconst resolvePageSizes = root => {\n  if (!root.children) return root;\n  const children = root.children.map(resolvePageSize);\n  return Object.assign({}, root, {\n    children\n  });\n};\nconst isFixed = node => {\n  if (!node.props) return false;\n  return 'fixed' in node.props ? node.props.fixed === true : false;\n};\n\n/**\n * Get line index at given height\n *\n * @param node\n * @param height\n */\nconst lineIndexAtHeight = (node, height) => {\n  let y = 0;\n  if (!node.lines) return 0;\n  for (let i = 0; i < node.lines.length; i += 1) {\n    const line = node.lines[i];\n    if (y + line.box.height > height) return i;\n    y += line.box.height;\n  }\n  return node.lines.length;\n};\n\n/**\n * Get height for given text line index\n *\n * @param node\n * @param index\n */\nconst heightAtLineIndex = (node, index) => {\n  let counter = 0;\n  if (!node.lines) return counter;\n  for (let i = 0; i < index; i += 1) {\n    const line = node.lines[i];\n    if (!line) break;\n    counter += line.box.height;\n  }\n  return counter;\n};\nconst getLineBreak = (node, height) => {\n  var _node$box;\n  const top = ((_node$box = node.box) === null || _node$box === void 0 ? void 0 : _node$box.top) || 0;\n  const widows = node.props.widows || 2;\n  const orphans = node.props.orphans || 2;\n  const linesQuantity = node.lines.length;\n  const slicedLine = lineIndexAtHeight(node, height - top);\n  if (slicedLine === 0) {\n    return 0;\n  }\n  if (linesQuantity < orphans) {\n    return linesQuantity;\n  }\n  if (slicedLine < orphans || linesQuantity < orphans + widows) {\n    return 0;\n  }\n  if (linesQuantity === orphans + widows) {\n    return orphans;\n  }\n  if (linesQuantity - slicedLine < widows) {\n    return linesQuantity - widows;\n  }\n  return slicedLine;\n};\n// Also receives contentArea in case it's needed\nconst splitText = (node, height) => {\n  const slicedLineIndex = getLineBreak(node, height);\n  const currentHeight = heightAtLineIndex(node, slicedLineIndex);\n  const nextHeight = node.box.height - currentHeight;\n  const current = Object.assign({}, node, {\n    box: _objectSpread(_objectSpread({}, node.box), {}, {\n      height: currentHeight,\n      borderBottomWidth: 0\n    }),\n    style: _objectSpread(_objectSpread({}, node.style), {}, {\n      marginBottom: 0,\n      paddingBottom: 0,\n      borderBottomWidth: 0,\n      borderBottomLeftRadius: 0,\n      borderBottomRightRadius: 0\n    }),\n    lines: node.lines.slice(0, slicedLineIndex)\n  });\n  const next = Object.assign({}, node, {\n    box: _objectSpread(_objectSpread({}, node.box), {}, {\n      top: 0,\n      height: nextHeight,\n      borderTopWidth: 0\n    }),\n    style: _objectSpread(_objectSpread({}, node.style), {}, {\n      marginTop: 0,\n      paddingTop: 0,\n      borderTopWidth: 0,\n      borderTopLeftRadius: 0,\n      borderTopRightRadius: 0\n    }),\n    lines: node.lines.slice(slicedLineIndex)\n  });\n  return [current, next];\n};\nconst getTop$1 = node => {\n  var _node$box2;\n  return ((_node$box2 = node.box) === null || _node$box2 === void 0 ? void 0 : _node$box2.top) || 0;\n};\nconst hasFixedHeight = node => {\n  var _node$style3;\n  return !isNil((_node$style3 = node.style) === null || _node$style3 === void 0 ? void 0 : _node$style3.height);\n};\nconst splitNode = (node, height) => {\n  if (!node) return [null, null];\n  const nodeTop = getTop$1(node);\n  const current = Object.assign({}, node, {\n    box: _objectSpread(_objectSpread({}, node.box), {}, {\n      borderBottomWidth: 0\n    }),\n    style: _objectSpread(_objectSpread({}, node.style), {}, {\n      marginBottom: 0,\n      paddingBottom: 0,\n      borderBottomWidth: 0,\n      borderBottomLeftRadius: 0,\n      borderBottomRightRadius: 0\n    })\n  });\n  current.style.height = height - nodeTop;\n  const nextHeight = hasFixedHeight(node) ? node.box.height - (height - nodeTop) : null;\n  const next = Object.assign({}, node, {\n    box: _objectSpread(_objectSpread({}, node.box), {}, {\n      top: 0,\n      borderTopWidth: 0\n    }),\n    style: _objectSpread(_objectSpread({}, node.style), {}, {\n      marginTop: 0,\n      paddingTop: 0,\n      borderTopWidth: 0,\n      borderTopLeftRadius: 0,\n      borderTopRightRadius: 0\n    })\n  });\n  if (nextHeight) {\n    next.style.height = nextHeight;\n  }\n  return [current, next];\n};\nconst NON_WRAP_TYPES = [P.Svg, P.Note, P.Image, P.Canvas];\nconst getWrap = node => {\n  if (NON_WRAP_TYPES.includes(node.type)) return false;\n  if (!node.props) return true;\n  return 'wrap' in node.props ? node.props.wrap : true;\n};\nconst getComputedPadding = (node, edge) => {\n  const {\n    yogaNode\n  } = node;\n  return yogaNode ? yogaNode.getComputedPadding(edge) : null;\n};\n/**\n * Get Yoga computed paddings. Zero otherwise\n *\n * @param  node\n * @returns paddings\n */\nconst getPadding = node => {\n  const {\n    style,\n    box\n  } = node;\n  const paddingTop = getComputedPadding(node, Yoga.Edge.Top) || (box === null || box === void 0 ? void 0 : box.paddingTop) || (style === null || style === void 0 ? void 0 : style.paddingTop) || 0;\n  const paddingRight = getComputedPadding(node, Yoga.Edge.Right) || (box === null || box === void 0 ? void 0 : box.paddingRight) || (style === null || style === void 0 ? void 0 : style.paddingRight) || 0;\n  const paddingBottom = getComputedPadding(node, Yoga.Edge.Bottom) || (box === null || box === void 0 ? void 0 : box.paddingBottom) || (style === null || style === void 0 ? void 0 : style.paddingBottom) || 0;\n  const paddingLeft = getComputedPadding(node, Yoga.Edge.Left) || (box === null || box === void 0 ? void 0 : box.paddingLeft) || (style === null || style === void 0 ? void 0 : style.paddingLeft) || 0;\n  return {\n    paddingTop,\n    paddingRight,\n    paddingBottom,\n    paddingLeft\n  };\n};\nconst getWrapArea = page => {\n  var _page$style;\n  const height = (_page$style = page.style) === null || _page$style === void 0 ? void 0 : _page$style.height;\n  const {\n    paddingBottom\n  } = getPadding(page);\n  return height - paddingBottom;\n};\nconst getContentArea = page => {\n  var _page$style2;\n  const height = (_page$style2 = page.style) === null || _page$style2 === void 0 ? void 0 : _page$style2.height;\n  const {\n    paddingTop,\n    paddingBottom\n  } = getPadding(page);\n  return height - paddingBottom - paddingTop;\n};\nconst isString = value => typeof value === 'string';\nconst isNumber = value => typeof value === 'number';\nconst isBoolean = value => typeof value === 'boolean';\nconst isFragment = value => value && value.type === Symbol.for('react.fragment');\n/**\n * Transforms a react element instance to internal element format.\n *\n * Can return multiple instances in the case of arrays or fragments.\n *\n * @param element - React element\n * @returns Parsed React elements\n */\nconst createInstances = element => {\n  if (!element) return [];\n  if (Array.isArray(element)) {\n    return element.reduce((acc, el) => acc.concat(createInstances(el)), []);\n  }\n  if (isBoolean(element)) {\n    return [];\n  }\n  if (isString(element) || isNumber(element)) {\n    return [{\n      type: P.TextInstance,\n      value: \"\".concat(element)\n    }];\n  }\n  if (isFragment(element)) {\n    // @ts-expect-error figure out why this is complains\n    return createInstances(element.props.children);\n  }\n  if (!isString(element.type)) {\n    // @ts-expect-error figure out why this is complains\n    return createInstances(element.type(element.props));\n  }\n  const {\n      type,\n      props: {\n        style = {},\n        children\n      }\n    } = element,\n    props = _objectWithoutProperties(element.props, _excluded);\n  const nextChildren = castArray(children).reduce((acc, child) => acc.concat(createInstances(child)), []);\n  return [{\n    type,\n    style,\n    props,\n    children: nextChildren\n  }];\n};\nconst getBreak = node => 'break' in node.props ? node.props.break : false;\nconst getMinPresenceAhead = node => 'minPresenceAhead' in node.props ? node.props.minPresenceAhead : 0;\nconst getFurthestEnd = elements => Math.max(...elements.map(node => node.box.top + node.box.height));\nconst getEndOfMinPresenceAhead = child => {\n  return child.box.top + child.box.height + child.box.marginBottom + getMinPresenceAhead(child);\n};\nconst getEndOfPresence = (child, futureElements) => {\n  const afterMinPresenceAhead = getEndOfMinPresenceAhead(child);\n  const endOfFurthestFutureElement = getFurthestEnd(futureElements.filter(node => !('fixed' in node.props)));\n  return Math.min(afterMinPresenceAhead, endOfFurthestFutureElement);\n};\nconst shouldBreak = (child, futureElements, height, previousElements) => {\n  if ('fixed' in child.props) return false;\n  const shouldSplit = height < child.box.top + child.box.height;\n  const canWrap = getWrap(child);\n  // Calculate the y coordinate where the desired presence of the child ends\n  const endOfPresence = getEndOfPresence(child, futureElements);\n  // If the child is already at the top of the page, breaking won't improve its presence\n  // (as long as react-pdf does not support breaking into differently sized containers)\n  const breakingImprovesPresence = previousElements.filter(node => !isFixed(node)).length > 0;\n  return getBreak(child) || shouldSplit && !canWrap || !shouldSplit && endOfPresence > height && breakingImprovesPresence;\n};\nconst IGNORABLE_CODEPOINTS = [8232,\n// LINE_SEPARATOR\n8233 // PARAGRAPH_SEPARATOR\n];\nconst buildSubsetForFont = font => IGNORABLE_CODEPOINTS.reduce((acc, codePoint) => {\n  if (font && font.hasGlyphForCodePoint && font.hasGlyphForCodePoint(codePoint)) {\n    return acc;\n  }\n  return [...acc, String.fromCharCode(codePoint)];\n}, []);\nconst ignoreChars = fragments => fragments.map(fragment => {\n  const charSubset = buildSubsetForFont(fragment.attributes.font[0]);\n  const subsetRegex = new RegExp(charSubset.join('|'));\n  return {\n    string: fragment.string.replace(subsetRegex, ''),\n    attributes: fragment.attributes\n  };\n});\nconst PREPROCESSORS = [ignoreChars, embedEmojis];\nconst isImage$1 = node => node.type === P.Image;\nconst isTextInstance$2 = node => node.type === P.TextInstance;\n/**\n * Get textkit fragments of given node object\n *\n * @param fontStore - Font store\n * @param instance - Node\n * @param parentLink - Parent link\n * @param level - Fragment level\n * @returns Text fragments\n */\nconst getFragments = function (fontStore, instance) {\n  var _instance$props, _instance$props2;\n  let parentLink = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let level = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  if (!instance) return [{\n    string: ''\n  }];\n  let fragments = [];\n  const {\n    color = 'black',\n    direction = 'ltr',\n    fontFamily = 'Helvetica',\n    fontWeight,\n    fontStyle,\n    fontSize = 18,\n    textAlign,\n    lineHeight,\n    textDecoration,\n    textDecorationColor,\n    textDecorationStyle,\n    textTransform,\n    letterSpacing,\n    textIndent,\n    opacity,\n    verticalAlign\n  } = instance.style;\n  const fontFamilies = typeof fontFamily === 'string' ? [fontFamily] : [...(fontFamily || [])];\n  // Fallback font\n  fontFamilies.push('Helvetica');\n  const font = fontFamilies.map(fontFamilyName => {\n    const opts = {\n      fontFamily: fontFamilyName,\n      fontWeight,\n      fontStyle\n    };\n    const obj = fontStore.getFont(opts);\n    return obj === null || obj === void 0 ? void 0 : obj.data;\n  });\n  // Don't pass main background color to textkit. Will be rendered by the render package instead\n  const backgroundColor = level === 0 ? null : instance.style.backgroundColor;\n  const attributes = {\n    font,\n    color,\n    opacity,\n    fontSize,\n    lineHeight,\n    direction,\n    verticalAlign,\n    backgroundColor,\n    indent: textIndent,\n    characterSpacing: letterSpacing,\n    strikeStyle: textDecorationStyle,\n    underlineStyle: textDecorationStyle,\n    underline: textDecoration === 'underline' || textDecoration === 'underline line-through' || textDecoration === 'line-through underline',\n    strike: textDecoration === 'line-through' || textDecoration === 'underline line-through' || textDecoration === 'line-through underline',\n    strikeColor: textDecorationColor || color,\n    underlineColor: textDecorationColor || color,\n    // @ts-expect-error allow this props access\n    link: parentLink || ((_instance$props = instance.props) === null || _instance$props === void 0 ? void 0 : _instance$props.src) || ((_instance$props2 = instance.props) === null || _instance$props2 === void 0 ? void 0 : _instance$props2.href),\n    align: textAlign || (direction === 'rtl' ? 'right' : 'left')\n  };\n  for (let i = 0; i < instance.children.length; i += 1) {\n    const child = instance.children[i];\n    if (isImage$1(child)) {\n      fragments.push({\n        string: String.fromCharCode(0xfffc),\n        attributes: _objectSpread(_objectSpread({}, attributes), {}, {\n          attachment: {\n            width: child.style.width || fontSize,\n            height: child.style.height || fontSize,\n            image: child.image.data\n          }\n        })\n      });\n    } else if (isTextInstance$2(child)) {\n      fragments.push({\n        string: transformText(child.value, textTransform),\n        attributes\n      });\n    } else if (child) {\n      fragments.push(...getFragments(fontStore, child, attributes.link, level + 1));\n    }\n  }\n  for (let i = 0; i < PREPROCESSORS.length; i += 1) {\n    const preprocessor = PREPROCESSORS[i];\n    fragments = preprocessor(fragments);\n  }\n  return fragments;\n};\n/**\n * Get textkit attributed string from text node\n *\n * @param fontStore - Font store\n * @param instance Node\n * @returns Attributed string\n */\nconst getAttributedString = (fontStore, instance) => {\n  const fragments = getFragments(fontStore, instance);\n  return fromFragments(fragments);\n};\nconst engines = {\n  bidi,\n  linebreaker,\n  justification,\n  textDecoration,\n  scriptItemizer,\n  wordHyphenation,\n  fontSubstitution\n};\nconst engine = layoutEngine(engines);\nconst getMaxLines = node => {\n  var _node$style4;\n  return (_node$style4 = node.style) === null || _node$style4 === void 0 ? void 0 : _node$style4.maxLines;\n};\nconst getTextOverflow = node => {\n  var _node$style5;\n  return (_node$style5 = node.style) === null || _node$style5 === void 0 ? void 0 : _node$style5.textOverflow;\n};\n/**\n * Get layout container for specific text node\n *\n * @param {number} width\n * @param {number} height\n * @param {Object} node\n * @returns {Object} layout container\n */\nconst getContainer = (width, height, node) => {\n  const maxLines = getMaxLines(node);\n  const textOverflow = getTextOverflow(node);\n  return {\n    x: 0,\n    y: 0,\n    width,\n    maxLines,\n    height: height || Infinity,\n    truncateMode: textOverflow\n  };\n};\n/**\n * Get text layout options for specific text node\n *\n * @param {Object} node instance\n * @returns {Object} layout options\n */\nconst getLayoutOptions = (fontStore, node) => ({\n  hyphenationPenalty: node.props.hyphenationPenalty,\n  shrinkWhitespaceFactor: {\n    before: -0.5,\n    after: -0.5\n  },\n  hyphenationCallback: node.props.hyphenationCallback || (fontStore === null || fontStore === void 0 ? void 0 : fontStore.getHyphenationCallback()) || null\n});\n/**\n * Get text lines for given node\n *\n * @param node - Node\n * @param width - Container width\n * @param height - Container height\n * @param fontStore - Font store\n * @returns Layout lines\n */\nconst layoutText = (node, width, height, fontStore) => {\n  const attributedString = getAttributedString(fontStore, node);\n  const container = getContainer(width, height, node);\n  const options = getLayoutOptions(fontStore, node);\n  const lines = engine(attributedString, container, options);\n  return lines.reduce((acc, line) => [...acc, ...line], []);\n};\nconst isSvg$2 = node => node.type === P.Svg;\nconst isText$4 = node => node.type === P.Text;\nconst shouldIterate = node => !isSvg$2(node) && !isText$4(node);\nconst shouldLayoutText = node => isText$4(node) && !node.lines;\n/**\n * Performs text layout on text node if wasn't calculated before.\n * Text layout is usually performed on Yoga's layout process (via setMeasureFunc),\n * but we need to layout those nodes with fixed width and height.\n *\n * @param node\n * @returns Layout node\n */\nconst resolveTextLayout = (node, fontStore) => {\n  if (shouldLayoutText(node)) {\n    const width = node.box.width - (node.box.paddingRight + node.box.paddingLeft);\n    const height = node.box.height - (node.box.paddingTop + node.box.paddingBottom);\n    node.lines = layoutText(node, width, height, fontStore);\n  }\n  if (shouldIterate(node)) {\n    if (!node.children) return node;\n    const mapChild = child => resolveTextLayout(child, fontStore);\n    const children = node.children.map(mapChild);\n    return Object.assign({}, node, {\n      children\n    });\n  }\n  return node;\n};\nconst BASE_INHERITABLE_PROPERTIES = ['color', 'fontFamily', 'fontSize', 'fontStyle', 'fontWeight', 'letterSpacing', 'opacity', 'textDecoration', 'textTransform', 'lineHeight', 'textAlign', 'visibility', 'wordSpacing'];\nconst TEXT_INHERITABLE_PROPERTIES = [...BASE_INHERITABLE_PROPERTIES, 'backgroundColor'];\nconst isType$2 = type => node => node.type === type;\nconst isSvg$1 = isType$2(P.Svg);\nconst isText$3 = isType$2(P.Text);\n// Merge style values\nconst mergeValues = (styleName, value, inheritedValue) => {\n  switch (styleName) {\n    case 'textDecoration':\n      {\n        // merge not none and not false textDecoration values to one rule\n        return [inheritedValue, value].filter(v => v && v !== 'none').join(' ');\n      }\n    default:\n      return value;\n  }\n};\n// Merge inherited and node styles\nconst merge = (inheritedStyles, style) => {\n  const mergedStyles = _objectSpread({}, inheritedStyles);\n  Object.entries(style).forEach(_ref2 => {\n    let [styleName, value] = _ref2;\n    mergedStyles[styleName] = mergeValues(styleName, value, inheritedStyles[styleName]);\n  });\n  return mergedStyles;\n};\n/**\n * Merges styles with node\n *\n * @param inheritedStyles - Style object\n * @returns Merge styles function\n */\nconst mergeStyles = inheritedStyles => node => {\n  const style = merge(inheritedStyles, node.style || {});\n  return Object.assign({}, node, {\n    style\n  });\n};\n/**\n * Inherit style values from the root to the leafs\n *\n * @param node - Document root\n * @returns Document root with inheritance\n *\n */\nconst resolveInheritance = node => {\n  if (isSvg$1(node)) return node;\n  if (!('children' in node)) return node;\n  const inheritableProperties = isText$3(node) ? TEXT_INHERITABLE_PROPERTIES : BASE_INHERITABLE_PROPERTIES;\n  const inheritStyles = pick(inheritableProperties, node.style || {});\n  const resolveChild = compose(resolveInheritance, mergeStyles(inheritStyles));\n  const children = node.children.map(resolveChild);\n  return Object.assign({}, node, {\n    children\n  });\n};\nconst getComputedMargin = (node, edge) => {\n  const {\n    yogaNode\n  } = node;\n  return yogaNode ? yogaNode.getComputedMargin(edge) : null;\n};\n/**\n * Get Yoga computed magins. Zero otherwise\n *\n * @param node\n * @returns Margins\n */\nconst getMargin = node => {\n  const {\n    style,\n    box\n  } = node;\n  const marginTop = getComputedMargin(node, Yoga.Edge.Top) || (box === null || box === void 0 ? void 0 : box.marginTop) || (style === null || style === void 0 ? void 0 : style.marginTop) || 0;\n  const marginRight = getComputedMargin(node, Yoga.Edge.Right) || (box === null || box === void 0 ? void 0 : box.marginRight) || (style === null || style === void 0 ? void 0 : style.marginRight) || 0;\n  const marginBottom = getComputedMargin(node, Yoga.Edge.Bottom) || (box === null || box === void 0 ? void 0 : box.marginBottom) || (style === null || style === void 0 ? void 0 : style.marginBottom) || 0;\n  const marginLeft = getComputedMargin(node, Yoga.Edge.Left) || (box === null || box === void 0 ? void 0 : box.marginLeft) || (style === null || style === void 0 ? void 0 : style.marginLeft) || 0;\n  return {\n    marginTop,\n    marginRight,\n    marginBottom,\n    marginLeft\n  };\n};\n\n/**\n * Get Yoga computed position. Zero otherwise\n *\n * @param node\n * @returns Position\n */\nconst getPosition = node => {\n  const {\n    yogaNode\n  } = node;\n  return {\n    top: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedTop()) || 0,\n    right: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedRight()) || 0,\n    bottom: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedBottom()) || 0,\n    left: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedLeft()) || 0\n  };\n};\nconst DEFAULT_DIMENSION = {\n  width: 0,\n  height: 0\n};\n/**\n * Get Yoga computed dimensions. Zero otherwise\n *\n * @param node\n * @returns Dimensions\n */\nconst getDimension = node => {\n  const {\n    yogaNode\n  } = node;\n  if (!yogaNode) return DEFAULT_DIMENSION;\n  return {\n    width: yogaNode.getComputedWidth(),\n    height: yogaNode.getComputedHeight()\n  };\n};\nconst getComputedBorder = (yogaNode, edge) => yogaNode ? yogaNode.getComputedBorder(edge) : 0;\n/**\n * Get Yoga computed border width. Zero otherwise\n *\n * @param node\n * @returns Border widths\n */\nconst getBorderWidth = node => {\n  const {\n    yogaNode\n  } = node;\n  return {\n    borderTopWidth: getComputedBorder(yogaNode, Yoga.Edge.Top),\n    borderRightWidth: getComputedBorder(yogaNode, Yoga.Edge.Right),\n    borderBottomWidth: getComputedBorder(yogaNode, Yoga.Edge.Bottom),\n    borderLeftWidth: getComputedBorder(yogaNode, Yoga.Edge.Left)\n  };\n};\n\n/**\n * Set display attribute to node's Yoga instance\n *\n * @param value - Display\n * @returns Node instance wrapper\n */\nconst setDisplay = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (yogaNode) {\n    yogaNode.setDisplay(value === 'none' ? Yoga.Display.None : Yoga.Display.Flex);\n  }\n  return node;\n};\nconst OVERFLOW = {\n  hidden: Yoga.Overflow.Hidden,\n  scroll: Yoga.Overflow.Scroll\n};\n/**\n * Set overflow attribute to node's Yoga instance\n *\n * @param value - Overflow value\n * @returns Node instance wrapper\n */\nconst setOverflow = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (!isNil(value) && yogaNode) {\n    const overflow = OVERFLOW[value] || Yoga.Overflow.Visible;\n    yogaNode.setOverflow(overflow);\n  }\n  return node;\n};\nconst FLEX_WRAP = {\n  wrap: Yoga.Wrap.Wrap,\n  'wrap-reverse': Yoga.Wrap.WrapReverse\n};\n/**\n * Set flex wrap attribute to node's Yoga instance\n *\n * @param value - Flex wrap value\n * @returns Node instance wrapper\n */\nconst setFlexWrap = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (yogaNode) {\n    const flexWrap = FLEX_WRAP[value] || Yoga.Wrap.NoWrap;\n    yogaNode.setFlexWrap(flexWrap);\n  }\n  return node;\n};\n\n/**\n * Set generic yoga attribute to node's Yoga instance, handing `auto`, edges and percentage cases\n *\n * @param attr - Property\n * @param edge - Edge\n * @returns Node instance wrapper\n */\nconst setYogaValue = (attr, edge) => value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (!isNil(value) && yogaNode) {\n    const hasEdge = !isNil(edge);\n    const fixedMethod = \"set\".concat(upperFirst(attr));\n    const autoMethod = \"\".concat(fixedMethod, \"Auto\");\n    const percentMethod = \"\".concat(fixedMethod, \"Percent\");\n    const percent = matchPercent(value);\n    if (percent && !yogaNode[percentMethod]) {\n      throw new Error(\"You can't pass percentage values to \".concat(attr, \" property\"));\n    }\n    if (percent) {\n      if (hasEdge) {\n        var _yogaNode$percentMeth;\n        (_yogaNode$percentMeth = yogaNode[percentMethod]) === null || _yogaNode$percentMeth === void 0 || _yogaNode$percentMeth.call(yogaNode, edge, percent.value);\n      } else {\n        var _yogaNode$percentMeth2;\n        (_yogaNode$percentMeth2 = yogaNode[percentMethod]) === null || _yogaNode$percentMeth2 === void 0 || _yogaNode$percentMeth2.call(yogaNode, percent.value);\n      }\n    } else if (value === 'auto') {\n      if (hasEdge) {\n        var _yogaNode$autoMethod;\n        (_yogaNode$autoMethod = yogaNode[autoMethod]) === null || _yogaNode$autoMethod === void 0 || _yogaNode$autoMethod.call(yogaNode, edge);\n      } else {\n        var _yogaNode$autoMethod2;\n        (_yogaNode$autoMethod2 = yogaNode[autoMethod]) === null || _yogaNode$autoMethod2 === void 0 || _yogaNode$autoMethod2.call(yogaNode);\n      }\n    } else if (hasEdge) {\n      var _yogaNode$fixedMethod;\n      (_yogaNode$fixedMethod = yogaNode[fixedMethod]) === null || _yogaNode$fixedMethod === void 0 || _yogaNode$fixedMethod.call(yogaNode, edge, value);\n    } else {\n      var _yogaNode$fixedMethod2;\n      (_yogaNode$fixedMethod2 = yogaNode[fixedMethod]) === null || _yogaNode$fixedMethod2 === void 0 || _yogaNode$fixedMethod2.call(yogaNode, value);\n    }\n  }\n  return node;\n};\n\n/**\n * Set flex grow attribute to node's Yoga instance\n *\n * @param  value - Flex grow value\n * @returns Node instance wrapper\n */\nconst setFlexGrow = value => node => {\n  return setYogaValue('flexGrow')(value || 0)(node);\n};\n\n/**\n * Set flex basis attribute to node's Yoga instance\n *\n * @param flex - Basis value\n * @param node - Node instance\n * @returns Node instance\n */\nconst setFlexBasis = setYogaValue('flexBasis');\nconst ALIGN = {\n  'flex-start': Yoga.Align.FlexStart,\n  center: Yoga.Align.Center,\n  'flex-end': Yoga.Align.FlexEnd,\n  stretch: Yoga.Align.Stretch,\n  baseline: Yoga.Align.Baseline,\n  'space-between': Yoga.Align.SpaceBetween,\n  'space-around': Yoga.Align.SpaceAround,\n  'space-evenly': Yoga.Align.SpaceEvenly\n};\n/**\n * Set generic align attribute to node's Yoga instance\n *\n * @param attr - Specific align property\n * @param value - Specific align value\n * @param node - Node\n * @returns Node\n */\nconst setAlign = attr => value => node => {\n  const {\n    yogaNode\n  } = node;\n  const defaultValue = attr === 'items' ? Yoga.Align.Stretch : Yoga.Align.Auto;\n  if (yogaNode) {\n    const align = ALIGN[value] || defaultValue;\n    yogaNode[\"setAlign\".concat(upperFirst(attr))](align);\n  }\n  return node;\n};\n\n/**\n * Set align self attribute to node's Yoga instance\n *\n * @param align - Value\n * @param node - Node instance\n * @returns Node instance\n */\nconst setAlignSelf = setAlign('self');\n\n/**\n * Set align items attribute to node's Yoga instance\n *\n * @param align - Value\n * @param node - Node instance\n * @returns Node instance\n */\nconst setAlignItems = setAlign('items');\n\n/**\n * Set flex shrink attribute to node's Yoga instance\n *\n * @param value - Flex shrink value\n * @returns Node instance wrapper\n */\nconst setFlexShrink = value => node => {\n  return setYogaValue('flexShrink')(value || 1)(node);\n};\n\n/**\n * Set aspect ratio attribute to node's Yoga instance\n *\n * @param value - Ratio\n * @returns Node instance\n */\nconst setAspectRatio = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (!isNil(value) && yogaNode) {\n    yogaNode.setAspectRatio(value);\n  }\n  return node;\n};\n\n/**\n * Set align content attribute to node's Yoga instance\n *\n * @param align - Value\n * @param node - Instance\n * @returns Node instance\n */\nconst setAlignContent = setAlign('content');\nconst POSITION = {\n  absolute: Yoga.PositionType.Absolute,\n  relative: Yoga.PositionType.Relative,\n  static: Yoga.PositionType.Static\n};\n/**\n * Set position type attribute to node's Yoga instance\n *\n * @param value - Position position type\n * @returns Node instance\n */\nconst setPositionType = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (!isNil(value) && yogaNode) {\n    yogaNode.setPositionType(POSITION[value]);\n  }\n  return node;\n};\nconst FLEX_DIRECTIONS = {\n  row: Yoga.FlexDirection.Row,\n  'row-reverse': Yoga.FlexDirection.RowReverse,\n  'column-reverse': Yoga.FlexDirection.ColumnReverse\n};\n/**\n * Set flex direction attribute to node's Yoga instance\n *\n * @param value - Flex direction value\n * @returns Node instance wrapper\n */\nconst setFlexDirection = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (yogaNode) {\n    const flexDirection = FLEX_DIRECTIONS[value] || Yoga.FlexDirection.Column;\n    yogaNode.setFlexDirection(flexDirection);\n  }\n  return node;\n};\nconst JUSTIFY_CONTENT = {\n  center: Yoga.Justify.Center,\n  'flex-end': Yoga.Justify.FlexEnd,\n  'space-between': Yoga.Justify.SpaceBetween,\n  'space-around': Yoga.Justify.SpaceAround,\n  'space-evenly': Yoga.Justify.SpaceEvenly\n};\n/**\n * Set justify content attribute to node's Yoga instance\n *\n * @param value - Justify content value\n * @returns Node instance wrapper\n */\nconst setJustifyContent = value => node => {\n  const {\n    yogaNode\n  } = node;\n  if (!isNil(value) && yogaNode) {\n    const justifyContent = JUSTIFY_CONTENT[value] || Yoga.Justify.FlexStart;\n    yogaNode.setJustifyContent(justifyContent);\n  }\n  return node;\n};\n\n/**\n * Set margin top attribute to node's Yoga instance\n *\n * @param margin - Margin top\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMarginTop = setYogaValue('margin', Yoga.Edge.Top);\n/**\n * Set margin right attribute to node's Yoga instance\n *\n * @param margin - Margin right\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMarginRight = setYogaValue('margin', Yoga.Edge.Right);\n/**\n * Set margin bottom attribute to node's Yoga instance\n *\n * @param margin - Margin bottom\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMarginBottom = setYogaValue('margin', Yoga.Edge.Bottom);\n/**\n * Set margin left attribute to node's Yoga instance\n *\n * @param margin - Margin left\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMarginLeft = setYogaValue('margin', Yoga.Edge.Left);\n\n/**\n * Set padding top attribute to node's Yoga instance\n *\n * @param padding - Padding top\n * @param node - Node instance\n * @returns Node instance\n */\nconst setPaddingTop = setYogaValue('padding', Yoga.Edge.Top);\n/**\n * Set padding right attribute to node's Yoga instance\n *\n * @param padding - Padding right\n * @param node - Node instance\n * @returns Node instance\n */\nconst setPaddingRight = setYogaValue('padding', Yoga.Edge.Right);\n/**\n * Set padding bottom attribute to node's Yoga instance\n *\n * @param padding - Padding bottom\n * @param node Node instance\n * @returns Node instance\n */\nconst setPaddingBottom = setYogaValue('padding', Yoga.Edge.Bottom);\n/**\n * Set padding left attribute to node's Yoga instance\n *\n * @param padding - Padding left\n * @param node - Node instance\n * @returns Node instance\n */\nconst setPaddingLeft = setYogaValue('padding', Yoga.Edge.Left);\n\n/**\n * Set border top attribute to node's Yoga instance\n *\n * @param border - Border top width\n * @param node - Node instance\n * @returns Node instance\n */\nconst setBorderTop = setYogaValue('border', Yoga.Edge.Top);\n/**\n * Set border right attribute to node's Yoga instance\n *\n * @param border - Border right width\n * @param node - Node instance\n * @returns Node instance\n */\nconst setBorderRight = setYogaValue('border', Yoga.Edge.Right);\n/**\n * Set border bottom attribute to node's Yoga instance\n *\n * @param border - Border bottom width\n * @param node - Node instance\n * @returns Node instance\n */\nconst setBorderBottom = setYogaValue('border', Yoga.Edge.Bottom);\n/**\n * Set border left attribute to node's Yoga instance\n *\n * @param border - Border left width\n * @param node - Node instance\n * @returns Node instance\n */\nconst setBorderLeft = setYogaValue('border', Yoga.Edge.Left);\n\n/**\n * Set position top attribute to node's Yoga instance\n *\n * @param position - Position top\n * @param node - Node instance\n * @returns Node instance\n */\nconst setPositionTop = setYogaValue('position', Yoga.Edge.Top);\n/**\n * Set position right attribute to node's Yoga instance\n *\n * @param position - Position right\n * @param node - Node instance\n * @returns Node instance\n */\nconst setPositionRight = setYogaValue('position', Yoga.Edge.Right);\n/**\n * Set position bottom attribute to node's Yoga instance\n *\n * @param position - Position bottom\n * @param node - Node instance\n * @returns Node instance\n */\nconst setPositionBottom = setYogaValue('position', Yoga.Edge.Bottom);\n/**\n * Set position left attribute to node's Yoga instance\n *\n * @param position - Position left\n * @param node - Node instance\n * @returns Node instance\n */\nconst setPositionLeft = setYogaValue('position', Yoga.Edge.Left);\n\n/**\n * Set width to node's Yoga instance\n *\n * @param width - Width\n * @param node - Node instance\n * @returns Node instance\n */\nconst setWidth = setYogaValue('width');\n/**\n * Set min width to node's Yoga instance\n *\n * @param min - Width\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMinWidth = setYogaValue('minWidth');\n/**\n * Set max width to node's Yoga instance\n *\n * @param max - Width\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMaxWidth = setYogaValue('maxWidth');\n/**\n * Set height to node's Yoga instance\n *\n * @param height - Height\n * @param node - Node instance\n * @returns Node instance\n */\nconst setHeight = setYogaValue('height');\n/**\n * Set min height to node's Yoga instance\n *\n * @param min - Height\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMinHeight = setYogaValue('minHeight');\n/**\n * Set max height to node's Yoga instance\n *\n * @param max - Height\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMaxHeight = setYogaValue('maxHeight');\n\n/**\n * Set rowGap value to node's Yoga instance\n *\n * @param value - Gap value\n * @returns Node instance wrapper\n */\nconst setRowGap = setYogaValue('gap', Yoga.Gutter.Row);\n/**\n * Set columnGap value to node's Yoga instance\n *\n * @param value - Gap value\n * @returns Node instance wrapper\n */\nconst setColumnGap = setYogaValue('gap', Yoga.Gutter.Column);\nconst getAspectRatio = viewbox => {\n  if (!viewbox) return null;\n  if (typeof viewbox === 'string') return null;\n  return (viewbox.maxX - viewbox.minX) / (viewbox.maxY - viewbox.minY);\n};\n/**\n * Yoga svg measure function\n *\n * @param page\n * @param node\n * @returns Measure svg\n */\nconst measureCanvas$1 = (page, node) => (width, widthMode, height, heightMode) => {\n  const aspectRatio = getAspectRatio(node.props.viewBox) || 1;\n  if (widthMode === Yoga.MeasureMode.Exactly || widthMode === Yoga.MeasureMode.AtMost) {\n    return {\n      width,\n      height: width / aspectRatio\n    };\n  }\n  if (heightMode === Yoga.MeasureMode.Exactly) {\n    return {\n      width: height * aspectRatio\n    };\n  }\n  return {};\n};\n\n/**\n * Get lines width (if any)\n *\n * @param node\n * @returns Lines width\n */\nconst linesWidth = node => {\n  if (!node.lines) return 0;\n  return Math.max(0, ...node.lines.map(line => line.xAdvance));\n};\n\n/**\n * Get lines height (if any)\n *\n * @param node\n * @returns Lines height\n */\nconst linesHeight = node => {\n  if (!node.lines) return -1;\n  return node.lines.reduce((acc, line) => acc + line.box.height, 0);\n};\nconst ALIGNMENT_FACTORS = {\n  center: 0.5,\n  right: 1\n};\n/**\n * Yoga text measure function\n *\n * @param page\n * @param node\n * @param fontStore\n * @returns {MeasureText} measure text function\n */\nconst measureText = (page, node, fontStore) => (width, widthMode, height) => {\n  if (widthMode === Yoga.MeasureMode.Exactly) {\n    if (!node.lines) node.lines = layoutText(node, width, height, fontStore);\n    return {\n      height: linesHeight(node),\n      width\n    };\n  }\n  if (widthMode === Yoga.MeasureMode.AtMost) {\n    var _node$style6;\n    const alignFactor = ALIGNMENT_FACTORS[(_node$style6 = node.style) === null || _node$style6 === void 0 ? void 0 : _node$style6.textAlign] || 0;\n    if (!node.lines) {\n      node.lines = layoutText(node, width, height, fontStore);\n      node.alignOffset = (width - linesWidth(node)) * alignFactor; // Compensate align in variable width containers\n    }\n    return {\n      height: linesHeight(node),\n      width: Math.min(width, linesWidth(node))\n    };\n  }\n  return {};\n};\n\n/**\n * Get image ratio\n *\n * @param node - Image node\n * @returns Image ratio\n */\nconst getRatio = node => {\n  var _node$image;\n  return (_node$image = node.image) !== null && _node$image !== void 0 && _node$image.data ? node.image.width / node.image.height : 1;\n};\n\n/**\n * Checks if page has auto height\n *\n * @param page\n * @returns Is page height auto\n */\nconst isHeightAuto = page => {\n  var _page$box3;\n  return isNil((_page$box3 = page.box) === null || _page$box3 === void 0 ? void 0 : _page$box3.height);\n};\nconst SAFETY_HEIGHT$1 = 10;\n/**\n * Yoga image measure function\n *\n * @param page - Page\n * @param node - Node\n * @returns Measure image\n */\nconst measureImage = (page, node) => (width, widthMode, height, heightMode) => {\n  var _page$box4;\n  const imageRatio = getRatio(node);\n  const imageMargin = getMargin(node);\n  const pagePadding = getPadding(page);\n  // TODO: Check image percentage margins\n  const pageArea = isHeightAuto(page) ? Infinity : (((_page$box4 = page.box) === null || _page$box4 === void 0 ? void 0 : _page$box4.height) || 0) - pagePadding.paddingTop - pagePadding.paddingBottom - imageMargin.marginTop - imageMargin.marginBottom - SAFETY_HEIGHT$1;\n  // Skip measure if image data not present yet\n  if (!node.image) return {\n    width: 0,\n    height: 0\n  };\n  if (widthMode === Yoga.MeasureMode.Exactly && heightMode === Yoga.MeasureMode.Undefined) {\n    const scaledHeight = width / imageRatio;\n    return {\n      height: Math.min(pageArea, scaledHeight)\n    };\n  }\n  if (heightMode === Yoga.MeasureMode.Exactly && (widthMode === Yoga.MeasureMode.AtMost || widthMode === Yoga.MeasureMode.Undefined)) {\n    return {\n      width: Math.min(height * imageRatio, width)\n    };\n  }\n  if (widthMode === Yoga.MeasureMode.Exactly && heightMode === Yoga.MeasureMode.AtMost) {\n    const scaledHeight = width / imageRatio;\n    return {\n      height: Math.min(height, pageArea, scaledHeight)\n    };\n  }\n  if (widthMode === Yoga.MeasureMode.AtMost && heightMode === Yoga.MeasureMode.AtMost) {\n    if (imageRatio > 1) {\n      return {\n        width,\n        height: Math.min(width / imageRatio, height)\n      };\n    }\n    return {\n      height,\n      width: Math.min(height * imageRatio, width)\n    };\n  }\n  return {\n    height,\n    width\n  };\n};\nconst SAFETY_HEIGHT = 10;\nconst getMax = values => Math.max(-Infinity, ...values);\n/**\n * Helper object to predict canvas size\n * TODO: Implement remaining functions (as close as possible);\n */\nconst measureCtx = () => {\n  const ctx = {};\n  const points = [];\n  const nil = () => ctx;\n  const addPoint = (x, y) => points.push([x, y]);\n  const moveTo = (x, y) => {\n    addPoint(x, y);\n    return ctx;\n  };\n  const rect = (x, y, w, h) => {\n    addPoint(x, y);\n    addPoint(x + w, y);\n    addPoint(x, y + h);\n    addPoint(x + w, y + h);\n    return ctx;\n  };\n  const ellipse = (x, y, rx, ry) => {\n    ry = ry || rx;\n    addPoint(x - rx, y - ry);\n    addPoint(x + rx, y - ry);\n    addPoint(x + rx, y + ry);\n    addPoint(x - rx, y + ry);\n    return ctx;\n  };\n  const polygon = function () {\n    points.push(...arguments);\n    return ctx;\n  };\n  // Change dimensions\n  ctx.rect = rect;\n  ctx.moveTo = moveTo;\n  ctx.lineTo = moveTo;\n  ctx.circle = ellipse;\n  ctx.polygon = polygon;\n  ctx.ellipse = ellipse;\n  ctx.roundedRect = rect;\n  // To be implemented\n  ctx.text = nil;\n  ctx.path = nil;\n  ctx.lineWidth = nil;\n  ctx.bezierCurveTo = nil;\n  ctx.quadraticCurveTo = nil;\n  ctx.scale = nil;\n  ctx.rotate = nil;\n  ctx.translate = nil;\n  // These don't change dimensions\n  ctx.dash = nil;\n  ctx.clip = nil;\n  ctx.save = nil;\n  ctx.fill = nil;\n  ctx.font = nil;\n  ctx.stroke = nil;\n  ctx.lineCap = nil;\n  ctx.opacity = nil;\n  ctx.restore = nil;\n  ctx.lineJoin = nil;\n  ctx.fontSize = nil;\n  ctx.fillColor = nil;\n  ctx.miterLimit = nil;\n  ctx.strokeColor = nil;\n  ctx.fillOpacity = nil;\n  ctx.strokeOpacity = nil;\n  ctx.linearGradient = nil;\n  ctx.radialGradient = nil;\n  ctx.getWidth = () => getMax(points.map(p => p[0]));\n  ctx.getHeight = () => getMax(points.map(p => p[1]));\n  return ctx;\n};\n/**\n * @typedef {Function} MeasureCanvas\n * @returns {{ width: number, height: number }} canvas width and height\n */\n/**\n * Yoga canvas measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @returns {MeasureCanvas} measure canvas\n */\nconst measureCanvas = (page, node) => () => {\n  var _page$box5;\n  const imageMargin = getMargin(node);\n  const pagePadding = getPadding(page);\n  // TODO: Check image percentage margins\n  const pageArea = isHeightAuto(page) ? Infinity : (((_page$box5 = page.box) === null || _page$box5 === void 0 ? void 0 : _page$box5.height) || 0) - pagePadding.paddingTop - pagePadding.paddingBottom - imageMargin.marginTop - imageMargin.marginBottom - SAFETY_HEIGHT;\n  const ctx = measureCtx();\n  node.props.paint(ctx);\n  const width = ctx.getWidth();\n  const height = Math.min(pageArea, ctx.getHeight());\n  return {\n    width,\n    height\n  };\n};\nconst isType$1 = type => node => node.type === type;\nconst isSvg = isType$1(P.Svg);\nconst isText$2 = isType$1(P.Text);\nconst isNote = isType$1(P.Note);\nconst isPage = isType$1(P.Page);\nconst isImage = isType$1(P.Image);\nconst isCanvas = isType$1(P.Canvas);\nconst isTextInstance$1 = isType$1(P.TextInstance);\nconst setNodeHeight = node => {\n  var _node$box3, _node$style7;\n  const value = isPage(node) ? (_node$box3 = node.box) === null || _node$box3 === void 0 ? void 0 : _node$box3.height : (_node$style7 = node.style) === null || _node$style7 === void 0 ? void 0 : _node$style7.height;\n  return setHeight(value);\n};\n/**\n * Set styles valeus into yoga node before layout calculation\n *\n * @param node\n */\nconst setYogaValues = node => {\n  compose(setNodeHeight(node), setWidth(node.style.width), setMinWidth(node.style.minWidth), setMaxWidth(node.style.maxWidth), setMinHeight(node.style.minHeight), setMaxHeight(node.style.maxHeight), setMarginTop(node.style.marginTop), setMarginRight(node.style.marginRight), setMarginBottom(node.style.marginBottom), setMarginLeft(node.style.marginLeft), setPaddingTop(node.style.paddingTop), setPaddingRight(node.style.paddingRight), setPaddingBottom(node.style.paddingBottom), setPaddingLeft(node.style.paddingLeft), setPositionType(node.style.position), setPositionTop(node.style.top), setPositionRight(node.style.right), setPositionBottom(node.style.bottom), setPositionLeft(node.style.left), setBorderTop(node.style.borderTopWidth), setBorderRight(node.style.borderRightWidth), setBorderBottom(node.style.borderBottomWidth), setBorderLeft(node.style.borderLeftWidth), setDisplay(node.style.display), setFlexDirection(node.style.flexDirection), setAlignSelf(node.style.alignSelf), setAlignContent(node.style.alignContent), setAlignItems(node.style.alignItems), setJustifyContent(node.style.justifyContent), setFlexWrap(node.style.flexWrap), setOverflow(node.style.overflow), setAspectRatio(node.style.aspectRatio), setFlexBasis(node.style.flexBasis), setFlexGrow(node.style.flexGrow), setFlexShrink(node.style.flexShrink), setRowGap(node.style.rowGap), setColumnGap(node.style.columnGap))(node);\n};\n/**\n * Inserts child into parent' yoga node\n *\n * @param parent parent\n * @returns Insert yoga nodes\n */\nconst insertYogaNodes = parent => child => {\n  parent.insertChild(child.yogaNode, parent.getChildCount());\n  return child;\n};\nconst setMeasureFunc = (node, page, fontStore) => {\n  const {\n    yogaNode\n  } = node;\n  if (isText$2(node)) {\n    yogaNode.setMeasureFunc(measureText(page, node, fontStore));\n  }\n  if (isImage(node)) {\n    yogaNode.setMeasureFunc(measureImage(page, node));\n  }\n  if (isCanvas(node)) {\n    yogaNode.setMeasureFunc(measureCanvas(page, node));\n  }\n  if (isSvg(node)) {\n    yogaNode.setMeasureFunc(measureCanvas$1(page, node));\n  }\n  return node;\n};\nconst isLayoutElement = node => !isText$2(node) && !isNote(node) && !isSvg(node);\n/**\n * @typedef {Function} CreateYogaNodes\n * @param {Object} node\n * @returns {Object} node with appended yoga node\n */\n/**\n * Creates and add yoga node to document tree\n * Handles measure function for text and image nodes\n *\n * @returns Create yoga nodes\n */\nconst createYogaNodes = (page, fontStore, yoga) => node => {\n  const yogaNode = yoga.node.create();\n  const result = Object.assign({}, node, {\n    yogaNode\n  });\n  setYogaValues(result);\n  if (isLayoutElement(node) && node.children) {\n    const resolveChild = compose(insertYogaNodes(yogaNode), createYogaNodes(page, fontStore, yoga));\n    result.children = node.children.map(resolveChild);\n  }\n  setMeasureFunc(result, page, fontStore);\n  return result;\n};\n/**\n * Performs yoga calculation\n *\n * @param page - Page node\n * @returns Page node\n */\nconst calculateLayout = page => {\n  page.yogaNode.calculateLayout();\n  return page;\n};\n/**\n * Saves Yoga layout result into 'box' attribute of node\n *\n * @param node\n * @returns Node with box data\n */\nconst persistDimensions = node => {\n  if (isTextInstance$1(node)) return node;\n  const box = Object.assign(getPadding(node), getMargin(node), getBorderWidth(node), getPosition(node), getDimension(node));\n  const newNode = Object.assign({}, node, {\n    box\n  });\n  if (!node.children) return newNode;\n  const children = node.children.map(persistDimensions);\n  return Object.assign({}, newNode, {\n    children\n  });\n};\n/**\n * Removes yoga node from document tree\n *\n * @param node\n * @returns Node without yoga node\n */\nconst destroyYogaNodes = node => {\n  const newNode = Object.assign({}, node);\n  delete newNode.yogaNode;\n  if (!node.children) return newNode;\n  const children = node.children.map(destroyYogaNodes);\n  return Object.assign({}, newNode, {\n    children\n  });\n};\n/**\n * Free yoga node from document tree\n *\n * @param node\n * @returns Node without yoga node\n */\nconst freeYogaNodes = node => {\n  if (node.yogaNode) node.yogaNode.freeRecursive();\n  return node;\n};\n/**\n * Calculates page object layout using Yoga.\n * Takes node values from 'box' and 'style' attributes, and persist them back into 'box'\n * Destroy yoga values at the end.\n *\n * @param page - Object\n * @returns Page object with correct 'box' layout attributes\n */\nconst resolvePageDimensions = (page, fontStore, yoga) => {\n  if (isNil(page)) return null;\n  return compose(destroyYogaNodes, freeYogaNodes, persistDimensions, calculateLayout, createYogaNodes(page, fontStore, yoga))(page);\n};\n/**\n * Calculates root object layout using Yoga.\n *\n * @param node - Root object\n * @param fontStore - Font store\n * @returns Root object with correct 'box' layout attributes\n */\nconst resolveDimensions = (node, fontStore) => {\n  if (!node.children) return node;\n  const resolveChild = child => resolvePageDimensions(child, fontStore, node.yoga);\n  const children = node.children.map(resolveChild);\n  return Object.assign({}, node, {\n    children\n  });\n};\nconst isText$1 = node => node.type === P.Text;\n// Prevent splitting elements by low decimal numbers\nconst SAFETY_THRESHOLD = 0.001;\nconst assingChildren = (children, node) => Object.assign({}, node, {\n  children\n});\nconst getTop = node => {\n  var _node$box4;\n  return ((_node$box4 = node.box) === null || _node$box4 === void 0 ? void 0 : _node$box4.top) || 0;\n};\nconst allFixed = nodes => nodes.every(isFixed);\nconst isDynamic = node => node.props && 'render' in node.props;\nconst relayoutPage = compose(resolveTextLayout, resolvePageDimensions, resolveInheritance, resolvePageStyles);\nconst warnUnavailableSpace = node => {\n  console.warn(\"Node of type \".concat(node.type, \" can't wrap between pages and it's bigger than available page height\"));\n};\nconst splitNodes = (height, contentArea, nodes) => {\n  const currentChildren = [];\n  const nextChildren = [];\n  for (let i = 0; i < nodes.length; i += 1) {\n    const child = nodes[i];\n    const futureNodes = nodes.slice(i + 1);\n    const futureFixedNodes = futureNodes.filter(isFixed);\n    const nodeTop = getTop(child);\n    const nodeHeight = child.box.height;\n    const isOutside = height <= nodeTop;\n    const shouldBreak$1 = shouldBreak(child, futureNodes, height, currentChildren);\n    const shouldSplit = height + SAFETY_THRESHOLD < nodeTop + nodeHeight;\n    const canWrap = getWrap(child);\n    const fitsInsidePage = nodeHeight <= contentArea;\n    if (isFixed(child)) {\n      nextChildren.push(child);\n      currentChildren.push(child);\n      continue;\n    }\n    if (isOutside) {\n      const box = Object.assign({}, child.box, {\n        top: child.box.top - height\n      });\n      const next = Object.assign({}, child, {\n        box\n      });\n      nextChildren.push(next);\n      continue;\n    }\n    if (!fitsInsidePage && !canWrap) {\n      currentChildren.push(child);\n      nextChildren.push(...futureNodes);\n      warnUnavailableSpace(child);\n      break;\n    }\n    if (shouldBreak$1) {\n      const box = Object.assign({}, child.box, {\n        top: child.box.top - height\n      });\n      const props = Object.assign({}, child.props, {\n        wrap: true,\n        break: false\n      });\n      const next = Object.assign({}, child, {\n        box,\n        props\n      });\n      currentChildren.push(...futureFixedNodes);\n      nextChildren.push(next, ...futureNodes);\n      break;\n    }\n    if (shouldSplit) {\n      const [currentChild, nextChild] = split(child, height, contentArea);\n      // All children are moved to the next page, it doesn't make sense to show the parent on the current page\n      if (child.children.length > 0 && currentChild.children.length === 0) {\n        // But if the current page is empty then we can just include the parent on the current page\n        if (currentChildren.length === 0) {\n          currentChildren.push(child, ...futureFixedNodes);\n          nextChildren.push(...futureNodes);\n        } else {\n          const box = Object.assign({}, child.box, {\n            top: child.box.top - height\n          });\n          const next = Object.assign({}, child, {\n            box\n          });\n          currentChildren.push(...futureFixedNodes);\n          nextChildren.push(next, ...futureNodes);\n        }\n        break;\n      }\n      if (currentChild) currentChildren.push(currentChild);\n      if (nextChild) nextChildren.push(nextChild);\n      continue;\n    }\n    currentChildren.push(child);\n  }\n  return [currentChildren, nextChildren];\n};\nconst splitChildren = (height, contentArea, node) => {\n  const children = node.children || [];\n  const availableHeight = height - getTop(node);\n  return splitNodes(availableHeight, contentArea, children);\n};\nconst splitView = (node, height, contentArea) => {\n  const [currentNode, nextNode] = splitNode(node, height);\n  const [currentChilds, nextChildren] = splitChildren(height, contentArea, node);\n  return [assingChildren(currentChilds, currentNode), assingChildren(nextChildren, nextNode)];\n};\nconst split = (node, height, contentArea) => isText$1(node) ? splitText(node, height) : splitView(node, height, contentArea);\nconst shouldResolveDynamicNodes = node => {\n  const children = node.children || [];\n  return isDynamic(node) || children.some(shouldResolveDynamicNodes);\n};\nconst resolveDynamicNodes = (props, node) => {\n  const isNodeDynamic = isDynamic(node);\n  // Call render prop on dynamic nodes and append result to children\n  const resolveChildren = function () {\n    let children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    if (isNodeDynamic) {\n      const res = node.props.render(props);\n      return createInstances(res).filter(Boolean)\n      // @ts-expect-error rework dynamic nodes. conflicting types\n      .map(n => resolveDynamicNodes(props, n));\n    }\n    return children.map(c => resolveDynamicNodes(props, c));\n  };\n  // We reset dynamic text box so it can be computed again later on\n  const resetHeight = isNodeDynamic && isText$1(node);\n  const box = resetHeight ? _objectSpread(_objectSpread({}, node.box), {}, {\n    height: 0\n  }) : node.box;\n  const children = resolveChildren(node.children);\n  // @ts-expect-error handle text here specifically\n  const lines = isNodeDynamic ? null : node.lines;\n  return Object.assign({}, node, {\n    box,\n    lines,\n    children\n  });\n};\nconst resolveDynamicPage = (props, page, fontStore, yoga) => {\n  if (shouldResolveDynamicNodes(page)) {\n    const resolvedPage = resolveDynamicNodes(props, page);\n    return relayoutPage(resolvedPage, fontStore, yoga);\n  }\n  return page;\n};\nconst splitPage = (page, pageNumber, fontStore, yoga) => {\n  const wrapArea = getWrapArea(page);\n  const contentArea = getContentArea(page);\n  const dynamicPage = resolveDynamicPage({\n    pageNumber\n  }, page, fontStore, yoga);\n  const height = page.style.height;\n  const [currentChilds, nextChilds] = splitNodes(wrapArea, contentArea, dynamicPage.children);\n  const relayout = node =>\n  // @ts-expect-error rework pagination\n  relayoutPage(node, fontStore, yoga);\n  const currentBox = _objectSpread(_objectSpread({}, page.box), {}, {\n    height\n  });\n  const currentPage = relayout(Object.assign({}, page, {\n    box: currentBox,\n    children: currentChilds\n  }));\n  if (nextChilds.length === 0 || allFixed(nextChilds)) return [currentPage, null];\n  const nextBox = omit('height', page.box);\n  const nextProps = omit('bookmark', page.props);\n  const nextPage = relayout(Object.assign({}, page, {\n    props: nextProps,\n    box: nextBox,\n    children: nextChilds\n  }));\n  return [currentPage, nextPage];\n};\nconst resolvePageIndices = (fontStore, yoga, page, pageNumber, pages) => {\n  const totalPages = pages.length;\n  const props = {\n    totalPages,\n    pageNumber: pageNumber + 1,\n    subPageNumber: page.subPageNumber + 1,\n    subPageTotalPages: page.subPageTotalPages\n  };\n  return resolveDynamicPage(props, page, fontStore, yoga);\n};\nconst assocSubPageData = subpages => {\n  return subpages.map((page, i) => _objectSpread(_objectSpread({}, page), {}, {\n    subPageNumber: i,\n    subPageTotalPages: subpages.length\n  }));\n};\nconst dissocSubPageData = page => {\n  return omit(['subPageNumber', 'subPageTotalPages'], page);\n};\nconst paginate = (page, pageNumber, fontStore, yoga) => {\n  var _page$props6;\n  if (!page) return [];\n  if (((_page$props6 = page.props) === null || _page$props6 === void 0 ? void 0 : _page$props6.wrap) === false) return [page];\n  let splittedPage = splitPage(page, pageNumber, fontStore, yoga);\n  const pages = [splittedPage[0]];\n  let nextPage = splittedPage[1];\n  while (nextPage !== null) {\n    splittedPage = splitPage(nextPage, pageNumber + pages.length, fontStore, yoga);\n    pages.push(splittedPage[0]);\n    nextPage = splittedPage[1];\n  }\n  return pages;\n};\n/**\n * Performs pagination. This is the step responsible of breaking the whole document\n * into pages following pagiation rules, such as `fixed`, `break` and dynamic nodes.\n *\n * @param root - Document node\n * @param fontStore - Font store\n * @returns Layout node\n */\nconst resolvePagination = (root, fontStore) => {\n  let pages = [];\n  let pageNumber = 1;\n  for (let i = 0; i < root.children.length; i += 1) {\n    const page = root.children[i];\n    let subpages = paginate(page, pageNumber, fontStore, root.yoga);\n    subpages = assocSubPageData(subpages);\n    pageNumber += subpages.length;\n    pages = pages.concat(subpages);\n  }\n  pages = pages.map(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return dissocSubPageData(resolvePageIndices(fontStore, root.yoga, ...args));\n  });\n  return assingChildren(pages, root);\n};\n\n/**\n * Translates page percentage horizontal paddings in fixed ones\n *\n * @param container - Page container\n * @returns Resolve page horizontal padding\n */\nconst resolvePageHorizontalPadding = container => value => {\n  const match = matchPercent(value);\n  const width = container.width;\n  return match ? match.percent * width : value;\n};\n/**\n * Translates page percentage vertical paddings in fixed ones\n *\n * @param container - Page container\n * @returns Resolve page vertical padding\n */\nconst resolvePageVerticalPadding = container => value => {\n  const match = matchPercent(value);\n  const height = container.height;\n  return match ? match.percent * height : value;\n};\n/**\n * Translates page percentage paddings in fixed ones\n *\n * @param page\n * @returns Page with fixed paddings\n */\nconst resolvePagePaddings = page => {\n  const container = page.style;\n  const style = evolve({\n    paddingTop: resolvePageVerticalPadding(container),\n    paddingLeft: resolvePageHorizontalPadding(container),\n    paddingRight: resolvePageHorizontalPadding(container),\n    paddingBottom: resolvePageVerticalPadding(container)\n  }, page.style);\n  return Object.assign({}, page, {\n    style\n  });\n};\n/**\n * Translates all pages percentage paddings in fixed ones\n * This has to be computed from pages calculated size and not by Yoga\n * because at this point we didn't performed pagination yet.\n *\n * @param root - Document root\n * @returns Document root with translated page paddings\n */\nconst resolvePagesPaddings = root => {\n  if (!root.children) return root;\n  const children = root.children.map(resolvePagePaddings);\n  return Object.assign({}, root, {\n    children\n  });\n};\nconst resolveRadius = box => value => {\n  if (!value) return undefined;\n  const match = matchPercent(value);\n  return match ? match.percent * Math.min(box.width, box.height) : value;\n};\n/**\n * Transforms percent border radius into fixed values\n *\n * @param node\n * @returns Node\n */\nconst resolvePercentRadius = node => {\n  const style = evolve({\n    borderTopLeftRadius: resolveRadius(node.box),\n    borderTopRightRadius: resolveRadius(node.box),\n    borderBottomRightRadius: resolveRadius(node.box),\n    borderBottomLeftRadius: resolveRadius(node.box)\n  }, node.style || {});\n  const newNode = Object.assign({}, node, {\n    style\n  });\n  if (!node.children) return newNode;\n  const children = node.children.map(resolvePercentRadius);\n  return Object.assign({}, newNode, {\n    children\n  });\n};\n\n/**\n * Transform percent height into fixed\n *\n * @param height\n * @returns Height\n */\nconst transformHeight = (pageArea, height) => {\n  const match = matchPercent(height);\n  return match ? match.percent * pageArea : height;\n};\n/**\n * Get page area (height minus paddings)\n *\n * @param page\n * @returns Page area\n */\nconst getPageArea = page => {\n  var _page$style3, _page$style4;\n  const pageHeight = page.style.height;\n  const pagePaddingTop = ((_page$style3 = page.style) === null || _page$style3 === void 0 ? void 0 : _page$style3.paddingTop) || 0;\n  const pagePaddingBottom = ((_page$style4 = page.style) === null || _page$style4 === void 0 ? void 0 : _page$style4.paddingBottom) || 0;\n  return pageHeight - pagePaddingTop - pagePaddingBottom;\n};\n/**\n * Transform node percent height to fixed\n *\n * @param page\n * @param node\n * @returns Transformed node\n */\nconst resolveNodePercentHeight = (page, node) => {\n  var _page$style5, _node$style8;\n  if (isNil((_page$style5 = page.style) === null || _page$style5 === void 0 ? void 0 : _page$style5.height)) return node;\n  if (isNil((_node$style8 = node.style) === null || _node$style8 === void 0 ? void 0 : _node$style8.height)) return node;\n  const pageArea = getPageArea(page);\n  const height = transformHeight(pageArea, node.style.height);\n  const style = Object.assign({}, node.style, {\n    height\n  });\n  return Object.assign({}, node, {\n    style\n  });\n};\n/**\n * Transform page immediate children with percent height to fixed\n *\n * @param page\n * @returns Transformed page\n */\nconst resolvePagePercentHeight = page => {\n  if (!page.children) return page;\n  const resolveChild = child => resolveNodePercentHeight(page, child);\n  const children = page.children.map(resolveChild);\n  return Object.assign({}, page, {\n    children\n  });\n};\n/**\n * Transform all page immediate children with percent height to fixed.\n * This is needed for computing correct dimensions on pre-pagination layout.\n *\n * @param root - Document root\n * @returns Transformed document root\n */\nconst resolvePercentHeight = root => {\n  if (!root.children) return root;\n  const children = root.children.map(resolvePagePercentHeight);\n  return Object.assign({}, root, {\n    children\n  });\n};\nconst isType = type => node => node.type === type;\nconst isLink = isType(P.Link);\nconst isText = isType(P.Text);\nconst isTextInstance = isType(P.TextInstance);\n/**\n * Checks if node has render prop\n *\n * @param node\n * @returns Has render prop?\n */\nconst hasRenderProp = node => 'render' in node.props;\n/**\n * Checks if node is text type (Text or TextInstance)\n *\n * @param node\n * @returns Are all children text instances?\n */\nconst isTextType = node => isText(node) || isTextInstance(node);\n/**\n * Checks if is tet link that needs to be wrapped in Text\n *\n * @param node\n * @returns Are all children text instances?\n */\nconst isTextLink = node => {\n  const children = node.children || [];\n  // Text string inside a Link\n  if (children.every(isTextInstance)) return true;\n  // Text node inside a Link\n  if (children.every(isText)) return false;\n  return children.every(isTextType);\n};\n/**\n * Wraps node children inside Text node\n *\n * @param node\n * @returns Node with intermediate Text child\n */\nconst wrapText = node => {\n  const textElement = {\n    type: P.Text,\n    props: {},\n    style: {},\n    box: {},\n    children: node.children\n  };\n  return Object.assign({}, node, {\n    children: [textElement]\n  });\n};\nconst transformLink = node => {\n  if (!isLink(node)) return node;\n  // If has render prop substitute the instance by a Text, that will\n  // ultimately render the inline Link via the textkit PDF renderer.\n  if (hasRenderProp(node)) return Object.assign({}, node, {\n    type: P.Text\n  });\n  // If is a text link (either contains Text or TextInstance), wrap it\n  // inside a Text element so styles are applied correctly\n  if (isTextLink(node)) return wrapText(node);\n  return node;\n};\n/**\n * Transforms Link layout to correctly render text and dynamic rendered links\n *\n * @param node\n * @returns Node with link substitution\n */\nconst resolveLinkSubstitution = node => {\n  if (!node.children) return node;\n  const resolveChild = compose(transformLink, resolveLinkSubstitution);\n  const children = node.children.map(resolveChild);\n  return Object.assign({}, node, {\n    children\n  });\n};\nconst layout = asyncCompose(resolveZIndex, resolveOrigin, resolveAssets, resolvePagination, resolveTextLayout, resolvePercentRadius, resolveDimensions, resolveSvg, resolveAssets, resolveInheritance, resolvePercentHeight, resolvePagesPaddings, resolveStyles, resolveLinkSubstitution, resolveBookmarks, resolvePageSizes, resolveYoga);\nexport { layout as default };","map":{"version":3,"names":["upperFirst","capitalize","parseFloat","parseFloat$1","without","pick","compose","evolve","mapValues","matchPercent","castArray","isNil","omit","asyncCompose","P","resolveStyle","transformColor","flatten","layoutEngine","fontSubstitution","wordHyphenation","scriptItemizer","textDecoration","justification","linebreaker","bidi","fromFragments","Yoga","loadYoga","loadYoga$1","emojiRegex","resolveImage","transformText","text","transformation","toUpperCase","toLowerCase","isTspan","node","type","Tspan","isTextInstance$4","TextInstance","engines$1","engine$1","getFragments$1","fontStore","instance","string","fragments","fill","fontFamily","fontWeight","fontStyle","fontSize","textDecorationColor","textDecorationStyle","textTransform","opacity","props","_textDecoration","fontFamilies","push","font","map","fontFamilyName","opts","obj","getFont","data","attributes","color","underlineStyle","underline","underlineColor","strike","strikeStyle","strikeColor","i","children","length","child","value","getAttributedString$1","AlmostInfinity","shrinkWhitespaceFactor","before","after","layoutTspan","xOffset","_node$props","attributedString","x","undefined","y","container","width","height","hyphenationCallback","getHyphenationCallback","layoutOptions","lines","flat","Object","assign","joinTSpanLines","index","textInstance","_objectSpread","concat","layoutText$1","_node$props2","currentXOffset","layoutFn","joinedNode","childWithLayout","xAdvance","isDefs","Defs","getDefs","defs","find","values","reduce","acc","_value$props","id","isNotDefs","detachDefs","filter","URL_REGEX","replaceDef","test","match","parseNodeDefs","clipPath","newProps","parseDefs","root","replaceDefs","parseViewbox","split","minX","minY","maxX","maxY","getContainer$1","viewbox","viewBox","BASE_SVG_INHERITED_PROPS","TEXT_SVG_INHERITED_PROPS","SVG_INHERITED_PROPS","Text","getInheritProps","_SVG_INHERITED_PROPS$","svgInheritedProps","inheritProps","inheritedProps","newChild","parseAspectRatio","replace","align","meetOrSlice","STYLE_PROPS","VERTICAL_PROPS","HORIZONTAL_PROPS","isSvg$3","Svg","isText$5","isTextInstance$3","transformPercent","key","includes","percent","parsePercent","parseTransform","transform","parseProps","x1","x2","y1","y2","r","rx","ry","cx","cy","offset","stroke","stopOpacity","stopColor","gradientTransform","mergeStyles$1","style","removeNoneValues","removeNone","pickStyleProps","styleProps","parseSvgProps","preserveAspectRatio","wrapBetweenTspan","addMissingTspan","resolveChild","parseText","resolveSvgNode","resolveChildren","buildXLinksIndex","_node$children","idIndex","listToExplore","slice","shift","replaceXLinks","_node$children2","linkedNode","xlinkHref","resolveXLinks","resolveSvgRoot","resolveSvg","_root$children","instancePromise","config","Config","create","setPointScaleFactor","Node","createWithConfig","resolveYoga","yoga","getZIndex","zIndex","shouldSort","Document","sortZIndex","a","b","za","zb","resolveNodeZIndex","sortedChildren","sort","resolveZIndex","emojis","regex","removeVariationSelectors","getCodePoints","withVariationSelectors","arguments","Array","from","char","codePointAt","toString","join","buildEmojiUrl","emoji","source","builder","url","format","fetchEmojis","promises","matchAll","forEach","loading","emojiUrl","uri","then","image","catch","e","console","warn","embedEmojis","result","fragment","lastIndex","emojiSize","chunk","String","fromCharCode","attachment","yOffset","Math","floor","getSource","src","resolveSource","fetchImage","cache","Error","Buffer","isBuffer","Blob","message","isImage$2","Image","fetchAssets","_node$children3","emojiSource","getEmojiSource","_n$style","n","load","childNode","resolveAssets","Promise","all","isLink$1","Link","DEFAULT_LINK_STYLES","computeStyle","baseStyle","isArray","resolveNodeStyles","resolvePageStyles","page","_page$props","_page$box","_page$box2","_page$props2","dpi","box","orientation","remBase","resolveStyles","getTransformStyle","s","_node$style","_node$style$s","_node$style2","getOrigin","left","top","transformOriginX","transformOriginY","percentX","percentY","offsetX","offsetY","resolveNodeOrigin","origin","newNode","resolveOrigin","getBookmarkValue","bookmark","title","fit","expanded","resolveBookmarks","refs","parent","element","_parent","ref","newHierarchy","VALID_ORIENTATIONS","getOrientation","_page$props3","isLandscape","PAGE_SIZES","A0","A1","A2","A3","A4","A5","A6","A7","A8","A9","A10","B0","B1","B2","B3","B4","B5","B6","B7","B8","B9","B10","C0","C1","C2","C3","C4","C5","C6","C7","C8","C9","C10","RA0","RA1","RA2","RA3","RA4","SRA0","SRA1","SRA2","SRA3","SRA4","EXECUTIVE","FOLIO","LEGAL","LETTER","TABLOID","ID1","parseValue","unit","exec","transformUnit","inputDpi","scalar","outputDpi","mmFactor","cmFactor","round","transformUnits","_ref","toSizeObject","v","flipSizeObject","getStringSize","getNumberSize","getSize","_page$props4","_page$props5","size","resolvePageSize","resolvePageSizes","isFixed","fixed","lineIndexAtHeight","line","heightAtLineIndex","counter","getLineBreak","_node$box","widows","orphans","linesQuantity","slicedLine","splitText","slicedLineIndex","currentHeight","nextHeight","current","borderBottomWidth","marginBottom","paddingBottom","borderBottomLeftRadius","borderBottomRightRadius","next","borderTopWidth","marginTop","paddingTop","borderTopLeftRadius","borderTopRightRadius","getTop$1","_node$box2","hasFixedHeight","_node$style3","splitNode","nodeTop","NON_WRAP_TYPES","Note","Canvas","getWrap","wrap","getComputedPadding","edge","yogaNode","getPadding","Edge","Top","paddingRight","Right","Bottom","paddingLeft","Left","getWrapArea","_page$style","getContentArea","_page$style2","isString","isNumber","isBoolean","isFragment","Symbol","for","createInstances","el","_objectWithoutProperties","_excluded","nextChildren","getBreak","break","getMinPresenceAhead","minPresenceAhead","getFurthestEnd","elements","max","getEndOfMinPresenceAhead","getEndOfPresence","futureElements","afterMinPresenceAhead","endOfFurthestFutureElement","min","shouldBreak","previousElements","shouldSplit","canWrap","endOfPresence","breakingImprovesPresence","IGNORABLE_CODEPOINTS","buildSubsetForFont","codePoint","hasGlyphForCodePoint","ignoreChars","charSubset","subsetRegex","RegExp","PREPROCESSORS","isImage$1","isTextInstance$2","getFragments","_instance$props","_instance$props2","parentLink","level","direction","textAlign","lineHeight","letterSpacing","textIndent","verticalAlign","backgroundColor","indent","characterSpacing","link","href","preprocessor","getAttributedString","engines","engine","getMaxLines","_node$style4","maxLines","getTextOverflow","_node$style5","textOverflow","getContainer","Infinity","truncateMode","getLayoutOptions","hyphenationPenalty","layoutText","options","isSvg$2","isText$4","shouldIterate","shouldLayoutText","resolveTextLayout","mapChild","BASE_INHERITABLE_PROPERTIES","TEXT_INHERITABLE_PROPERTIES","isType$2","isSvg$1","isText$3","mergeValues","styleName","inheritedValue","merge","inheritedStyles","mergedStyles","entries","_ref2","mergeStyles","resolveInheritance","inheritableProperties","inheritStyles","getComputedMargin","getMargin","marginRight","marginLeft","getPosition","getComputedTop","right","getComputedRight","bottom","getComputedBottom","getComputedLeft","DEFAULT_DIMENSION","getDimension","getComputedWidth","getComputedHeight","getComputedBorder","getBorderWidth","borderRightWidth","borderLeftWidth","setDisplay","Display","None","Flex","OVERFLOW","hidden","Overflow","Hidden","scroll","Scroll","setOverflow","overflow","Visible","FLEX_WRAP","Wrap","WrapReverse","setFlexWrap","flexWrap","NoWrap","setYogaValue","attr","hasEdge","fixedMethod","autoMethod","percentMethod","_yogaNode$percentMeth","call","_yogaNode$percentMeth2","_yogaNode$autoMethod","_yogaNode$autoMethod2","_yogaNode$fixedMethod","_yogaNode$fixedMethod2","setFlexGrow","setFlexBasis","ALIGN","Align","FlexStart","center","Center","FlexEnd","stretch","Stretch","baseline","Baseline","SpaceBetween","SpaceAround","SpaceEvenly","setAlign","defaultValue","Auto","setAlignSelf","setAlignItems","setFlexShrink","setAspectRatio","setAlignContent","POSITION","absolute","PositionType","Absolute","relative","Relative","static","Static","setPositionType","FLEX_DIRECTIONS","row","FlexDirection","Row","RowReverse","ColumnReverse","setFlexDirection","flexDirection","Column","JUSTIFY_CONTENT","Justify","setJustifyContent","justifyContent","setMarginTop","setMarginRight","setMarginBottom","setMarginLeft","setPaddingTop","setPaddingRight","setPaddingBottom","setPaddingLeft","setBorderTop","setBorderRight","setBorderBottom","setBorderLeft","setPositionTop","setPositionRight","setPositionBottom","setPositionLeft","setWidth","setMinWidth","setMaxWidth","setHeight","setMinHeight","setMaxHeight","setRowGap","Gutter","setColumnGap","getAspectRatio","measureCanvas$1","widthMode","heightMode","aspectRatio","MeasureMode","Exactly","AtMost","linesWidth","linesHeight","ALIGNMENT_FACTORS","measureText","_node$style6","alignFactor","alignOffset","getRatio","_node$image","isHeightAuto","_page$box3","SAFETY_HEIGHT$1","measureImage","_page$box4","imageRatio","imageMargin","pagePadding","pageArea","Undefined","scaledHeight","SAFETY_HEIGHT","getMax","measureCtx","ctx","points","nil","addPoint","moveTo","rect","w","h","ellipse","polygon","lineTo","circle","roundedRect","path","lineWidth","bezierCurveTo","quadraticCurveTo","scale","rotate","translate","dash","clip","save","lineCap","restore","lineJoin","fillColor","miterLimit","strokeColor","fillOpacity","strokeOpacity","linearGradient","radialGradient","getWidth","p","getHeight","measureCanvas","_page$box5","paint","isType$1","isSvg","isText$2","isNote","isPage","Page","isImage","isCanvas","isTextInstance$1","setNodeHeight","_node$box3","_node$style7","setYogaValues","minWidth","maxWidth","minHeight","maxHeight","position","display","alignSelf","alignContent","alignItems","flexBasis","flexGrow","flexShrink","rowGap","columnGap","insertYogaNodes","insertChild","getChildCount","setMeasureFunc","isLayoutElement","createYogaNodes","calculateLayout","persistDimensions","destroyYogaNodes","freeYogaNodes","freeRecursive","resolvePageDimensions","resolveDimensions","isText$1","SAFETY_THRESHOLD","assingChildren","getTop","_node$box4","allFixed","nodes","every","isDynamic","relayoutPage","warnUnavailableSpace","splitNodes","contentArea","currentChildren","futureNodes","futureFixedNodes","nodeHeight","isOutside","shouldBreak$1","fitsInsidePage","currentChild","nextChild","splitChildren","availableHeight","splitView","currentNode","nextNode","currentChilds","shouldResolveDynamicNodes","some","resolveDynamicNodes","isNodeDynamic","res","render","Boolean","c","resetHeight","resolveDynamicPage","resolvedPage","splitPage","pageNumber","wrapArea","dynamicPage","nextChilds","relayout","currentBox","currentPage","nextBox","nextProps","nextPage","resolvePageIndices","pages","totalPages","subPageNumber","subPageTotalPages","assocSubPageData","subpages","dissocSubPageData","paginate","_page$props6","splittedPage","resolvePagination","_len","args","_key","resolvePageHorizontalPadding","resolvePageVerticalPadding","resolvePagePaddings","resolvePagesPaddings","resolveRadius","resolvePercentRadius","transformHeight","getPageArea","_page$style3","_page$style4","pageHeight","pagePaddingTop","pagePaddingBottom","resolveNodePercentHeight","_page$style5","_node$style8","resolvePagePercentHeight","resolvePercentHeight","isType","isLink","isText","isTextInstance","hasRenderProp","isTextType","isTextLink","wrapText","textElement","transformLink","resolveLinkSubstitution","layout","default"],"sources":["C:/PreventaWeb/FrontEnd/node_modules/@react-pdf/layout/lib/index.js"],"sourcesContent":["import { upperFirst, capitalize, parseFloat as parseFloat$1, without, pick, compose, evolve, mapValues, matchPercent, castArray, isNil, omit, asyncCompose } from '@react-pdf/fns';\nimport * as P from '@react-pdf/primitives';\nimport resolveStyle, { transformColor, flatten } from '@react-pdf/stylesheet';\nimport layoutEngine, { fontSubstitution, wordHyphenation, scriptItemizer, textDecoration, justification, linebreaker, bidi, fromFragments } from '@react-pdf/textkit';\nimport * as Yoga from 'yoga-layout/load';\nimport { loadYoga as loadYoga$1 } from 'yoga-layout/load';\nimport emojiRegex from 'emoji-regex-xs';\nimport resolveImage from '@react-pdf/image';\n\n/**\n * Apply transformation to text string\n *\n * @param {string} text\n * @param {string} transformation type\n * @returns {string} transformed text\n */\nconst transformText = (text, transformation) => {\n    switch (transformation) {\n        case 'uppercase':\n            return text.toUpperCase();\n        case 'lowercase':\n            return text.toLowerCase();\n        case 'capitalize':\n            return capitalize(text);\n        case 'upperfirst':\n            return upperFirst(text);\n        default:\n            return text;\n    }\n};\n\nconst isTspan = (node) => node.type === P.Tspan;\nconst isTextInstance$4 = (node) => node.type === P.TextInstance;\nconst engines$1 = {\n    bidi,\n    linebreaker,\n    justification,\n    textDecoration,\n    scriptItemizer,\n    wordHyphenation,\n    fontSubstitution,\n};\nconst engine$1 = layoutEngine(engines$1);\nconst getFragments$1 = (fontStore, instance) => {\n    if (!instance)\n        return [{ string: '' }];\n    const fragments = [];\n    const { fill = 'black', fontFamily = 'Helvetica', fontWeight, fontStyle, fontSize = 18, textDecorationColor, textDecorationStyle, textTransform, opacity, } = instance.props;\n    const _textDecoration = instance.props.textDecoration;\n    const fontFamilies = typeof fontFamily === 'string' ? [fontFamily] : [...(fontFamily || [])];\n    // Fallback font\n    fontFamilies.push('Helvetica');\n    const font = fontFamilies.map((fontFamilyName) => {\n        const opts = { fontFamily: fontFamilyName, fontWeight, fontStyle };\n        const obj = fontStore.getFont(opts);\n        return obj?.data;\n    });\n    const attributes = {\n        font,\n        opacity,\n        fontSize,\n        color: fill,\n        underlineStyle: textDecorationStyle,\n        underline: _textDecoration === 'underline' ||\n            _textDecoration === 'underline line-through' ||\n            _textDecoration === 'line-through underline',\n        underlineColor: textDecorationColor || fill,\n        strike: _textDecoration === 'line-through' ||\n            _textDecoration === 'underline line-through' ||\n            _textDecoration === 'line-through underline',\n        strikeStyle: textDecorationStyle,\n        strikeColor: textDecorationColor || fill,\n    };\n    for (let i = 0; i < instance.children.length; i += 1) {\n        const child = instance.children[i];\n        if (isTextInstance$4(child)) {\n            fragments.push({\n                string: transformText(child.value, textTransform),\n                attributes,\n            });\n        }\n        else if (child) {\n            fragments.push(...getFragments$1(fontStore, child));\n        }\n    }\n    return fragments;\n};\nconst getAttributedString$1 = (fontStore, instance) => fromFragments(getFragments$1(fontStore, instance));\nconst AlmostInfinity = 999999999999;\nconst shrinkWhitespaceFactor = { before: -0.5, after: -0.5 };\nconst layoutTspan = (fontStore) => (node, xOffset) => {\n    const attributedString = getAttributedString$1(fontStore, node);\n    const x = node.props.x === undefined ? xOffset : node.props.x;\n    const y = node.props?.y || 0;\n    const container = { x, y, width: AlmostInfinity, height: AlmostInfinity };\n    const hyphenationCallback = node.props.hyphenationCallback ||\n        fontStore?.getHyphenationCallback() ||\n        null;\n    const layoutOptions = { hyphenationCallback, shrinkWhitespaceFactor };\n    const lines = engine$1(attributedString, container, layoutOptions).flat();\n    return Object.assign({}, node, { lines });\n};\n// Consecutive TSpan elements should be joined with a space\nconst joinTSpanLines = (node) => {\n    const children = node.children.map((child, index) => {\n        if (!isTspan(child))\n            return child;\n        const textInstance = child.children[0];\n        if (child.props.x === undefined &&\n            index < node.children.length - 1 &&\n            textInstance?.value) {\n            return Object.assign({}, child, {\n                children: [{ ...textInstance, value: `${textInstance.value} ` }],\n            });\n        }\n        return child;\n    }, []);\n    return Object.assign({}, node, { children });\n};\nconst layoutText$1 = (fontStore, node) => {\n    if (!node.children)\n        return node;\n    let currentXOffset = node.props?.x || 0;\n    const layoutFn = layoutTspan(fontStore);\n    const joinedNode = joinTSpanLines(node);\n    const children = joinedNode.children.map((child) => {\n        const childWithLayout = layoutFn(child, currentXOffset);\n        currentXOffset += childWithLayout.lines[0].xAdvance;\n        return childWithLayout;\n    });\n    return Object.assign({}, node, { children });\n};\n\nconst isDefs = (node) => node.type === P.Defs;\nconst getDefs = (node) => {\n    const children = node.children || [];\n    const defs = children.find(isDefs);\n    const values = defs?.children || [];\n    return values.reduce((acc, value) => {\n        const id = value.props?.id;\n        if (id)\n            acc[id] = value;\n        return acc;\n    }, {});\n};\n\nconst isNotDefs = (node) => node.type !== P.Defs;\nconst detachDefs = (node) => {\n    if (!node.children)\n        return node;\n    const children = node.children.filter(isNotDefs);\n    return Object.assign({}, node, { children });\n};\nconst URL_REGEX = /url\\(['\"]?#([^'\"]+)['\"]?\\)/;\nconst replaceDef = (defs, value) => {\n    if (!value)\n        return undefined;\n    if (!URL_REGEX.test(value))\n        return value;\n    const match = value.match(URL_REGEX);\n    return defs[match[1]];\n};\nconst parseNodeDefs = (defs) => (node) => {\n    const props = node.props;\n    const fill = `fill` in props ? replaceDef(defs, props?.fill) : undefined;\n    const clipPath = `clipPath` in props\n        ? replaceDef(defs, props?.clipPath)\n        : undefined;\n    const newProps = Object.assign({}, node.props, { fill, clipPath });\n    const children = node.children\n        ? node.children.map(parseNodeDefs(defs))\n        : undefined;\n    return Object.assign({}, node, { props: newProps, children });\n};\nconst parseDefs = (root) => {\n    if (!root.children)\n        return root;\n    const defs = getDefs(root);\n    const children = root.children.map(parseNodeDefs(defs));\n    return Object.assign({}, root, { children });\n};\nconst replaceDefs = (node) => {\n    return detachDefs(parseDefs(node));\n};\n\nconst parseViewbox = (value) => {\n    if (!value)\n        return null;\n    if (typeof value !== 'string')\n        return value;\n    const values = value.split(/[,\\s]+/).map(parseFloat$1);\n    if (values.length !== 4)\n        return null;\n    return { minX: values[0], minY: values[1], maxX: values[2], maxY: values[3] };\n};\n\nconst getContainer$1 = (node) => {\n    const viewbox = parseViewbox(node.props.viewBox);\n    if (viewbox) {\n        return { width: viewbox.maxX, height: viewbox.maxY };\n    }\n    if (node.props.width && node.props.height) {\n        return {\n            width: parseFloat$1(node.props.width),\n            height: parseFloat$1(node.props.height),\n        };\n    }\n    return { width: 0, height: 0 };\n};\n\nconst BASE_SVG_INHERITED_PROPS = [\n    'x',\n    'y',\n    'clipPath',\n    'clipRule',\n    'opacity',\n    'fill',\n    'fillOpacity',\n    'fillRule',\n    'stroke',\n    'strokeLinecap',\n    'strokeLinejoin',\n    'strokeOpacity',\n    'strokeWidth',\n    'textAnchor',\n    'dominantBaseline',\n    'color',\n    'fontFamily',\n    'fontSize',\n    'fontStyle',\n    'fontWeight',\n    'letterSpacing',\n    'opacity',\n    'textDecoration',\n    'lineHeight',\n    'textAlign',\n    'visibility',\n    'wordSpacing',\n];\n// Do not inherit \"x\" for <tspan> elements from <text> parent\nconst TEXT_SVG_INHERITED_PROPS = without(['x'], BASE_SVG_INHERITED_PROPS);\nconst SVG_INHERITED_PROPS = {\n    [P.Text]: TEXT_SVG_INHERITED_PROPS,\n};\nconst getInheritProps = (node) => {\n    const props = node.props || {};\n    const svgInheritedProps = SVG_INHERITED_PROPS[node.type] ?? BASE_SVG_INHERITED_PROPS;\n    return pick(svgInheritedProps, props);\n};\nconst inheritProps = (node) => {\n    if (!node.children)\n        return node;\n    const inheritedProps = getInheritProps(node);\n    const children = node.children.map((child) => {\n        const props = Object.assign({}, inheritedProps, child.props || {});\n        const newChild = Object.assign({}, child, { props });\n        return inheritProps(newChild);\n    });\n    return Object.assign({}, node, { children });\n};\n\nconst parseAspectRatio = (value) => {\n    if (typeof value !== 'string')\n        return value;\n    const match = value\n        .replace(/[\\s\\r\\t\\n]+/gm, ' ')\n        .replace(/^defer\\s/, '')\n        .split(' ');\n    const align = (match[0] || 'xMidYMid');\n    const meetOrSlice = (match[1] ||\n        'meet');\n    return { align, meetOrSlice };\n};\n\nconst STYLE_PROPS = [\n    'width',\n    'height',\n    'color',\n    'stroke',\n    'strokeWidth',\n    'opacity',\n    'fillOpacity',\n    'strokeOpacity',\n    'fill',\n    'fillRule',\n    'clipPath',\n    'offset',\n    'transform',\n    'strokeLinejoin',\n    'strokeLinecap',\n    'strokeDasharray',\n    'gradientUnits',\n    'gradientTransform',\n];\nconst VERTICAL_PROPS = ['y', 'y1', 'y2', 'height', 'cy', 'ry'];\nconst HORIZONTAL_PROPS = ['x', 'x1', 'x2', 'width', 'cx', 'rx'];\nconst isSvg$3 = (node) => node.type === P.Svg;\nconst isText$5 = (node) => node.type === P.Text;\nconst isTextInstance$3 = (node) => node.type === P.TextInstance;\nconst transformPercent = (container) => (props) => mapValues(props, (value, key) => {\n    const match = matchPercent(value);\n    if (match && VERTICAL_PROPS.includes(key)) {\n        return match.percent * container.height;\n    }\n    if (match && HORIZONTAL_PROPS.includes(key)) {\n        return match.percent * container.width;\n    }\n    return value;\n});\nconst parsePercent = (value) => {\n    const match = matchPercent(value);\n    return match ? match.percent : parseFloat$1(value);\n};\nconst parseTransform = (container) => (value) => {\n    return resolveStyle(container, { transform: value }).transform;\n};\nconst parseProps = (container) => (node) => {\n    let props = transformPercent(container)(node.props);\n    props = evolve({\n        x: parseFloat$1,\n        x1: parseFloat$1,\n        x2: parseFloat$1,\n        y: parseFloat$1,\n        y1: parseFloat$1,\n        y2: parseFloat$1,\n        r: parseFloat$1,\n        rx: parseFloat$1,\n        ry: parseFloat$1,\n        cx: parseFloat$1,\n        cy: parseFloat$1,\n        width: parseFloat$1,\n        height: parseFloat$1,\n        offset: parsePercent,\n        fill: transformColor,\n        opacity: parsePercent,\n        stroke: transformColor,\n        stopOpacity: parsePercent,\n        stopColor: transformColor,\n        transform: parseTransform(container),\n        gradientTransform: parseTransform(container),\n    }, props);\n    return Object.assign({}, node, { props });\n};\nconst mergeStyles$1 = (node) => {\n    const style = node.style || {};\n    const props = Object.assign({}, style, node.props);\n    return Object.assign({}, node, { props });\n};\nconst removeNoneValues = (node) => {\n    const removeNone = (value) => (value === 'none' ? null : value);\n    const props = mapValues(node.props, removeNone);\n    return Object.assign({}, node, { props });\n};\nconst pickStyleProps = (node) => {\n    const props = node.props || {};\n    const styleProps = pick(STYLE_PROPS, props);\n    const style = Object.assign({}, styleProps, node.style || {});\n    return Object.assign({}, node, { style });\n};\nconst parseSvgProps = (node) => {\n    const props = evolve({\n        width: parseFloat$1,\n        height: parseFloat$1,\n        viewBox: parseViewbox,\n        preserveAspectRatio: parseAspectRatio,\n    }, node.props);\n    return Object.assign({}, node, { props });\n};\nconst wrapBetweenTspan = (node) => ({\n    type: P.Tspan,\n    props: {},\n    style: {},\n    children: [node],\n});\nconst addMissingTspan = (node) => {\n    if (!isText$5(node))\n        return node;\n    if (!node.children)\n        return node;\n    const resolveChild = (child) => isTextInstance$3(child) ? wrapBetweenTspan(child) : child;\n    const children = node.children.map(resolveChild);\n    return Object.assign({}, node, { children });\n};\nconst parseText = (fontStore) => (node) => {\n    if (isText$5(node))\n        return layoutText$1(fontStore, node);\n    if (!node.children)\n        return node;\n    const children = node.children.map(parseText(fontStore));\n    return Object.assign({}, node, { children });\n};\nconst resolveSvgNode = (container) => compose(parseProps(container), addMissingTspan, removeNoneValues, mergeStyles$1);\nconst resolveChildren = (container) => (node) => {\n    if (!node.children)\n        return node;\n    const resolveChild = compose(resolveChildren(container), resolveSvgNode(container));\n    const children = node.children.map(resolveChild);\n    return Object.assign({}, node, { children });\n};\nconst buildXLinksIndex = (node) => {\n    const idIndex = {};\n    const listToExplore = node.children?.slice(0) || [];\n    while (listToExplore.length > 0) {\n        const child = listToExplore.shift();\n        if (child.props && 'id' in child.props) {\n            idIndex[child.props.id] = child;\n        }\n        if (child.children)\n            listToExplore.push(...child.children);\n    }\n    return idIndex;\n};\nconst replaceXLinks = (node, idIndex) => {\n    if (node.props && 'xlinkHref' in node.props) {\n        const linkedNode = idIndex[node.props.xlinkHref.replace(/^#/, '')];\n        // No node to extend from\n        if (!linkedNode)\n            return node;\n        const newProps = Object.assign({}, linkedNode.props, node.props);\n        delete newProps.xlinkHref;\n        return Object.assign({}, linkedNode, { props: newProps });\n    }\n    const children = node.children?.map((child) => replaceXLinks(child, idIndex));\n    return Object.assign({}, node, { children });\n};\nconst resolveXLinks = (node) => {\n    const idIndex = buildXLinksIndex(node);\n    return replaceXLinks(node, idIndex);\n};\nconst resolveSvgRoot = (node, fontStore) => {\n    const container = getContainer$1(node);\n    return compose(replaceDefs, parseText(fontStore), parseSvgProps, pickStyleProps, inheritProps, resolveChildren(container), resolveXLinks)(node);\n};\n/**\n * Pre-process SVG nodes so they can be rendered in the next steps\n *\n * @param node - Root node\n * @param fontStore - Font store\n * @returns Root node\n */\nconst resolveSvg = (node, fontStore) => {\n    if (!('children' in node))\n        return node;\n    const resolveChild = (child) => resolveSvg(child, fontStore);\n    const root = isSvg$3(node) ? resolveSvgRoot(node, fontStore) : node;\n    const children = root.children?.map(resolveChild);\n    return Object.assign({}, root, { children });\n};\n\nlet instancePromise;\nconst loadYoga = async () => {\n    // Yoga WASM binaries must be asynchronously compiled and loaded\n    // to prevent Event emitter memory leak warnings, Yoga must be loaded only once\n    const instance = await (instancePromise ??= loadYoga$1());\n    const config = instance.Config.create();\n    config.setPointScaleFactor(0);\n    const node = { create: () => instance.Node.createWithConfig(config) };\n    return { node };\n};\n\nconst resolveYoga = async (root) => {\n    const yoga = await loadYoga();\n    return Object.assign({}, root, { yoga });\n};\n\nconst getZIndex = (node) => node.style.zIndex;\nconst shouldSort = (node) => node.type !== P.Document && node.type !== P.Svg;\nconst sortZIndex = (a, b) => {\n    const za = getZIndex(a);\n    const zb = getZIndex(b);\n    if (!za && !zb)\n        return 0;\n    if (!za)\n        return 1;\n    if (!zb)\n        return -1;\n    return zb - za;\n};\n/**\n * Sort children by zIndex value\n *\n * @param node\n * @returns Node\n */\nconst resolveNodeZIndex = (node) => {\n    if (!node.children)\n        return node;\n    const sortedChildren = shouldSort(node)\n        ? node.children.sort(sortZIndex)\n        : node.children;\n    const children = sortedChildren.map(resolveNodeZIndex);\n    return Object.assign({}, node, { children });\n};\n/**\n * Sort children by zIndex value\n *\n * @param node\n * @returns Node\n */\nconst resolveZIndex = (root) => resolveNodeZIndex(root);\n\n/* eslint-disable no-console */\n// Caches emoji images data\nconst emojis = {};\nconst regex = emojiRegex();\n/**\n * When an emoji as no variations, it might still have 2 parts,\n * the canonical emoji and an empty string.\n * ex.\n *   (no color) Array.from('â¤ï¸') => [\"â¤\", \"ï¸\"]\n *   (w/ color) Array.from('ðŸ‘ðŸ¿') => [\"ðŸ‘\", \"ðŸ¿\"]\n *\n * The empty string needs to be removed otherwise the generated\n * url will be incorect.\n */\nconst removeVariationSelectors = (x) => x !== 'ï¸';\nconst getCodePoints = (string, withVariationSelectors = false) => Array.from(string)\n    .filter(withVariationSelectors ? () => true : removeVariationSelectors)\n    .map((char) => char.codePointAt(0).toString(16))\n    .join('-');\nconst buildEmojiUrl = (emoji, source) => {\n    if ('builder' in source) {\n        return source.builder(getCodePoints(emoji, source.withVariationSelectors));\n    }\n    const { url, format = 'png', withVariationSelectors } = source;\n    return `${url}${getCodePoints(emoji, withVariationSelectors)}.${format}`;\n};\nconst fetchEmojis = (string, source) => {\n    if (!source)\n        return [];\n    const promises = [];\n    Array.from(string.matchAll(regex)).forEach((match) => {\n        const emoji = match[0];\n        if (!emojis[emoji] || emojis[emoji].loading) {\n            const emojiUrl = buildEmojiUrl(emoji, source);\n            emojis[emoji] = { loading: true };\n            promises.push(resolveImage({ uri: emojiUrl })\n                .then((image) => {\n                emojis[emoji].loading = false;\n                emojis[emoji].data = image.data;\n            })\n                .catch((e) => {\n                console.warn(e, 'Failed to load emoji image');\n                emojis[emoji].loading = false;\n            }));\n        }\n    });\n    return promises;\n};\nconst embedEmojis = (fragments) => {\n    const result = [];\n    for (let i = 0; i < fragments.length; i += 1) {\n        const fragment = fragments[i];\n        let lastIndex = 0;\n        Array.from(fragment.string.matchAll(regex)).forEach((match) => {\n            const { index } = match;\n            const emoji = match[0];\n            const emojiSize = fragment.attributes.fontSize;\n            const chunk = fragment.string.slice(lastIndex, index + match[0].length);\n            // If emoji image was found, we create a new fragment with the\n            // correct attachment and object substitution character;\n            if (emojis[emoji] && emojis[emoji].data) {\n                result.push({\n                    string: chunk.replace(match[0], String.fromCharCode(0xfffc)),\n                    attributes: {\n                        ...fragment.attributes,\n                        attachment: {\n                            width: emojiSize,\n                            height: emojiSize,\n                            yOffset: Math.floor(emojiSize * 0.1),\n                            image: emojis[emoji].data,\n                        },\n                    },\n                });\n            }\n            else {\n                // If no emoji data, we try to use emojis in the font\n                result.push({\n                    string: chunk,\n                    attributes: fragment.attributes,\n                });\n            }\n            lastIndex = index + emoji.length;\n        });\n        if (lastIndex < fragment.string.length) {\n            result.push({\n                string: fragment.string.slice(lastIndex),\n                attributes: fragment.attributes,\n            });\n        }\n    }\n    return result;\n};\n\n/**\n * Get image source\n *\n * @param node - Image node\n * @returns Image src\n */\nconst getSource = (node) => {\n    if (node.props.src)\n        return node.props.src;\n    if (node.props.source)\n        return node.props.source;\n};\n\n/**\n * Resolves `src` to `@react-pdf/image` interface.\n *\n * Also it handles factories and async sources.\n *\n * @param src\n * @returns Resolved src\n */\nconst resolveSource = async (src) => {\n    const source = typeof src === 'function' ? await src() : await src;\n    return typeof source === 'string' ? { uri: source } : source;\n};\n\n/**\n * Fetches image and append data to node\n * Ideally this fn should be immutable.\n *\n * @param node\n */\nconst fetchImage = async (node) => {\n    const src = getSource(node);\n    const { cache } = node.props;\n    if (!src) {\n        console.warn(false, 'Image should receive either a \"src\" or \"source\" prop');\n        return;\n    }\n    try {\n        const source = await resolveSource(src);\n        if (!source) {\n            throw new Error(`Image's \"src\" or \"source\" prop returned ${source}`);\n        }\n        node.image = await resolveImage(source, { cache });\n        if (Buffer.isBuffer(source) || source instanceof Blob)\n            return;\n        node.image.key = 'data' in source ? source.data.toString() : source.uri;\n    }\n    catch (e) {\n        console.warn(e.message);\n    }\n};\n\nconst isImage$2 = (node) => node.type === P.Image;\n/**\n * Get all asset promises that need to be resolved\n *\n * @param fontStore - Font store\n * @param node - Root node\n * @returns Asset promises\n */\nconst fetchAssets = (fontStore, node) => {\n    const promises = [];\n    const listToExplore = node.children?.slice(0) || [];\n    const emojiSource = fontStore ? fontStore.getEmojiSource() : null;\n    while (listToExplore.length > 0) {\n        const n = listToExplore.shift();\n        if (isImage$2(n)) {\n            promises.push(fetchImage(n));\n        }\n        if (fontStore && n.style?.fontFamily) {\n            const fontFamilies = castArray(n.style.fontFamily);\n            promises.push(...fontFamilies.map((fontFamily) => fontStore.load({\n                fontFamily,\n                fontStyle: n.style.fontStyle,\n                fontWeight: n.style.fontWeight,\n            })));\n        }\n        if (typeof n === 'string') {\n            promises.push(...fetchEmojis(n, emojiSource));\n        }\n        if ('value' in n && typeof n.value === 'string') {\n            promises.push(...fetchEmojis(n.value, emojiSource));\n        }\n        if (n.children) {\n            n.children.forEach((childNode) => {\n                listToExplore.push(childNode);\n            });\n        }\n    }\n    return promises;\n};\n/**\n * Fetch image, font and emoji assets in parallel.\n * Layout process will not be resumed until promise resolves.\n *\n * @param node root node\n * @param fontStore font store\n * @returns Root node\n */\nconst resolveAssets = async (node, fontStore) => {\n    const promises = fetchAssets(fontStore, node);\n    await Promise.all(promises);\n    return node;\n};\n\nconst isLink$1 = (node) => node.type === P.Link;\nconst DEFAULT_LINK_STYLES = {\n    color: 'blue',\n    textDecoration: 'underline',\n};\n/**\n * Computes styles using stylesheet\n *\n * @param container\n * @param node - Document node\n * @returns Computed styles\n */\nconst computeStyle = (container, node) => {\n    let baseStyle = [node.style];\n    if (isLink$1(node)) {\n        baseStyle = Array.isArray(node.style)\n            ? [DEFAULT_LINK_STYLES, ...node.style]\n            : [DEFAULT_LINK_STYLES, node.style];\n    }\n    return resolveStyle(container, baseStyle);\n};\n/**\n * Resolves node styles\n *\n * @param container\n * @returns Resolve node styles\n */\nconst resolveNodeStyles = (container) => (node) => {\n    const style = computeStyle(container, node);\n    if (!node.children)\n        return Object.assign({}, node, { style });\n    const children = node.children.map(resolveNodeStyles(container));\n    return Object.assign({}, node, { style, children });\n};\n/**\n * Resolves page styles\n *\n * @param page Document page\n * @returns Document page with resolved styles\n */\nconst resolvePageStyles = (page) => {\n    const dpi = page.props?.dpi || 72;\n    const style = page.style;\n    const width = page.box?.width || style.width;\n    const height = page.box?.height || style.height;\n    const orientation = page.props?.orientation || 'portrait';\n    const remBase = style?.fontSize || 18;\n    const container = { width, height, orientation, dpi, remBase };\n    return resolveNodeStyles(container)(page);\n};\n/**\n * Resolves document styles\n *\n * @param root - Document root\n * @returns Document root with resolved styles\n */\nconst resolveStyles = (root) => {\n    if (!root.children)\n        return root;\n    const children = root.children.map(resolvePageStyles);\n    return Object.assign({}, root, { children });\n};\n\nconst getTransformStyle = (s) => (node) => isNil(node.style?.[s]) ? '50%' : node.style?.[s] ?? null;\n/**\n * Get node origin\n *\n * @param node\n * @returns {{ left?: number, top?: number }} node origin\n */\nconst getOrigin = (node) => {\n    if (!node.box)\n        return null;\n    const { left, top, width, height } = node.box;\n    const transformOriginX = getTransformStyle('transformOriginX')(node);\n    const transformOriginY = getTransformStyle('transformOriginY')(node);\n    const percentX = matchPercent(transformOriginX);\n    const percentY = matchPercent(transformOriginY);\n    const offsetX = percentX ? width * percentX.percent : transformOriginX;\n    const offsetY = percentY ? height * percentY.percent : transformOriginY;\n    if (isNil(offsetX) || typeof offsetX === 'string')\n        throw new Error(`Invalid origin offsetX: ${offsetX}`);\n    if (isNil(offsetY) || typeof offsetY === 'string')\n        throw new Error(`Invalid origin offsetY: ${offsetY}`);\n    return { left: left + offsetX, top: top + offsetY };\n};\n\n/**\n * Resolve node origin\n *\n * @param node\n * @returns Node with origin attribute\n */\nconst resolveNodeOrigin = (node) => {\n    const origin = getOrigin(node);\n    const newNode = Object.assign({}, node, { origin });\n    if (!node.children)\n        return newNode;\n    const children = node.children.map(resolveNodeOrigin);\n    return Object.assign({}, newNode, { children });\n};\n/**\n * Resolve document origins\n *\n * @param root - Document root\n * @returns Document root\n */\nconst resolveOrigin = (root) => {\n    if (!root.children)\n        return root;\n    const children = root.children.map(resolveNodeOrigin);\n    return Object.assign({}, root, { children });\n};\n\nconst getBookmarkValue = (bookmark) => {\n    return typeof bookmark === 'string'\n        ? { title: bookmark, fit: false, expanded: false }\n        : bookmark;\n};\nconst resolveBookmarks = (node) => {\n    let refs = 0;\n    const children = (node.children || []).slice(0);\n    const listToExplore = children.map((value) => ({\n        value,\n        parent: null,\n    }));\n    while (listToExplore.length > 0) {\n        const element = listToExplore.shift();\n        if (!element)\n            break;\n        const child = element.value;\n        let parent = element.parent;\n        if (child.props && 'bookmark' in child.props && child.props.bookmark) {\n            const bookmark = getBookmarkValue(child.props.bookmark);\n            const ref = refs++;\n            const newHierarchy = { ref, parent: parent?.ref, ...bookmark };\n            child.props.bookmark = newHierarchy;\n            parent = newHierarchy;\n        }\n        if (child.children) {\n            child.children.forEach((childNode) => {\n                listToExplore.push({ value: childNode, parent });\n            });\n        }\n    }\n    return node;\n};\n\nconst VALID_ORIENTATIONS = ['portrait', 'landscape'];\n/**\n * Get page orientation. Defaults to portrait\n *\n * @param page - Page object\n * @returns Page orientation\n */\nconst getOrientation = (page) => {\n    const value = page.props?.orientation || 'portrait';\n    return VALID_ORIENTATIONS.includes(value) ? value : 'portrait';\n};\n\n/**\n * Return true if page is landscape\n *\n * @param page - Page instance\n * @returns Is page landscape\n */\nconst isLandscape = (page) => getOrientation(page) === 'landscape';\n\n// Page sizes for 72dpi. 72dpi is used internally by pdfkit.\nconst PAGE_SIZES = {\n    '4A0': [4767.87, 6740.79],\n    '2A0': [3370.39, 4767.87],\n    A0: [2383.94, 3370.39],\n    A1: [1683.78, 2383.94],\n    A2: [1190.55, 1683.78],\n    A3: [841.89, 1190.55],\n    A4: [595.28, 841.89],\n    A5: [419.53, 595.28],\n    A6: [297.64, 419.53],\n    A7: [209.76, 297.64],\n    A8: [147.4, 209.76],\n    A9: [104.88, 147.4],\n    A10: [73.7, 104.88],\n    B0: [2834.65, 4008.19],\n    B1: [2004.09, 2834.65],\n    B2: [1417.32, 2004.09],\n    B3: [1000.63, 1417.32],\n    B4: [708.66, 1000.63],\n    B5: [498.9, 708.66],\n    B6: [354.33, 498.9],\n    B7: [249.45, 354.33],\n    B8: [175.75, 249.45],\n    B9: [124.72, 175.75],\n    B10: [87.87, 124.72],\n    C0: [2599.37, 3676.54],\n    C1: [1836.85, 2599.37],\n    C2: [1298.27, 1836.85],\n    C3: [918.43, 1298.27],\n    C4: [649.13, 918.43],\n    C5: [459.21, 649.13],\n    C6: [323.15, 459.21],\n    C7: [229.61, 323.15],\n    C8: [161.57, 229.61],\n    C9: [113.39, 161.57],\n    C10: [79.37, 113.39],\n    RA0: [2437.8, 3458.27],\n    RA1: [1729.13, 2437.8],\n    RA2: [1218.9, 1729.13],\n    RA3: [864.57, 1218.9],\n    RA4: [609.45, 864.57],\n    SRA0: [2551.18, 3628.35],\n    SRA1: [1814.17, 2551.18],\n    SRA2: [1275.59, 1814.17],\n    SRA3: [907.09, 1275.59],\n    SRA4: [637.8, 907.09],\n    EXECUTIVE: [521.86, 756.0],\n    FOLIO: [612.0, 936.0],\n    LEGAL: [612.0, 1008.0],\n    LETTER: [612.0, 792.0],\n    TABLOID: [792.0, 1224.0],\n    ID1: [153, 243],\n};\n/**\n * Parses scalar value in value and unit pairs\n *\n * @param value - Scalar value\n * @returns Parsed value\n */\nconst parseValue = (value) => {\n    if (typeof value === 'number')\n        return { value, unit: undefined };\n    const match = /^(-?\\d*\\.?\\d+)(in|mm|cm|pt|px)?$/g.exec(value);\n    return match\n        ? { value: parseFloat(match[1]), unit: match[2] || 'pt' }\n        : { value, unit: undefined };\n};\n/**\n * Transform given scalar value to 72dpi equivalent of size\n *\n * @param value - Styles value\n * @param inputDpi - User defined dpi\n * @returns Transformed value\n */\nconst transformUnit = (value, inputDpi) => {\n    if (!value)\n        return 0;\n    const scalar = parseValue(value);\n    const outputDpi = 72;\n    const mmFactor = (1 / 25.4) * outputDpi;\n    const cmFactor = (1 / 2.54) * outputDpi;\n    if (typeof scalar.value === 'string')\n        throw new Error(`Invalid page size: ${value}`);\n    switch (scalar.unit) {\n        case 'in':\n            return scalar.value * outputDpi;\n        case 'mm':\n            return scalar.value * mmFactor;\n        case 'cm':\n            return scalar.value * cmFactor;\n        case 'px':\n            return Math.round(scalar.value * (outputDpi / inputDpi));\n        default:\n            return scalar.value;\n    }\n};\nconst transformUnits = ({ width, height }, dpi) => ({\n    width: transformUnit(width, dpi),\n    height: transformUnit(height, dpi),\n});\n/**\n * Transforms array into size object\n *\n * @param v - Values array\n * @returns Size object with width and height\n */\nconst toSizeObject = (v) => ({\n    width: v[0],\n    height: v[1],\n});\n/**\n * Flip size object\n *\n * @param v - Size object\n * @returns Flipped size object\n */\nconst flipSizeObject = (v) => ({\n    width: v.height,\n    height: v.width,\n});\n/**\n * Returns size object from a given string\n *\n * @param v - Page size string\n * @returns Size object with width and height\n */\nconst getStringSize = (v) => {\n    return toSizeObject(PAGE_SIZES[v.toUpperCase()]);\n};\n/**\n * Returns size object from a single number\n *\n * @param n - Page size number\n * @returns Size object with width and height\n */\nconst getNumberSize = (n) => toSizeObject([n, n]);\n/**\n * Return page size in an object { width, height }\n *\n * @param page - Page node\n * @returns Size object with width and height\n */\nconst getSize = (page) => {\n    const value = page.props?.size || 'A4';\n    const dpi = page.props?.dpi || 72;\n    let size;\n    if (typeof value === 'string') {\n        size = getStringSize(value);\n    }\n    else if (Array.isArray(value)) {\n        size = transformUnits(toSizeObject(value), dpi);\n    }\n    else if (typeof value === 'number') {\n        size = transformUnits(getNumberSize(value), dpi);\n    }\n    else {\n        size = transformUnits(value, dpi);\n    }\n    return isLandscape(page) ? flipSizeObject(size) : size;\n};\n\n/**\n * Resolves page size\n *\n * @param page\n * @returns Page with resolved size in style attribute\n */\nconst resolvePageSize = (page) => {\n    const size = getSize(page);\n    const style = flatten(page.style || {});\n    return { ...page, style: { ...style, ...size } };\n};\n/**\n * Resolves page sizes\n *\n * @param root  -Document root\n * @returns Document root with resolved page sizes\n */\nconst resolvePageSizes = (root) => {\n    if (!root.children)\n        return root;\n    const children = root.children.map(resolvePageSize);\n    return Object.assign({}, root, { children });\n};\n\nconst isFixed = (node) => {\n    if (!node.props)\n        return false;\n    return 'fixed' in node.props ? node.props.fixed === true : false;\n};\n\n/**\n * Get line index at given height\n *\n * @param node\n * @param height\n */\nconst lineIndexAtHeight = (node, height) => {\n    let y = 0;\n    if (!node.lines)\n        return 0;\n    for (let i = 0; i < node.lines.length; i += 1) {\n        const line = node.lines[i];\n        if (y + line.box.height > height)\n            return i;\n        y += line.box.height;\n    }\n    return node.lines.length;\n};\n\n/**\n * Get height for given text line index\n *\n * @param node\n * @param index\n */\nconst heightAtLineIndex = (node, index) => {\n    let counter = 0;\n    if (!node.lines)\n        return counter;\n    for (let i = 0; i < index; i += 1) {\n        const line = node.lines[i];\n        if (!line)\n            break;\n        counter += line.box.height;\n    }\n    return counter;\n};\n\nconst getLineBreak = (node, height) => {\n    const top = node.box?.top || 0;\n    const widows = node.props.widows || 2;\n    const orphans = node.props.orphans || 2;\n    const linesQuantity = node.lines.length;\n    const slicedLine = lineIndexAtHeight(node, height - top);\n    if (slicedLine === 0) {\n        return 0;\n    }\n    if (linesQuantity < orphans) {\n        return linesQuantity;\n    }\n    if (slicedLine < orphans || linesQuantity < orphans + widows) {\n        return 0;\n    }\n    if (linesQuantity === orphans + widows) {\n        return orphans;\n    }\n    if (linesQuantity - slicedLine < widows) {\n        return linesQuantity - widows;\n    }\n    return slicedLine;\n};\n// Also receives contentArea in case it's needed\nconst splitText = (node, height) => {\n    const slicedLineIndex = getLineBreak(node, height);\n    const currentHeight = heightAtLineIndex(node, slicedLineIndex);\n    const nextHeight = node.box.height - currentHeight;\n    const current = Object.assign({}, node, {\n        box: {\n            ...node.box,\n            height: currentHeight,\n            borderBottomWidth: 0,\n        },\n        style: {\n            ...node.style,\n            marginBottom: 0,\n            paddingBottom: 0,\n            borderBottomWidth: 0,\n            borderBottomLeftRadius: 0,\n            borderBottomRightRadius: 0,\n        },\n        lines: node.lines.slice(0, slicedLineIndex),\n    });\n    const next = Object.assign({}, node, {\n        box: {\n            ...node.box,\n            top: 0,\n            height: nextHeight,\n            borderTopWidth: 0,\n        },\n        style: {\n            ...node.style,\n            marginTop: 0,\n            paddingTop: 0,\n            borderTopWidth: 0,\n            borderTopLeftRadius: 0,\n            borderTopRightRadius: 0,\n        },\n        lines: node.lines.slice(slicedLineIndex),\n    });\n    return [current, next];\n};\n\nconst getTop$1 = (node) => node.box?.top || 0;\nconst hasFixedHeight = (node) => !isNil(node.style?.height);\nconst splitNode = (node, height) => {\n    if (!node)\n        return [null, null];\n    const nodeTop = getTop$1(node);\n    const current = Object.assign({}, node, {\n        box: {\n            ...node.box,\n            borderBottomWidth: 0,\n        },\n        style: {\n            ...node.style,\n            marginBottom: 0,\n            paddingBottom: 0,\n            borderBottomWidth: 0,\n            borderBottomLeftRadius: 0,\n            borderBottomRightRadius: 0,\n        },\n    });\n    current.style.height = height - nodeTop;\n    const nextHeight = hasFixedHeight(node)\n        ? node.box.height - (height - nodeTop)\n        : null;\n    const next = Object.assign({}, node, {\n        box: {\n            ...node.box,\n            top: 0,\n            borderTopWidth: 0,\n        },\n        style: {\n            ...node.style,\n            marginTop: 0,\n            paddingTop: 0,\n            borderTopWidth: 0,\n            borderTopLeftRadius: 0,\n            borderTopRightRadius: 0,\n        },\n    });\n    if (nextHeight) {\n        next.style.height = nextHeight;\n    }\n    return [current, next];\n};\n\nconst NON_WRAP_TYPES = [P.Svg, P.Note, P.Image, P.Canvas];\nconst getWrap = (node) => {\n    if (NON_WRAP_TYPES.includes(node.type))\n        return false;\n    if (!node.props)\n        return true;\n    return 'wrap' in node.props ? node.props.wrap : true;\n};\n\nconst getComputedPadding = (node, edge) => {\n    const { yogaNode } = node;\n    return yogaNode ? yogaNode.getComputedPadding(edge) : null;\n};\n/**\n * Get Yoga computed paddings. Zero otherwise\n *\n * @param  node\n * @returns paddings\n */\nconst getPadding = (node) => {\n    const { style, box } = node;\n    const paddingTop = getComputedPadding(node, Yoga.Edge.Top) ||\n        box?.paddingTop ||\n        style?.paddingTop ||\n        0;\n    const paddingRight = getComputedPadding(node, Yoga.Edge.Right) ||\n        box?.paddingRight ||\n        style?.paddingRight ||\n        0;\n    const paddingBottom = getComputedPadding(node, Yoga.Edge.Bottom) ||\n        box?.paddingBottom ||\n        style?.paddingBottom ||\n        0;\n    const paddingLeft = getComputedPadding(node, Yoga.Edge.Left) ||\n        box?.paddingLeft ||\n        style?.paddingLeft ||\n        0;\n    return { paddingTop, paddingRight, paddingBottom, paddingLeft };\n};\n\nconst getWrapArea = (page) => {\n    const height = page.style?.height;\n    const { paddingBottom } = getPadding(page);\n    return height - paddingBottom;\n};\n\nconst getContentArea = (page) => {\n    const height = page.style?.height;\n    const { paddingTop, paddingBottom } = getPadding(page);\n    return height - paddingBottom - paddingTop;\n};\n\nconst isString = (value) => typeof value === 'string';\nconst isNumber = (value) => typeof value === 'number';\nconst isBoolean = (value) => typeof value === 'boolean';\nconst isFragment = (value) => value && value.type === Symbol.for('react.fragment');\n/**\n * Transforms a react element instance to internal element format.\n *\n * Can return multiple instances in the case of arrays or fragments.\n *\n * @param element - React element\n * @returns Parsed React elements\n */\nconst createInstances = (element) => {\n    if (!element)\n        return [];\n    if (Array.isArray(element)) {\n        return element.reduce((acc, el) => acc.concat(createInstances(el)), []);\n    }\n    if (isBoolean(element)) {\n        return [];\n    }\n    if (isString(element) || isNumber(element)) {\n        return [{ type: P.TextInstance, value: `${element}` }];\n    }\n    if (isFragment(element)) {\n        // @ts-expect-error figure out why this is complains\n        return createInstances(element.props.children);\n    }\n    if (!isString(element.type)) {\n        // @ts-expect-error figure out why this is complains\n        return createInstances(element.type(element.props));\n    }\n    const { type, props: { style = {}, children, ...props }, } = element;\n    const nextChildren = castArray(children).reduce((acc, child) => acc.concat(createInstances(child)), []);\n    return [\n        {\n            type,\n            style,\n            props,\n            children: nextChildren,\n        },\n    ];\n};\n\nconst getBreak = (node) => 'break' in node.props ? node.props.break : false;\nconst getMinPresenceAhead = (node) => 'minPresenceAhead' in node.props ? node.props.minPresenceAhead : 0;\nconst getFurthestEnd = (elements) => Math.max(...elements.map((node) => node.box.top + node.box.height));\nconst getEndOfMinPresenceAhead = (child) => {\n    return (child.box.top +\n        child.box.height +\n        child.box.marginBottom +\n        getMinPresenceAhead(child));\n};\nconst getEndOfPresence = (child, futureElements) => {\n    const afterMinPresenceAhead = getEndOfMinPresenceAhead(child);\n    const endOfFurthestFutureElement = getFurthestEnd(futureElements.filter((node) => !('fixed' in node.props)));\n    return Math.min(afterMinPresenceAhead, endOfFurthestFutureElement);\n};\nconst shouldBreak = (child, futureElements, height, previousElements) => {\n    if ('fixed' in child.props)\n        return false;\n    const shouldSplit = height < child.box.top + child.box.height;\n    const canWrap = getWrap(child);\n    // Calculate the y coordinate where the desired presence of the child ends\n    const endOfPresence = getEndOfPresence(child, futureElements);\n    // If the child is already at the top of the page, breaking won't improve its presence\n    // (as long as react-pdf does not support breaking into differently sized containers)\n    const breakingImprovesPresence = previousElements.filter((node) => !isFixed(node)).length > 0;\n    return (getBreak(child) ||\n        (shouldSplit && !canWrap) ||\n        (!shouldSplit && endOfPresence > height && breakingImprovesPresence));\n};\n\nconst IGNORABLE_CODEPOINTS = [\n    8232, // LINE_SEPARATOR\n    8233, // PARAGRAPH_SEPARATOR\n];\nconst buildSubsetForFont = (font) => IGNORABLE_CODEPOINTS.reduce((acc, codePoint) => {\n    if (font &&\n        font.hasGlyphForCodePoint &&\n        font.hasGlyphForCodePoint(codePoint)) {\n        return acc;\n    }\n    return [...acc, String.fromCharCode(codePoint)];\n}, []);\nconst ignoreChars = (fragments) => fragments.map((fragment) => {\n    const charSubset = buildSubsetForFont(fragment.attributes.font[0]);\n    const subsetRegex = new RegExp(charSubset.join('|'));\n    return {\n        string: fragment.string.replace(subsetRegex, ''),\n        attributes: fragment.attributes,\n    };\n});\n\nconst PREPROCESSORS = [ignoreChars, embedEmojis];\nconst isImage$1 = (node) => node.type === P.Image;\nconst isTextInstance$2 = (node) => node.type === P.TextInstance;\n/**\n * Get textkit fragments of given node object\n *\n * @param fontStore - Font store\n * @param instance - Node\n * @param parentLink - Parent link\n * @param level - Fragment level\n * @returns Text fragments\n */\nconst getFragments = (fontStore, instance, parentLink = null, level = 0) => {\n    if (!instance)\n        return [{ string: '' }];\n    let fragments = [];\n    const { color = 'black', direction = 'ltr', fontFamily = 'Helvetica', fontWeight, fontStyle, fontSize = 18, textAlign, lineHeight, textDecoration, textDecorationColor, textDecorationStyle, textTransform, letterSpacing, textIndent, opacity, verticalAlign, } = instance.style;\n    const fontFamilies = typeof fontFamily === 'string' ? [fontFamily] : [...(fontFamily || [])];\n    // Fallback font\n    fontFamilies.push('Helvetica');\n    const font = fontFamilies.map((fontFamilyName) => {\n        const opts = { fontFamily: fontFamilyName, fontWeight, fontStyle };\n        const obj = fontStore.getFont(opts);\n        return obj?.data;\n    });\n    // Don't pass main background color to textkit. Will be rendered by the render package instead\n    const backgroundColor = level === 0 ? null : instance.style.backgroundColor;\n    const attributes = {\n        font,\n        color,\n        opacity,\n        fontSize,\n        lineHeight,\n        direction,\n        verticalAlign,\n        backgroundColor,\n        indent: textIndent,\n        characterSpacing: letterSpacing,\n        strikeStyle: textDecorationStyle,\n        underlineStyle: textDecorationStyle,\n        underline: textDecoration === 'underline' ||\n            textDecoration === 'underline line-through' ||\n            textDecoration === 'line-through underline',\n        strike: textDecoration === 'line-through' ||\n            textDecoration === 'underline line-through' ||\n            textDecoration === 'line-through underline',\n        strikeColor: textDecorationColor || color,\n        underlineColor: textDecorationColor || color,\n        // @ts-expect-error allow this props access\n        link: parentLink || instance.props?.src || instance.props?.href,\n        align: textAlign || (direction === 'rtl' ? 'right' : 'left'),\n    };\n    for (let i = 0; i < instance.children.length; i += 1) {\n        const child = instance.children[i];\n        if (isImage$1(child)) {\n            fragments.push({\n                string: String.fromCharCode(0xfffc),\n                attributes: {\n                    ...attributes,\n                    attachment: {\n                        width: (child.style.width || fontSize),\n                        height: (child.style.height || fontSize),\n                        image: child.image.data,\n                    },\n                },\n            });\n        }\n        else if (isTextInstance$2(child)) {\n            fragments.push({\n                string: transformText(child.value, textTransform),\n                attributes,\n            });\n        }\n        else if (child) {\n            fragments.push(...getFragments(fontStore, child, attributes.link, level + 1));\n        }\n    }\n    for (let i = 0; i < PREPROCESSORS.length; i += 1) {\n        const preprocessor = PREPROCESSORS[i];\n        fragments = preprocessor(fragments);\n    }\n    return fragments;\n};\n/**\n * Get textkit attributed string from text node\n *\n * @param fontStore - Font store\n * @param instance Node\n * @returns Attributed string\n */\nconst getAttributedString = (fontStore, instance) => {\n    const fragments = getFragments(fontStore, instance);\n    return fromFragments(fragments);\n};\n\nconst engines = {\n    bidi,\n    linebreaker,\n    justification,\n    textDecoration,\n    scriptItemizer,\n    wordHyphenation,\n    fontSubstitution,\n};\nconst engine = layoutEngine(engines);\nconst getMaxLines = (node) => node.style?.maxLines;\nconst getTextOverflow = (node) => node.style?.textOverflow;\n/**\n * Get layout container for specific text node\n *\n * @param {number} width\n * @param {number} height\n * @param {Object} node\n * @returns {Object} layout container\n */\nconst getContainer = (width, height, node) => {\n    const maxLines = getMaxLines(node);\n    const textOverflow = getTextOverflow(node);\n    return {\n        x: 0,\n        y: 0,\n        width,\n        maxLines,\n        height: height || Infinity,\n        truncateMode: textOverflow,\n    };\n};\n/**\n * Get text layout options for specific text node\n *\n * @param {Object} node instance\n * @returns {Object} layout options\n */\nconst getLayoutOptions = (fontStore, node) => ({\n    hyphenationPenalty: node.props.hyphenationPenalty,\n    shrinkWhitespaceFactor: { before: -0.5, after: -0.5 },\n    hyphenationCallback: node.props.hyphenationCallback ||\n        fontStore?.getHyphenationCallback() ||\n        null,\n});\n/**\n * Get text lines for given node\n *\n * @param node - Node\n * @param width - Container width\n * @param height - Container height\n * @param fontStore - Font store\n * @returns Layout lines\n */\nconst layoutText = (node, width, height, fontStore) => {\n    const attributedString = getAttributedString(fontStore, node);\n    const container = getContainer(width, height, node);\n    const options = getLayoutOptions(fontStore, node);\n    const lines = engine(attributedString, container, options);\n    return lines.reduce((acc, line) => [...acc, ...line], []);\n};\n\nconst isSvg$2 = (node) => node.type === P.Svg;\nconst isText$4 = (node) => node.type === P.Text;\nconst shouldIterate = (node) => !isSvg$2(node) && !isText$4(node);\nconst shouldLayoutText = (node) => isText$4(node) && !node.lines;\n/**\n * Performs text layout on text node if wasn't calculated before.\n * Text layout is usually performed on Yoga's layout process (via setMeasureFunc),\n * but we need to layout those nodes with fixed width and height.\n *\n * @param node\n * @returns Layout node\n */\nconst resolveTextLayout = (node, fontStore) => {\n    if (shouldLayoutText(node)) {\n        const width = node.box.width - (node.box.paddingRight + node.box.paddingLeft);\n        const height = node.box.height - (node.box.paddingTop + node.box.paddingBottom);\n        node.lines = layoutText(node, width, height, fontStore);\n    }\n    if (shouldIterate(node)) {\n        if (!node.children)\n            return node;\n        const mapChild = (child) => resolveTextLayout(child, fontStore);\n        const children = node.children.map(mapChild);\n        return Object.assign({}, node, { children });\n    }\n    return node;\n};\n\nconst BASE_INHERITABLE_PROPERTIES = [\n    'color',\n    'fontFamily',\n    'fontSize',\n    'fontStyle',\n    'fontWeight',\n    'letterSpacing',\n    'opacity',\n    'textDecoration',\n    'textTransform',\n    'lineHeight',\n    'textAlign',\n    'visibility',\n    'wordSpacing',\n];\nconst TEXT_INHERITABLE_PROPERTIES = [\n    ...BASE_INHERITABLE_PROPERTIES,\n    'backgroundColor',\n];\nconst isType$2 = (type) => (node) => node.type === type;\nconst isSvg$1 = isType$2(P.Svg);\nconst isText$3 = isType$2(P.Text);\n// Merge style values\nconst mergeValues = (styleName, value, inheritedValue) => {\n    switch (styleName) {\n        case 'textDecoration': {\n            // merge not none and not false textDecoration values to one rule\n            return [inheritedValue, value].filter((v) => v && v !== 'none').join(' ');\n        }\n        default:\n            return value;\n    }\n};\n// Merge inherited and node styles\nconst merge = (inheritedStyles, style) => {\n    const mergedStyles = { ...inheritedStyles };\n    Object.entries(style).forEach(([styleName, value]) => {\n        mergedStyles[styleName] = mergeValues(styleName, value, inheritedStyles[styleName]);\n    });\n    return mergedStyles;\n};\n/**\n * Merges styles with node\n *\n * @param inheritedStyles - Style object\n * @returns Merge styles function\n */\nconst mergeStyles = (inheritedStyles) => (node) => {\n    const style = merge(inheritedStyles, node.style || {});\n    return Object.assign({}, node, { style });\n};\n/**\n * Inherit style values from the root to the leafs\n *\n * @param node - Document root\n * @returns Document root with inheritance\n *\n */\nconst resolveInheritance = (node) => {\n    if (isSvg$1(node))\n        return node;\n    if (!('children' in node))\n        return node;\n    const inheritableProperties = isText$3(node)\n        ? TEXT_INHERITABLE_PROPERTIES\n        : BASE_INHERITABLE_PROPERTIES;\n    const inheritStyles = pick(inheritableProperties, node.style || {});\n    const resolveChild = compose(resolveInheritance, mergeStyles(inheritStyles));\n    const children = node.children.map(resolveChild);\n    return Object.assign({}, node, { children });\n};\n\nconst getComputedMargin = (node, edge) => {\n    const { yogaNode } = node;\n    return yogaNode ? yogaNode.getComputedMargin(edge) : null;\n};\n/**\n * Get Yoga computed magins. Zero otherwise\n *\n * @param node\n * @returns Margins\n */\nconst getMargin = (node) => {\n    const { style, box } = node;\n    const marginTop = getComputedMargin(node, Yoga.Edge.Top) ||\n        box?.marginTop ||\n        style?.marginTop ||\n        0;\n    const marginRight = getComputedMargin(node, Yoga.Edge.Right) ||\n        box?.marginRight ||\n        style?.marginRight ||\n        0;\n    const marginBottom = getComputedMargin(node, Yoga.Edge.Bottom) ||\n        box?.marginBottom ||\n        style?.marginBottom ||\n        0;\n    const marginLeft = getComputedMargin(node, Yoga.Edge.Left) ||\n        box?.marginLeft ||\n        style?.marginLeft ||\n        0;\n    return { marginTop, marginRight, marginBottom, marginLeft };\n};\n\n/**\n * Get Yoga computed position. Zero otherwise\n *\n * @param node\n * @returns Position\n */\nconst getPosition = (node) => {\n    const { yogaNode } = node;\n    return {\n        top: yogaNode?.getComputedTop() || 0,\n        right: yogaNode?.getComputedRight() || 0,\n        bottom: yogaNode?.getComputedBottom() || 0,\n        left: yogaNode?.getComputedLeft() || 0,\n    };\n};\n\nconst DEFAULT_DIMENSION = {\n    width: 0,\n    height: 0,\n};\n/**\n * Get Yoga computed dimensions. Zero otherwise\n *\n * @param node\n * @returns Dimensions\n */\nconst getDimension = (node) => {\n    const { yogaNode } = node;\n    if (!yogaNode)\n        return DEFAULT_DIMENSION;\n    return {\n        width: yogaNode.getComputedWidth(),\n        height: yogaNode.getComputedHeight(),\n    };\n};\n\nconst getComputedBorder = (yogaNode, edge) => (yogaNode ? yogaNode.getComputedBorder(edge) : 0);\n/**\n * Get Yoga computed border width. Zero otherwise\n *\n * @param node\n * @returns Border widths\n */\nconst getBorderWidth = (node) => {\n    const { yogaNode } = node;\n    return {\n        borderTopWidth: getComputedBorder(yogaNode, Yoga.Edge.Top),\n        borderRightWidth: getComputedBorder(yogaNode, Yoga.Edge.Right),\n        borderBottomWidth: getComputedBorder(yogaNode, Yoga.Edge.Bottom),\n        borderLeftWidth: getComputedBorder(yogaNode, Yoga.Edge.Left),\n    };\n};\n\n/**\n * Set display attribute to node's Yoga instance\n *\n * @param value - Display\n * @returns Node instance wrapper\n */\nconst setDisplay = (value) => (node) => {\n    const { yogaNode } = node;\n    if (yogaNode) {\n        yogaNode.setDisplay(value === 'none' ? Yoga.Display.None : Yoga.Display.Flex);\n    }\n    return node;\n};\n\nconst OVERFLOW = {\n    hidden: Yoga.Overflow.Hidden,\n    scroll: Yoga.Overflow.Scroll,\n};\n/**\n * Set overflow attribute to node's Yoga instance\n *\n * @param value - Overflow value\n * @returns Node instance wrapper\n */\nconst setOverflow = (value) => (node) => {\n    const { yogaNode } = node;\n    if (!isNil(value) && yogaNode) {\n        const overflow = OVERFLOW[value] || Yoga.Overflow.Visible;\n        yogaNode.setOverflow(overflow);\n    }\n    return node;\n};\n\nconst FLEX_WRAP = {\n    wrap: Yoga.Wrap.Wrap,\n    'wrap-reverse': Yoga.Wrap.WrapReverse,\n};\n/**\n * Set flex wrap attribute to node's Yoga instance\n *\n * @param value - Flex wrap value\n * @returns Node instance wrapper\n */\nconst setFlexWrap = (value) => (node) => {\n    const { yogaNode } = node;\n    if (yogaNode) {\n        const flexWrap = FLEX_WRAP[value] || Yoga.Wrap.NoWrap;\n        yogaNode.setFlexWrap(flexWrap);\n    }\n    return node;\n};\n\n/**\n * Set generic yoga attribute to node's Yoga instance, handing `auto`, edges and percentage cases\n *\n * @param attr - Property\n * @param edge - Edge\n * @returns Node instance wrapper\n */\nconst setYogaValue = (attr, edge) => (value) => (node) => {\n    const { yogaNode } = node;\n    if (!isNil(value) && yogaNode) {\n        const hasEdge = !isNil(edge);\n        const fixedMethod = `set${upperFirst(attr)}`;\n        const autoMethod = `${fixedMethod}Auto`;\n        const percentMethod = `${fixedMethod}Percent`;\n        const percent = matchPercent(value);\n        if (percent && !yogaNode[percentMethod]) {\n            throw new Error(`You can't pass percentage values to ${attr} property`);\n        }\n        if (percent) {\n            if (hasEdge) {\n                yogaNode[percentMethod]?.(edge, percent.value);\n            }\n            else {\n                yogaNode[percentMethod]?.(percent.value);\n            }\n        }\n        else if (value === 'auto') {\n            if (hasEdge) {\n                yogaNode[autoMethod]?.(edge);\n            }\n            else {\n                yogaNode[autoMethod]?.();\n            }\n        }\n        else if (hasEdge) {\n            yogaNode[fixedMethod]?.(edge, value);\n        }\n        else {\n            yogaNode[fixedMethod]?.(value);\n        }\n    }\n    return node;\n};\n\n/**\n * Set flex grow attribute to node's Yoga instance\n *\n * @param  value - Flex grow value\n * @returns Node instance wrapper\n */\nconst setFlexGrow = (value) => (node) => {\n    return setYogaValue('flexGrow')(value || 0)(node);\n};\n\n/**\n * Set flex basis attribute to node's Yoga instance\n *\n * @param flex - Basis value\n * @param node - Node instance\n * @returns Node instance\n */\nconst setFlexBasis = setYogaValue('flexBasis');\n\nconst ALIGN = {\n    'flex-start': Yoga.Align.FlexStart,\n    center: Yoga.Align.Center,\n    'flex-end': Yoga.Align.FlexEnd,\n    stretch: Yoga.Align.Stretch,\n    baseline: Yoga.Align.Baseline,\n    'space-between': Yoga.Align.SpaceBetween,\n    'space-around': Yoga.Align.SpaceAround,\n    'space-evenly': Yoga.Align.SpaceEvenly,\n};\n/**\n * Set generic align attribute to node's Yoga instance\n *\n * @param attr - Specific align property\n * @param value - Specific align value\n * @param node - Node\n * @returns Node\n */\nconst setAlign = (attr) => (value) => (node) => {\n    const { yogaNode } = node;\n    const defaultValue = attr === 'items' ? Yoga.Align.Stretch : Yoga.Align.Auto;\n    if (yogaNode) {\n        const align = ALIGN[value] || defaultValue;\n        yogaNode[`setAlign${upperFirst(attr)}`](align);\n    }\n    return node;\n};\n\n/**\n * Set align self attribute to node's Yoga instance\n *\n * @param align - Value\n * @param node - Node instance\n * @returns Node instance\n */\nconst setAlignSelf = setAlign('self');\n\n/**\n * Set align items attribute to node's Yoga instance\n *\n * @param align - Value\n * @param node - Node instance\n * @returns Node instance\n */\nconst setAlignItems = setAlign('items');\n\n/**\n * Set flex shrink attribute to node's Yoga instance\n *\n * @param value - Flex shrink value\n * @returns Node instance wrapper\n */\nconst setFlexShrink = (value) => (node) => {\n    return setYogaValue('flexShrink')(value || 1)(node);\n};\n\n/**\n * Set aspect ratio attribute to node's Yoga instance\n *\n * @param value - Ratio\n * @returns Node instance\n */\nconst setAspectRatio = (value) => (node) => {\n    const { yogaNode } = node;\n    if (!isNil(value) && yogaNode) {\n        yogaNode.setAspectRatio(value);\n    }\n    return node;\n};\n\n/**\n * Set align content attribute to node's Yoga instance\n *\n * @param align - Value\n * @param node - Instance\n * @returns Node instance\n */\nconst setAlignContent = setAlign('content');\n\nconst POSITION = {\n    absolute: Yoga.PositionType.Absolute,\n    relative: Yoga.PositionType.Relative,\n    static: Yoga.PositionType.Static,\n};\n/**\n * Set position type attribute to node's Yoga instance\n *\n * @param value - Position position type\n * @returns Node instance\n */\nconst setPositionType = (value) => (node) => {\n    const { yogaNode } = node;\n    if (!isNil(value) && yogaNode) {\n        yogaNode.setPositionType(POSITION[value]);\n    }\n    return node;\n};\n\nconst FLEX_DIRECTIONS = {\n    row: Yoga.FlexDirection.Row,\n    'row-reverse': Yoga.FlexDirection.RowReverse,\n    'column-reverse': Yoga.FlexDirection.ColumnReverse,\n};\n/**\n * Set flex direction attribute to node's Yoga instance\n *\n * @param value - Flex direction value\n * @returns Node instance wrapper\n */\nconst setFlexDirection = (value) => (node) => {\n    const { yogaNode } = node;\n    if (yogaNode) {\n        const flexDirection = FLEX_DIRECTIONS[value] || Yoga.FlexDirection.Column;\n        yogaNode.setFlexDirection(flexDirection);\n    }\n    return node;\n};\n\nconst JUSTIFY_CONTENT = {\n    center: Yoga.Justify.Center,\n    'flex-end': Yoga.Justify.FlexEnd,\n    'space-between': Yoga.Justify.SpaceBetween,\n    'space-around': Yoga.Justify.SpaceAround,\n    'space-evenly': Yoga.Justify.SpaceEvenly,\n};\n/**\n * Set justify content attribute to node's Yoga instance\n *\n * @param value - Justify content value\n * @returns Node instance wrapper\n */\nconst setJustifyContent = (value) => (node) => {\n    const { yogaNode } = node;\n    if (!isNil(value) && yogaNode) {\n        const justifyContent = JUSTIFY_CONTENT[value] || Yoga.Justify.FlexStart;\n        yogaNode.setJustifyContent(justifyContent);\n    }\n    return node;\n};\n\n/**\n * Set margin top attribute to node's Yoga instance\n *\n * @param margin - Margin top\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMarginTop = setYogaValue('margin', Yoga.Edge.Top);\n/**\n * Set margin right attribute to node's Yoga instance\n *\n * @param margin - Margin right\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMarginRight = setYogaValue('margin', Yoga.Edge.Right);\n/**\n * Set margin bottom attribute to node's Yoga instance\n *\n * @param margin - Margin bottom\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMarginBottom = setYogaValue('margin', Yoga.Edge.Bottom);\n/**\n * Set margin left attribute to node's Yoga instance\n *\n * @param margin - Margin left\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMarginLeft = setYogaValue('margin', Yoga.Edge.Left);\n\n/**\n * Set padding top attribute to node's Yoga instance\n *\n * @param padding - Padding top\n * @param node - Node instance\n * @returns Node instance\n */\nconst setPaddingTop = setYogaValue('padding', Yoga.Edge.Top);\n/**\n * Set padding right attribute to node's Yoga instance\n *\n * @param padding - Padding right\n * @param node - Node instance\n * @returns Node instance\n */\nconst setPaddingRight = setYogaValue('padding', Yoga.Edge.Right);\n/**\n * Set padding bottom attribute to node's Yoga instance\n *\n * @param padding - Padding bottom\n * @param node Node instance\n * @returns Node instance\n */\nconst setPaddingBottom = setYogaValue('padding', Yoga.Edge.Bottom);\n/**\n * Set padding left attribute to node's Yoga instance\n *\n * @param padding - Padding left\n * @param node - Node instance\n * @returns Node instance\n */\nconst setPaddingLeft = setYogaValue('padding', Yoga.Edge.Left);\n\n/**\n * Set border top attribute to node's Yoga instance\n *\n * @param border - Border top width\n * @param node - Node instance\n * @returns Node instance\n */\nconst setBorderTop = setYogaValue('border', Yoga.Edge.Top);\n/**\n * Set border right attribute to node's Yoga instance\n *\n * @param border - Border right width\n * @param node - Node instance\n * @returns Node instance\n */\nconst setBorderRight = setYogaValue('border', Yoga.Edge.Right);\n/**\n * Set border bottom attribute to node's Yoga instance\n *\n * @param border - Border bottom width\n * @param node - Node instance\n * @returns Node instance\n */\nconst setBorderBottom = setYogaValue('border', Yoga.Edge.Bottom);\n/**\n * Set border left attribute to node's Yoga instance\n *\n * @param border - Border left width\n * @param node - Node instance\n * @returns Node instance\n */\nconst setBorderLeft = setYogaValue('border', Yoga.Edge.Left);\n\n/**\n * Set position top attribute to node's Yoga instance\n *\n * @param position - Position top\n * @param node - Node instance\n * @returns Node instance\n */\nconst setPositionTop = setYogaValue('position', Yoga.Edge.Top);\n/**\n * Set position right attribute to node's Yoga instance\n *\n * @param position - Position right\n * @param node - Node instance\n * @returns Node instance\n */\nconst setPositionRight = setYogaValue('position', Yoga.Edge.Right);\n/**\n * Set position bottom attribute to node's Yoga instance\n *\n * @param position - Position bottom\n * @param node - Node instance\n * @returns Node instance\n */\nconst setPositionBottom = setYogaValue('position', Yoga.Edge.Bottom);\n/**\n * Set position left attribute to node's Yoga instance\n *\n * @param position - Position left\n * @param node - Node instance\n * @returns Node instance\n */\nconst setPositionLeft = setYogaValue('position', Yoga.Edge.Left);\n\n/**\n * Set width to node's Yoga instance\n *\n * @param width - Width\n * @param node - Node instance\n * @returns Node instance\n */\nconst setWidth = setYogaValue('width');\n/**\n * Set min width to node's Yoga instance\n *\n * @param min - Width\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMinWidth = setYogaValue('minWidth');\n/**\n * Set max width to node's Yoga instance\n *\n * @param max - Width\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMaxWidth = setYogaValue('maxWidth');\n/**\n * Set height to node's Yoga instance\n *\n * @param height - Height\n * @param node - Node instance\n * @returns Node instance\n */\nconst setHeight = setYogaValue('height');\n/**\n * Set min height to node's Yoga instance\n *\n * @param min - Height\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMinHeight = setYogaValue('minHeight');\n/**\n * Set max height to node's Yoga instance\n *\n * @param max - Height\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMaxHeight = setYogaValue('maxHeight');\n\n/**\n * Set rowGap value to node's Yoga instance\n *\n * @param value - Gap value\n * @returns Node instance wrapper\n */\nconst setRowGap = setYogaValue('gap', Yoga.Gutter.Row);\n/**\n * Set columnGap value to node's Yoga instance\n *\n * @param value - Gap value\n * @returns Node instance wrapper\n */\nconst setColumnGap = setYogaValue('gap', Yoga.Gutter.Column);\n\nconst getAspectRatio = (viewbox) => {\n    if (!viewbox)\n        return null;\n    if (typeof viewbox === 'string')\n        return null;\n    return (viewbox.maxX - viewbox.minX) / (viewbox.maxY - viewbox.minY);\n};\n/**\n * Yoga svg measure function\n *\n * @param page\n * @param node\n * @returns Measure svg\n */\nconst measureCanvas$1 = (page, node) => (width, widthMode, height, heightMode) => {\n    const aspectRatio = getAspectRatio(node.props.viewBox) || 1;\n    if (widthMode === Yoga.MeasureMode.Exactly ||\n        widthMode === Yoga.MeasureMode.AtMost) {\n        return { width, height: width / aspectRatio };\n    }\n    if (heightMode === Yoga.MeasureMode.Exactly) {\n        return { width: height * aspectRatio };\n    }\n    return {};\n};\n\n/**\n * Get lines width (if any)\n *\n * @param node\n * @returns Lines width\n */\nconst linesWidth = (node) => {\n    if (!node.lines)\n        return 0;\n    return Math.max(0, ...node.lines.map((line) => line.xAdvance));\n};\n\n/**\n * Get lines height (if any)\n *\n * @param node\n * @returns Lines height\n */\nconst linesHeight = (node) => {\n    if (!node.lines)\n        return -1;\n    return node.lines.reduce((acc, line) => acc + line.box.height, 0);\n};\n\nconst ALIGNMENT_FACTORS = { center: 0.5, right: 1 };\n/**\n * Yoga text measure function\n *\n * @param page\n * @param node\n * @param fontStore\n * @returns {MeasureText} measure text function\n */\nconst measureText = (page, node, fontStore) => (width, widthMode, height) => {\n    if (widthMode === Yoga.MeasureMode.Exactly) {\n        if (!node.lines)\n            node.lines = layoutText(node, width, height, fontStore);\n        return { height: linesHeight(node), width };\n    }\n    if (widthMode === Yoga.MeasureMode.AtMost) {\n        const alignFactor = ALIGNMENT_FACTORS[node.style?.textAlign] || 0;\n        if (!node.lines) {\n            node.lines = layoutText(node, width, height, fontStore);\n            node.alignOffset = (width - linesWidth(node)) * alignFactor; // Compensate align in variable width containers\n        }\n        return {\n            height: linesHeight(node),\n            width: Math.min(width, linesWidth(node)),\n        };\n    }\n    return {};\n};\n\n/**\n * Get image ratio\n *\n * @param node - Image node\n * @returns Image ratio\n */\nconst getRatio = (node) => {\n    return node.image?.data ? node.image.width / node.image.height : 1;\n};\n\n/**\n * Checks if page has auto height\n *\n * @param page\n * @returns Is page height auto\n */\nconst isHeightAuto = (page) => isNil(page.box?.height);\n\nconst SAFETY_HEIGHT$1 = 10;\n/**\n * Yoga image measure function\n *\n * @param page - Page\n * @param node - Node\n * @returns Measure image\n */\nconst measureImage = (page, node) => (width, widthMode, height, heightMode) => {\n    const imageRatio = getRatio(node);\n    const imageMargin = getMargin(node);\n    const pagePadding = getPadding(page);\n    // TODO: Check image percentage margins\n    const pageArea = isHeightAuto(page)\n        ? Infinity\n        : (page.box?.height || 0) -\n            pagePadding.paddingTop -\n            pagePadding.paddingBottom -\n            imageMargin.marginTop -\n            imageMargin.marginBottom -\n            SAFETY_HEIGHT$1;\n    // Skip measure if image data not present yet\n    if (!node.image)\n        return { width: 0, height: 0 };\n    if (widthMode === Yoga.MeasureMode.Exactly &&\n        heightMode === Yoga.MeasureMode.Undefined) {\n        const scaledHeight = width / imageRatio;\n        return { height: Math.min(pageArea, scaledHeight) };\n    }\n    if (heightMode === Yoga.MeasureMode.Exactly &&\n        (widthMode === Yoga.MeasureMode.AtMost ||\n            widthMode === Yoga.MeasureMode.Undefined)) {\n        return { width: Math.min(height * imageRatio, width) };\n    }\n    if (widthMode === Yoga.MeasureMode.Exactly &&\n        heightMode === Yoga.MeasureMode.AtMost) {\n        const scaledHeight = width / imageRatio;\n        return { height: Math.min(height, pageArea, scaledHeight) };\n    }\n    if (widthMode === Yoga.MeasureMode.AtMost &&\n        heightMode === Yoga.MeasureMode.AtMost) {\n        if (imageRatio > 1) {\n            return {\n                width,\n                height: Math.min(width / imageRatio, height),\n            };\n        }\n        return {\n            height,\n            width: Math.min(height * imageRatio, width),\n        };\n    }\n    return { height, width };\n};\n\nconst SAFETY_HEIGHT = 10;\nconst getMax = (values) => Math.max(-Infinity, ...values);\n/**\n * Helper object to predict canvas size\n * TODO: Implement remaining functions (as close as possible);\n */\nconst measureCtx = () => {\n    const ctx = {};\n    const points = [];\n    const nil = () => ctx;\n    const addPoint = (x, y) => points.push([x, y]);\n    const moveTo = (x, y) => {\n        addPoint(x, y);\n        return ctx;\n    };\n    const rect = (x, y, w, h) => {\n        addPoint(x, y);\n        addPoint(x + w, y);\n        addPoint(x, y + h);\n        addPoint(x + w, y + h);\n        return ctx;\n    };\n    const ellipse = (x, y, rx, ry) => {\n        ry = ry || rx;\n        addPoint(x - rx, y - ry);\n        addPoint(x + rx, y - ry);\n        addPoint(x + rx, y + ry);\n        addPoint(x - rx, y + ry);\n        return ctx;\n    };\n    const polygon = (...pts) => {\n        points.push(...pts);\n        return ctx;\n    };\n    // Change dimensions\n    ctx.rect = rect;\n    ctx.moveTo = moveTo;\n    ctx.lineTo = moveTo;\n    ctx.circle = ellipse;\n    ctx.polygon = polygon;\n    ctx.ellipse = ellipse;\n    ctx.roundedRect = rect;\n    // To be implemented\n    ctx.text = nil;\n    ctx.path = nil;\n    ctx.lineWidth = nil;\n    ctx.bezierCurveTo = nil;\n    ctx.quadraticCurveTo = nil;\n    ctx.scale = nil;\n    ctx.rotate = nil;\n    ctx.translate = nil;\n    // These don't change dimensions\n    ctx.dash = nil;\n    ctx.clip = nil;\n    ctx.save = nil;\n    ctx.fill = nil;\n    ctx.font = nil;\n    ctx.stroke = nil;\n    ctx.lineCap = nil;\n    ctx.opacity = nil;\n    ctx.restore = nil;\n    ctx.lineJoin = nil;\n    ctx.fontSize = nil;\n    ctx.fillColor = nil;\n    ctx.miterLimit = nil;\n    ctx.strokeColor = nil;\n    ctx.fillOpacity = nil;\n    ctx.strokeOpacity = nil;\n    ctx.linearGradient = nil;\n    ctx.radialGradient = nil;\n    ctx.getWidth = () => getMax(points.map((p) => p[0]));\n    ctx.getHeight = () => getMax(points.map((p) => p[1]));\n    return ctx;\n};\n/**\n * @typedef {Function} MeasureCanvas\n * @returns {{ width: number, height: number }} canvas width and height\n */\n/**\n * Yoga canvas measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @returns {MeasureCanvas} measure canvas\n */\nconst measureCanvas = (page, node) => () => {\n    const imageMargin = getMargin(node);\n    const pagePadding = getPadding(page);\n    // TODO: Check image percentage margins\n    const pageArea = isHeightAuto(page)\n        ? Infinity\n        : (page.box?.height || 0) -\n            pagePadding.paddingTop -\n            pagePadding.paddingBottom -\n            imageMargin.marginTop -\n            imageMargin.marginBottom -\n            SAFETY_HEIGHT;\n    const ctx = measureCtx();\n    node.props.paint(ctx);\n    const width = ctx.getWidth();\n    const height = Math.min(pageArea, ctx.getHeight());\n    return { width, height };\n};\n\nconst isType$1 = (type) => (node) => node.type === type;\nconst isSvg = isType$1(P.Svg);\nconst isText$2 = isType$1(P.Text);\nconst isNote = isType$1(P.Note);\nconst isPage = isType$1(P.Page);\nconst isImage = isType$1(P.Image);\nconst isCanvas = isType$1(P.Canvas);\nconst isTextInstance$1 = isType$1(P.TextInstance);\nconst setNodeHeight = (node) => {\n    const value = isPage(node) ? node.box?.height : node.style?.height;\n    return setHeight(value);\n};\n/**\n * Set styles valeus into yoga node before layout calculation\n *\n * @param node\n */\nconst setYogaValues = (node) => {\n    compose(setNodeHeight(node), setWidth(node.style.width), setMinWidth(node.style.minWidth), setMaxWidth(node.style.maxWidth), setMinHeight(node.style.minHeight), setMaxHeight(node.style.maxHeight), setMarginTop(node.style.marginTop), setMarginRight(node.style.marginRight), setMarginBottom(node.style.marginBottom), setMarginLeft(node.style.marginLeft), setPaddingTop(node.style.paddingTop), setPaddingRight(node.style.paddingRight), setPaddingBottom(node.style.paddingBottom), setPaddingLeft(node.style.paddingLeft), setPositionType(node.style.position), setPositionTop(node.style.top), setPositionRight(node.style.right), setPositionBottom(node.style.bottom), setPositionLeft(node.style.left), setBorderTop(node.style.borderTopWidth), setBorderRight(node.style.borderRightWidth), setBorderBottom(node.style.borderBottomWidth), setBorderLeft(node.style.borderLeftWidth), setDisplay(node.style.display), setFlexDirection(node.style.flexDirection), setAlignSelf(node.style.alignSelf), setAlignContent(node.style.alignContent), setAlignItems(node.style.alignItems), setJustifyContent(node.style.justifyContent), setFlexWrap(node.style.flexWrap), setOverflow(node.style.overflow), setAspectRatio(node.style.aspectRatio), setFlexBasis(node.style.flexBasis), setFlexGrow(node.style.flexGrow), setFlexShrink(node.style.flexShrink), setRowGap(node.style.rowGap), setColumnGap(node.style.columnGap))(node);\n};\n/**\n * Inserts child into parent' yoga node\n *\n * @param parent parent\n * @returns Insert yoga nodes\n */\nconst insertYogaNodes = (parent) => (child) => {\n    parent.insertChild(child.yogaNode, parent.getChildCount());\n    return child;\n};\nconst setMeasureFunc = (node, page, fontStore) => {\n    const { yogaNode } = node;\n    if (isText$2(node)) {\n        yogaNode.setMeasureFunc(measureText(page, node, fontStore));\n    }\n    if (isImage(node)) {\n        yogaNode.setMeasureFunc(measureImage(page, node));\n    }\n    if (isCanvas(node)) {\n        yogaNode.setMeasureFunc(measureCanvas(page, node));\n    }\n    if (isSvg(node)) {\n        yogaNode.setMeasureFunc(measureCanvas$1(page, node));\n    }\n    return node;\n};\nconst isLayoutElement = (node) => !isText$2(node) && !isNote(node) && !isSvg(node);\n/**\n * @typedef {Function} CreateYogaNodes\n * @param {Object} node\n * @returns {Object} node with appended yoga node\n */\n/**\n * Creates and add yoga node to document tree\n * Handles measure function for text and image nodes\n *\n * @returns Create yoga nodes\n */\nconst createYogaNodes = (page, fontStore, yoga) => (node) => {\n    const yogaNode = yoga.node.create();\n    const result = Object.assign({}, node, { yogaNode });\n    setYogaValues(result);\n    if (isLayoutElement(node) && node.children) {\n        const resolveChild = compose(insertYogaNodes(yogaNode), createYogaNodes(page, fontStore, yoga));\n        result.children = node.children.map(resolveChild);\n    }\n    setMeasureFunc(result, page, fontStore);\n    return result;\n};\n/**\n * Performs yoga calculation\n *\n * @param page - Page node\n * @returns Page node\n */\nconst calculateLayout = (page) => {\n    page.yogaNode.calculateLayout();\n    return page;\n};\n/**\n * Saves Yoga layout result into 'box' attribute of node\n *\n * @param node\n * @returns Node with box data\n */\nconst persistDimensions = (node) => {\n    if (isTextInstance$1(node))\n        return node;\n    const box = Object.assign(getPadding(node), getMargin(node), getBorderWidth(node), getPosition(node), getDimension(node));\n    const newNode = Object.assign({}, node, { box });\n    if (!node.children)\n        return newNode;\n    const children = node.children.map(persistDimensions);\n    return Object.assign({}, newNode, { children });\n};\n/**\n * Removes yoga node from document tree\n *\n * @param node\n * @returns Node without yoga node\n */\nconst destroyYogaNodes = (node) => {\n    const newNode = Object.assign({}, node);\n    delete newNode.yogaNode;\n    if (!node.children)\n        return newNode;\n    const children = node.children.map(destroyYogaNodes);\n    return Object.assign({}, newNode, { children });\n};\n/**\n * Free yoga node from document tree\n *\n * @param node\n * @returns Node without yoga node\n */\nconst freeYogaNodes = (node) => {\n    if (node.yogaNode)\n        node.yogaNode.freeRecursive();\n    return node;\n};\n/**\n * Calculates page object layout using Yoga.\n * Takes node values from 'box' and 'style' attributes, and persist them back into 'box'\n * Destroy yoga values at the end.\n *\n * @param page - Object\n * @returns Page object with correct 'box' layout attributes\n */\nconst resolvePageDimensions = (page, fontStore, yoga) => {\n    if (isNil(page))\n        return null;\n    return compose(destroyYogaNodes, freeYogaNodes, persistDimensions, calculateLayout, createYogaNodes(page, fontStore, yoga))(page);\n};\n/**\n * Calculates root object layout using Yoga.\n *\n * @param node - Root object\n * @param fontStore - Font store\n * @returns Root object with correct 'box' layout attributes\n */\nconst resolveDimensions = (node, fontStore) => {\n    if (!node.children)\n        return node;\n    const resolveChild = (child) => resolvePageDimensions(child, fontStore, node.yoga);\n    const children = node.children.map(resolveChild);\n    return Object.assign({}, node, { children });\n};\n\nconst isText$1 = (node) => node.type === P.Text;\n// Prevent splitting elements by low decimal numbers\nconst SAFETY_THRESHOLD = 0.001;\nconst assingChildren = (children, node) => Object.assign({}, node, { children });\nconst getTop = (node) => node.box?.top || 0;\nconst allFixed = (nodes) => nodes.every(isFixed);\nconst isDynamic = (node) => node.props && 'render' in node.props;\nconst relayoutPage = compose(resolveTextLayout, resolvePageDimensions, resolveInheritance, resolvePageStyles);\nconst warnUnavailableSpace = (node) => {\n    console.warn(`Node of type ${node.type} can't wrap between pages and it's bigger than available page height`);\n};\nconst splitNodes = (height, contentArea, nodes) => {\n    const currentChildren = [];\n    const nextChildren = [];\n    for (let i = 0; i < nodes.length; i += 1) {\n        const child = nodes[i];\n        const futureNodes = nodes.slice(i + 1);\n        const futureFixedNodes = futureNodes.filter(isFixed);\n        const nodeTop = getTop(child);\n        const nodeHeight = child.box.height;\n        const isOutside = height <= nodeTop;\n        const shouldBreak$1 = shouldBreak(child, futureNodes, height, currentChildren);\n        const shouldSplit = height + SAFETY_THRESHOLD < nodeTop + nodeHeight;\n        const canWrap = getWrap(child);\n        const fitsInsidePage = nodeHeight <= contentArea;\n        if (isFixed(child)) {\n            nextChildren.push(child);\n            currentChildren.push(child);\n            continue;\n        }\n        if (isOutside) {\n            const box = Object.assign({}, child.box, { top: child.box.top - height });\n            const next = Object.assign({}, child, { box });\n            nextChildren.push(next);\n            continue;\n        }\n        if (!fitsInsidePage && !canWrap) {\n            currentChildren.push(child);\n            nextChildren.push(...futureNodes);\n            warnUnavailableSpace(child);\n            break;\n        }\n        if (shouldBreak$1) {\n            const box = Object.assign({}, child.box, { top: child.box.top - height });\n            const props = Object.assign({}, child.props, {\n                wrap: true,\n                break: false,\n            });\n            const next = Object.assign({}, child, { box, props });\n            currentChildren.push(...futureFixedNodes);\n            nextChildren.push(next, ...futureNodes);\n            break;\n        }\n        if (shouldSplit) {\n            const [currentChild, nextChild] = split(child, height, contentArea);\n            // All children are moved to the next page, it doesn't make sense to show the parent on the current page\n            if (child.children.length > 0 && currentChild.children.length === 0) {\n                // But if the current page is empty then we can just include the parent on the current page\n                if (currentChildren.length === 0) {\n                    currentChildren.push(child, ...futureFixedNodes);\n                    nextChildren.push(...futureNodes);\n                }\n                else {\n                    const box = Object.assign({}, child.box, {\n                        top: child.box.top - height,\n                    });\n                    const next = Object.assign({}, child, { box });\n                    currentChildren.push(...futureFixedNodes);\n                    nextChildren.push(next, ...futureNodes);\n                }\n                break;\n            }\n            if (currentChild)\n                currentChildren.push(currentChild);\n            if (nextChild)\n                nextChildren.push(nextChild);\n            continue;\n        }\n        currentChildren.push(child);\n    }\n    return [currentChildren, nextChildren];\n};\nconst splitChildren = (height, contentArea, node) => {\n    const children = node.children || [];\n    const availableHeight = height - getTop(node);\n    return splitNodes(availableHeight, contentArea, children);\n};\nconst splitView = (node, height, contentArea) => {\n    const [currentNode, nextNode] = splitNode(node, height);\n    const [currentChilds, nextChildren] = splitChildren(height, contentArea, node);\n    return [\n        assingChildren(currentChilds, currentNode),\n        assingChildren(nextChildren, nextNode),\n    ];\n};\nconst split = (node, height, contentArea) => isText$1(node) ? splitText(node, height) : splitView(node, height, contentArea);\nconst shouldResolveDynamicNodes = (node) => {\n    const children = node.children || [];\n    return isDynamic(node) || children.some(shouldResolveDynamicNodes);\n};\nconst resolveDynamicNodes = (props, node) => {\n    const isNodeDynamic = isDynamic(node);\n    // Call render prop on dynamic nodes and append result to children\n    const resolveChildren = (children = []) => {\n        if (isNodeDynamic) {\n            const res = node.props.render(props);\n            return (createInstances(res)\n                .filter(Boolean)\n                // @ts-expect-error rework dynamic nodes. conflicting types\n                .map((n) => resolveDynamicNodes(props, n)));\n        }\n        return children.map((c) => resolveDynamicNodes(props, c));\n    };\n    // We reset dynamic text box so it can be computed again later on\n    const resetHeight = isNodeDynamic && isText$1(node);\n    const box = resetHeight ? { ...node.box, height: 0 } : node.box;\n    const children = resolveChildren(node.children);\n    // @ts-expect-error handle text here specifically\n    const lines = isNodeDynamic ? null : node.lines;\n    return Object.assign({}, node, { box, lines, children });\n};\nconst resolveDynamicPage = (props, page, fontStore, yoga) => {\n    if (shouldResolveDynamicNodes(page)) {\n        const resolvedPage = resolveDynamicNodes(props, page);\n        return relayoutPage(resolvedPage, fontStore, yoga);\n    }\n    return page;\n};\nconst splitPage = (page, pageNumber, fontStore, yoga) => {\n    const wrapArea = getWrapArea(page);\n    const contentArea = getContentArea(page);\n    const dynamicPage = resolveDynamicPage({ pageNumber }, page, fontStore, yoga);\n    const height = page.style.height;\n    const [currentChilds, nextChilds] = splitNodes(wrapArea, contentArea, dynamicPage.children);\n    const relayout = (node) => \n    // @ts-expect-error rework pagination\n    relayoutPage(node, fontStore, yoga);\n    const currentBox = { ...page.box, height };\n    const currentPage = relayout(Object.assign({}, page, { box: currentBox, children: currentChilds }));\n    if (nextChilds.length === 0 || allFixed(nextChilds))\n        return [currentPage, null];\n    const nextBox = omit('height', page.box);\n    const nextProps = omit('bookmark', page.props);\n    const nextPage = relayout(Object.assign({}, page, {\n        props: nextProps,\n        box: nextBox,\n        children: nextChilds,\n    }));\n    return [currentPage, nextPage];\n};\nconst resolvePageIndices = (fontStore, yoga, page, pageNumber, pages) => {\n    const totalPages = pages.length;\n    const props = {\n        totalPages,\n        pageNumber: pageNumber + 1,\n        subPageNumber: page.subPageNumber + 1,\n        subPageTotalPages: page.subPageTotalPages,\n    };\n    return resolveDynamicPage(props, page, fontStore, yoga);\n};\nconst assocSubPageData = (subpages) => {\n    return subpages.map((page, i) => ({\n        ...page,\n        subPageNumber: i,\n        subPageTotalPages: subpages.length,\n    }));\n};\nconst dissocSubPageData = (page) => {\n    return omit(['subPageNumber', 'subPageTotalPages'], page);\n};\nconst paginate = (page, pageNumber, fontStore, yoga) => {\n    if (!page)\n        return [];\n    if (page.props?.wrap === false)\n        return [page];\n    let splittedPage = splitPage(page, pageNumber, fontStore, yoga);\n    const pages = [splittedPage[0]];\n    let nextPage = splittedPage[1];\n    while (nextPage !== null) {\n        splittedPage = splitPage(nextPage, pageNumber + pages.length, fontStore, yoga);\n        pages.push(splittedPage[0]);\n        nextPage = splittedPage[1];\n    }\n    return pages;\n};\n/**\n * Performs pagination. This is the step responsible of breaking the whole document\n * into pages following pagiation rules, such as `fixed`, `break` and dynamic nodes.\n *\n * @param root - Document node\n * @param fontStore - Font store\n * @returns Layout node\n */\nconst resolvePagination = (root, fontStore) => {\n    let pages = [];\n    let pageNumber = 1;\n    for (let i = 0; i < root.children.length; i += 1) {\n        const page = root.children[i];\n        let subpages = paginate(page, pageNumber, fontStore, root.yoga);\n        subpages = assocSubPageData(subpages);\n        pageNumber += subpages.length;\n        pages = pages.concat(subpages);\n    }\n    pages = pages.map((...args) => dissocSubPageData(resolvePageIndices(fontStore, root.yoga, ...args)));\n    return assingChildren(pages, root);\n};\n\n/**\n * Translates page percentage horizontal paddings in fixed ones\n *\n * @param container - Page container\n * @returns Resolve page horizontal padding\n */\nconst resolvePageHorizontalPadding = (container) => (value) => {\n    const match = matchPercent(value);\n    const width = container.width;\n    return match ? match.percent * width : value;\n};\n/**\n * Translates page percentage vertical paddings in fixed ones\n *\n * @param container - Page container\n * @returns Resolve page vertical padding\n */\nconst resolvePageVerticalPadding = (container) => (value) => {\n    const match = matchPercent(value);\n    const height = container.height;\n    return match ? match.percent * height : value;\n};\n/**\n * Translates page percentage paddings in fixed ones\n *\n * @param page\n * @returns Page with fixed paddings\n */\nconst resolvePagePaddings = (page) => {\n    const container = page.style;\n    const style = evolve({\n        paddingTop: resolvePageVerticalPadding(container),\n        paddingLeft: resolvePageHorizontalPadding(container),\n        paddingRight: resolvePageHorizontalPadding(container),\n        paddingBottom: resolvePageVerticalPadding(container),\n    }, page.style);\n    return Object.assign({}, page, { style });\n};\n/**\n * Translates all pages percentage paddings in fixed ones\n * This has to be computed from pages calculated size and not by Yoga\n * because at this point we didn't performed pagination yet.\n *\n * @param root - Document root\n * @returns Document root with translated page paddings\n */\nconst resolvePagesPaddings = (root) => {\n    if (!root.children)\n        return root;\n    const children = root.children.map(resolvePagePaddings);\n    return Object.assign({}, root, { children });\n};\n\nconst resolveRadius = (box) => (value) => {\n    if (!value)\n        return undefined;\n    const match = matchPercent(value);\n    return match ? match.percent * Math.min(box.width, box.height) : value;\n};\n/**\n * Transforms percent border radius into fixed values\n *\n * @param node\n * @returns Node\n */\nconst resolvePercentRadius = (node) => {\n    const style = evolve({\n        borderTopLeftRadius: resolveRadius(node.box),\n        borderTopRightRadius: resolveRadius(node.box),\n        borderBottomRightRadius: resolveRadius(node.box),\n        borderBottomLeftRadius: resolveRadius(node.box),\n    }, node.style || {});\n    const newNode = Object.assign({}, node, { style });\n    if (!node.children)\n        return newNode;\n    const children = node.children.map(resolvePercentRadius);\n    return Object.assign({}, newNode, { children });\n};\n\n/**\n * Transform percent height into fixed\n *\n * @param height\n * @returns Height\n */\nconst transformHeight = (pageArea, height) => {\n    const match = matchPercent(height);\n    return match ? match.percent * pageArea : height;\n};\n/**\n * Get page area (height minus paddings)\n *\n * @param page\n * @returns Page area\n */\nconst getPageArea = (page) => {\n    const pageHeight = page.style.height;\n    const pagePaddingTop = (page.style?.paddingTop || 0);\n    const pagePaddingBottom = (page.style?.paddingBottom || 0);\n    return pageHeight - pagePaddingTop - pagePaddingBottom;\n};\n/**\n * Transform node percent height to fixed\n *\n * @param page\n * @param node\n * @returns Transformed node\n */\nconst resolveNodePercentHeight = (page, node) => {\n    if (isNil(page.style?.height))\n        return node;\n    if (isNil(node.style?.height))\n        return node;\n    const pageArea = getPageArea(page);\n    const height = transformHeight(pageArea, node.style.height);\n    const style = Object.assign({}, node.style, { height });\n    return Object.assign({}, node, { style });\n};\n/**\n * Transform page immediate children with percent height to fixed\n *\n * @param page\n * @returns Transformed page\n */\nconst resolvePagePercentHeight = (page) => {\n    if (!page.children)\n        return page;\n    const resolveChild = (child) => resolveNodePercentHeight(page, child);\n    const children = page.children.map(resolveChild);\n    return Object.assign({}, page, { children });\n};\n/**\n * Transform all page immediate children with percent height to fixed.\n * This is needed for computing correct dimensions on pre-pagination layout.\n *\n * @param root - Document root\n * @returns Transformed document root\n */\nconst resolvePercentHeight = (root) => {\n    if (!root.children)\n        return root;\n    const children = root.children.map(resolvePagePercentHeight);\n    return Object.assign({}, root, { children });\n};\n\nconst isType = (type) => (node) => node.type === type;\nconst isLink = isType(P.Link);\nconst isText = isType(P.Text);\nconst isTextInstance = isType(P.TextInstance);\n/**\n * Checks if node has render prop\n *\n * @param node\n * @returns Has render prop?\n */\nconst hasRenderProp = (node) => 'render' in node.props;\n/**\n * Checks if node is text type (Text or TextInstance)\n *\n * @param node\n * @returns Are all children text instances?\n */\nconst isTextType = (node) => isText(node) || isTextInstance(node);\n/**\n * Checks if is tet link that needs to be wrapped in Text\n *\n * @param node\n * @returns Are all children text instances?\n */\nconst isTextLink = (node) => {\n    const children = node.children || [];\n    // Text string inside a Link\n    if (children.every(isTextInstance))\n        return true;\n    // Text node inside a Link\n    if (children.every(isText))\n        return false;\n    return children.every(isTextType);\n};\n/**\n * Wraps node children inside Text node\n *\n * @param node\n * @returns Node with intermediate Text child\n */\nconst wrapText = (node) => {\n    const textElement = {\n        type: P.Text,\n        props: {},\n        style: {},\n        box: {},\n        children: node.children,\n    };\n    return Object.assign({}, node, { children: [textElement] });\n};\nconst transformLink = (node) => {\n    if (!isLink(node))\n        return node;\n    // If has render prop substitute the instance by a Text, that will\n    // ultimately render the inline Link via the textkit PDF renderer.\n    if (hasRenderProp(node))\n        return Object.assign({}, node, { type: P.Text });\n    // If is a text link (either contains Text or TextInstance), wrap it\n    // inside a Text element so styles are applied correctly\n    if (isTextLink(node))\n        return wrapText(node);\n    return node;\n};\n/**\n * Transforms Link layout to correctly render text and dynamic rendered links\n *\n * @param node\n * @returns Node with link substitution\n */\nconst resolveLinkSubstitution = (node) => {\n    if (!node.children)\n        return node;\n    const resolveChild = compose(transformLink, resolveLinkSubstitution);\n    const children = node.children.map(resolveChild);\n    return Object.assign({}, node, { children });\n};\n\nconst layout = asyncCompose(resolveZIndex, resolveOrigin, resolveAssets, resolvePagination, resolveTextLayout, resolvePercentRadius, resolveDimensions, resolveSvg, resolveAssets, resolveInheritance, resolvePercentHeight, resolvePagesPaddings, resolveStyles, resolveLinkSubstitution, resolveBookmarks, resolvePageSizes, resolveYoga);\n\nexport { layout as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _defineProperty from \"C:/PreventaWeb/FrontEnd/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectWithoutProperties from \"C:/PreventaWeb/FrontEnd/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"C:/PreventaWeb/FrontEnd/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nconst _excluded = [\"excludeRects\"];\nimport { isNil, last, repeat, reverse, dropLast as dropLast$2, adjust, compose } from '@react-pdf/fns';\nimport bidiFactory from 'bidi-js';\nimport unicode from 'unicode-properties';\nimport hyphen from 'hyphen';\nimport pattern from 'hyphen/patterns/en-us.js';\n\n/**\n * Create attributed string from text fragments\n *\n * @param fragments - Fragments\n * @returns Attributed string\n */\nconst fromFragments = fragments => {\n  let offset = 0;\n  let string = '';\n  const runs = [];\n  fragments.forEach(fragment => {\n    string += fragment.string;\n    runs.push(_objectSpread(_objectSpread({}, fragment), {}, {\n      start: offset,\n      end: offset + fragment.string.length,\n      attributes: fragment.attributes || {}\n    }));\n    offset += fragment.string.length;\n  });\n  return {\n    string,\n    runs\n  };\n};\n\n/**\n * Default word hyphenation engine used when no one provided.\n * Does not perform word hyphenation at all\n *\n * @param word\n * @returns Same word\n */\nconst defaultHyphenationEngine = word => [word];\n/**\n * Wrap words of attribute string\n *\n * @param engines layout engines\n * @param options layout options\n */\nconst wrapWords = function () {\n  let engines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  /**\n   * @param attributedString - Attributed string\n   * @returns Attributed string including syllables\n   */\n  return attributedString => {\n    var _engines$wordHyphenat;\n    const syllables = [];\n    const fragments = [];\n    const hyphenateWord = options.hyphenationCallback || ((_engines$wordHyphenat = engines.wordHyphenation) === null || _engines$wordHyphenat === void 0 ? void 0 : _engines$wordHyphenat.call(engines)) || defaultHyphenationEngine;\n    for (let i = 0; i < attributedString.runs.length; i += 1) {\n      let string = '';\n      const run = attributedString.runs[i];\n      const words = attributedString.string.slice(run.start, run.end).split(/([ ]+)/g).filter(Boolean);\n      for (let j = 0; j < words.length; j += 1) {\n        const word = words[j];\n        const parts = hyphenateWord(word);\n        syllables.push(...parts);\n        string += parts.join('');\n      }\n      fragments.push(_objectSpread(_objectSpread({}, run), {}, {\n        string\n      }));\n    }\n    const result = _objectSpread(_objectSpread({}, fromFragments(fragments)), {}, {\n      syllables\n    });\n    return result;\n  };\n};\n\n/**\n * Clone rect\n *\n * @param rect - Rect\n * @returns Cloned rect\n */\nconst copy = rect => {\n  return Object.assign({}, rect);\n};\n\n/**\n * Partition rect in two in the vertical direction\n *\n * @param rect - Rect\n * @param height - Height\n * @returns Partitioned rects\n */\nconst partition = (rect, height) => {\n  const a = Object.assign({}, rect, {\n    height\n  });\n  const b = Object.assign({}, rect, {\n    y: rect.y + height,\n    height: rect.height - height\n  });\n  return [a, b];\n};\n\n/**\n * Crop upper section of rect\n *\n * @param height - Height\n * @param rect - Rect\n * @returns Cropped rect\n */\nconst crop = (height, rect) => {\n  const [, result] = partition(rect, height);\n  return result;\n};\n\n/**\n * Get paragraph block height\n *\n * @param paragraph - Paragraph\n * @returns Paragraph block height\n */\nconst height$2 = paragraph => {\n  return paragraph.reduce((acc, block) => acc + block.box.height, 0);\n};\n\n/**\n * Calculate run scale\n *\n * @param run - Run\n * @returns Scale\n */\nconst calculateScale = run => {\n  var _font$;\n  const attributes = run.attributes || {};\n  const fontSize = attributes.fontSize || 12;\n  const font = attributes.font;\n  const unitsPerEm = typeof font === 'string' ? null : font === null || font === void 0 || (_font$ = font[0]) === null || _font$ === void 0 ? void 0 : _font$.unitsPerEm;\n  return unitsPerEm ? fontSize / unitsPerEm : 0;\n};\n/**\n * Get run scale\n *\n * @param  run\n * @returns Scale\n */\nconst scale = run => {\n  var _run$attributes;\n  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.scale) || calculateScale(run);\n};\n\n/**\n * Get ligature offset by index\n *\n * Ex. ffi ligature\n *\n *   glyphs:         l  o  f  f  i  m\n *   glyphIndices:   0  1  2  2  2  3\n *   offset:         0  0  0  1  2  0\n *\n * @param index\n * @param run - Run\n * @returns Ligature offset\n */\nconst offset = (index, run) => {\n  if (!run) return 0;\n  const glyphIndices = run.glyphIndices || [];\n  const value = glyphIndices[index];\n  return glyphIndices.slice(0, index).filter(i => i === value).length;\n};\n\n/**\n * Get run font\n *\n * @param run - Run\n * @returns Font\n */\nconst getFont = run => {\n  var _run$attributes2;\n  return ((_run$attributes2 = run.attributes) === null || _run$attributes2 === void 0 || (_run$attributes2 = _run$attributes2.font) === null || _run$attributes2 === void 0 ? void 0 : _run$attributes2[0]) || null;\n};\n\n/**\n * Slice glyph between codePoints range\n * Util for breaking ligatures\n *\n * @param start - Start code point index\n * @param end - End code point index\n * @param font - Font to generate new glyph\n * @param glyph - Glyph to be sliced\n * @returns Sliced glyph parts\n */\nconst slice$2 = (start, end, font, glyph) => {\n  if (!glyph) return [];\n  if (start === end) return [];\n  if (start === 0 && end === glyph.codePoints.length) return [glyph];\n  const codePoints = glyph.codePoints.slice(start, end);\n  const string = String.fromCodePoint(...codePoints);\n  // passing LTR To force fontkit to not reverse the string\n  return font ? font.layout(string, undefined, undefined, undefined, 'ltr').glyphs : [glyph];\n};\n\n/**\n * Return glyph index at string index, if glyph indices present.\n * Otherwise return string index\n *\n * @param index - Index\n * @param run - Run\n * @returns Glyph index\n */\nconst glyphIndexAt = (index, run) => {\n  var _run$glyphIndices;\n  const result = run === null || run === void 0 || (_run$glyphIndices = run.glyphIndices) === null || _run$glyphIndices === void 0 ? void 0 : _run$glyphIndices[index];\n  return isNil(result) ? index : result;\n};\n\n/**\n * Returns new array starting with zero, and keeping same relation between consecutive values\n *\n * @param array - List\n * @returns Normalized array\n */\nconst normalize = array => {\n  const head = array[0];\n  return array.map(value => value - head);\n};\n\n/**\n * Slice run between glyph indices range\n *\n * @param start - Glyph index\n * @param end - Glyph index\n * @param run - Run\n * @returns Sliced run\n */\nconst slice$1 = (start, end, run) => {\n  var _run$glyphs, _run$glyphs2;\n  const runScale = scale(run);\n  const font = getFont(run);\n  // Get glyph start and end indices\n  const startIndex = glyphIndexAt(start, run);\n  const endIndex = glyphIndexAt(end, run);\n  // Get start and end glyph\n  const startGlyph = (_run$glyphs = run.glyphs) === null || _run$glyphs === void 0 ? void 0 : _run$glyphs[startIndex];\n  const endGlyph = (_run$glyphs2 = run.glyphs) === null || _run$glyphs2 === void 0 ? void 0 : _run$glyphs2[endIndex];\n  // Get start ligature chunks (if any)\n  const startOffset = offset(start, run);\n  const startGlyphs = startOffset > 0 ? slice$2(startOffset, Infinity, font, startGlyph) : [];\n  // Get end ligature chunks (if any)\n  const endOffset = offset(end, run);\n  const endGlyphs = slice$2(0, endOffset, font, endGlyph);\n  // Compute new glyphs\n  const sliceStart = startIndex + Math.min(1, startOffset);\n  const glyphs = (run.glyphs || []).slice(sliceStart, endIndex);\n  // Compute new positions\n  const glyphPosition = g => ({\n    xAdvance: g.advanceWidth * runScale,\n    yAdvance: 0,\n    xOffset: 0,\n    yOffset: 0\n  });\n  const startPositions = startGlyphs.map(glyphPosition);\n  const positions = (run.positions || []).slice(sliceStart, endIndex);\n  const endPositions = endGlyphs.map(glyphPosition);\n  return Object.assign({}, run, {\n    start: run.start + start,\n    end: Math.min(run.end, run.start + end),\n    glyphIndices: normalize((run.glyphIndices || []).slice(start, end)),\n    glyphs: [startGlyphs, glyphs, endGlyphs].flat(),\n    positions: [startPositions, positions, endPositions].flat()\n  });\n};\n\n/**\n * Get run index that contains passed index\n *\n * @param index - Index\n * @param runs - Runs\n * @returns Run index\n */\nconst runIndexAt$1 = (index, runs) => {\n  if (!runs) return -1;\n  return runs.findIndex(run => run.start <= index && index < run.end);\n};\n\n/**\n * Filter runs contained between start and end\n *\n * @param start\n * @param end\n * @param runs\n * @returns Filtered runs\n */\nconst filter = (start, end, runs) => {\n  const startIndex = runIndexAt$1(start, runs);\n  const endIndex = Math.max(runIndexAt$1(end - 1, runs), startIndex);\n  return runs.slice(startIndex, endIndex + 1);\n};\n\n/**\n * Subtract scalar to run\n *\n * @param index - Scalar\n * @param run - Run\n * @returns Subtracted run\n */\nconst subtract = (index, run) => {\n  const start = run.start - index;\n  const end = run.end - index;\n  return Object.assign({}, run, {\n    start,\n    end\n  });\n};\n\n/**\n * Slice array of runs\n *\n * @param start - Offset\n * @param end - Offset\n * @param runs\n * @returns Sliced runs\n */\nconst sliceRuns = (start, end, runs) => {\n  const sliceFirstRun = a => slice$1(start - a.start, end - a.start, a);\n  const sliceLastRun = a => slice$1(0, end - a.start, a);\n  return runs.map((run, i) => {\n    let result = run;\n    const isFirst = i === 0;\n    const isLast = !isFirst && i === runs.length - 1;\n    if (isFirst) result = sliceFirstRun(run);\n    if (isLast) result = sliceLastRun(run);\n    return subtract(start, result);\n  });\n};\n/**\n * Slice attributed string between two indices\n *\n * @param start - Offset\n * @param end - Offset\n * @param attributedString - Attributed string\n * @returns Attributed string\n */\nconst slice = (start, end, attributedString) => {\n  if (attributedString.string.length === 0) return attributedString;\n  const string = attributedString.string.slice(start, end);\n  const filteredRuns = filter(start, end, attributedString.runs);\n  const slicedRuns = sliceRuns(start, end, filteredRuns);\n  return Object.assign({}, attributedString, {\n    string,\n    runs: slicedRuns\n  });\n};\nconst findCharIndex = string => {\n  return string.search(/\\S/g);\n};\nconst findLastCharIndex = string => {\n  const match = string.match(/\\S/g);\n  return match ? string.lastIndexOf(match[match.length - 1]) : -1;\n};\n/**\n * Removes (strips) whitespace from both ends of the attributted string.\n *\n * @param attributedString - Attributed string\n * @returns Attributed string\n */\nconst trim = attributedString => {\n  const start = findCharIndex(attributedString.string);\n  const end = findLastCharIndex(attributedString.string);\n  return slice(start, end + 1, attributedString);\n};\n\n/**\n * Returns empty run\n *\n * @returns Empty run\n */\nconst empty$1 = () => {\n  return {\n    start: 0,\n    end: 0,\n    glyphIndices: [],\n    glyphs: [],\n    positions: [],\n    attributes: {}\n  };\n};\n\n/**\n * Check if value is a number\n *\n * @param value - Value to check\n * @returns Whether value is a number\n */\nconst isNumber = value => {\n  return typeof value === 'number';\n};\n\n/**\n * Append glyph indices with given length\n *\n * Ex. appendIndices(3, [0, 1, 2, 2]) => [0, 1, 2, 2, 3, 3, 3]\n *\n * @param length - Length\n * @param indices - Glyph indices\n * @returns Extended glyph indices\n */\nconst appendIndices = (length, indices) => {\n  const lastIndex = last(indices);\n  const value = isNil(lastIndex) ? 0 : lastIndex + 1;\n  const newIndices = Array(length).fill(value);\n  return indices.concat(newIndices);\n};\n\n/**\n * Get glyph for a given code point\n *\n * @param value - CodePoint\n * @param font - Font\n * @returns Glyph\n * */\nconst fromCodePoint = (value, font) => {\n  if (typeof font === 'string') return null;\n  return font && value ? font.glyphForCodePoint(value) : null;\n};\n\n/**\n * Append glyph to run\n *\n * @param glyph - Glyph\n * @param run - Run\n * @returns Run with glyph\n */\nconst appendGlyph = (glyph, run) => {\n  var _glyph$codePoints;\n  const glyphLength = ((_glyph$codePoints = glyph.codePoints) === null || _glyph$codePoints === void 0 ? void 0 : _glyph$codePoints.length) || 0;\n  const end = run.end + glyphLength;\n  const glyphs = run.glyphs.concat(glyph);\n  const glyphIndices = appendIndices(glyphLength, run.glyphIndices);\n  if (!run.positions) return Object.assign({}, run, {\n    end,\n    glyphs,\n    glyphIndices\n  });\n  const positions = run.positions.concat({\n    xAdvance: glyph.advanceWidth * scale(run),\n    yAdvance: 0,\n    xOffset: 0,\n    yOffset: 0\n  });\n  return Object.assign({}, run, {\n    end,\n    glyphs,\n    glyphIndices,\n    positions\n  });\n};\n/**\n * Append glyph or code point to run\n *\n * @param value - Glyph or codePoint\n * @param run - Run\n * @returns Run with glyph\n */\nconst append$1 = (value, run) => {\n  if (!value) return run;\n  const font = getFont(run);\n  const glyph = isNumber(value) ? fromCodePoint(value, font) : value;\n  return appendGlyph(glyph, run);\n};\n\n/**\n * Get string from array of code points\n *\n * @param codePoints - Points\n * @returns String\n */\nconst stringFromCodePoints = codePoints => {\n  return String.fromCodePoint(...(codePoints || []));\n};\n\n/**\n * Append glyph into last run of attributed string\n *\n * @param glyph - Glyph or code point\n * @param attributedString - Attributed string\n * @returns Attributed string with new glyph\n */\nconst append = (glyph, attributedString) => {\n  const codePoints = typeof glyph === 'number' ? [glyph] : glyph === null || glyph === void 0 ? void 0 : glyph.codePoints;\n  const codePointsString = stringFromCodePoints(codePoints || []);\n  const string = attributedString.string + codePointsString;\n  const firstRuns = attributedString.runs.slice(0, -1);\n  const lastRun = last(attributedString.runs) || empty$1();\n  const runs = firstRuns.concat(append$1(glyph, lastRun));\n  return Object.assign({}, attributedString, {\n    string,\n    runs\n  });\n};\nconst ELLIPSIS_UNICODE = 8230;\nconst ELLIPSIS_STRING = String.fromCharCode(ELLIPSIS_UNICODE);\n/**\n * Get ellipsis codepoint. This may be different in standard and embedded fonts\n *\n * @param font\n * @returns Ellipsis codepoint\n */\nconst getEllipsisCodePoint = font => {\n  if (!font.encode) return ELLIPSIS_UNICODE;\n  const [codePoints] = font.encode(ELLIPSIS_STRING);\n  return parseInt(codePoints[0], 16);\n};\n/**\n * Trucante block with ellipsis\n *\n * @param paragraph - Paragraph\n * @returns Sliced paragraph\n */\nconst truncate = paragraph => {\n  var _last, _last2;\n  const runs = ((_last = last(paragraph)) === null || _last === void 0 ? void 0 : _last.runs) || [];\n  const font = (_last2 = last(runs)) === null || _last2 === void 0 || (_last2 = _last2.attributes) === null || _last2 === void 0 ? void 0 : _last2.font[0];\n  if (font) {\n    const index = paragraph.length - 1;\n    const codePoint = getEllipsisCodePoint(font);\n    const glyph = font.glyphForCodePoint(codePoint);\n    const lastBlock = append(glyph, trim(paragraph[index]));\n    return Object.assign([], paragraph, {\n      [index]: lastBlock\n    });\n  }\n  return paragraph;\n};\n\n/**\n * Omit attribute from run\n *\n * @param value - Attribute key\n * @param run - Run\n * @returns Run without ommited attribute\n */\nconst omit = (value, run) => {\n  const attributes = Object.assign({}, run.attributes);\n  delete attributes[value];\n  return Object.assign({}, run, {\n    attributes\n  });\n};\n\n/**\n * Get run ascent\n *\n * @param run - Run\n * @returns Ascent\n */\nconst ascent$1 = run => {\n  var _font$2;\n  const {\n    font,\n    attachment\n  } = run.attributes;\n  const attachmentHeight = (attachment === null || attachment === void 0 ? void 0 : attachment.height) || 0;\n  const fontAscent = typeof font === 'string' ? 0 : (font === null || font === void 0 || (_font$2 = font[0]) === null || _font$2 === void 0 ? void 0 : _font$2.ascent) || 0;\n  return Math.max(attachmentHeight, fontAscent * scale(run));\n};\n\n/**\n * Get run descent\n *\n * @param run - Run\n * @returns Descent\n */\nconst descent = run => {\n  var _run$attributes3, _font$3;\n  const font = (_run$attributes3 = run.attributes) === null || _run$attributes3 === void 0 ? void 0 : _run$attributes3.font;\n  const fontDescent = typeof font === 'string' ? 0 : (font === null || font === void 0 || (_font$3 = font[0]) === null || _font$3 === void 0 ? void 0 : _font$3.descent) || 0;\n  return scale(run) * fontDescent;\n};\n\n/**\n * Get run lineGap\n *\n * @param run - Run\n * @returns LineGap\n */\nconst lineGap = run => {\n  var _run$attributes4, _font$4;\n  const font = (_run$attributes4 = run.attributes) === null || _run$attributes4 === void 0 ? void 0 : _run$attributes4.font;\n  const lineGap = typeof font === 'string' ? 0 : (font === null || font === void 0 || (_font$4 = font[0]) === null || _font$4 === void 0 ? void 0 : _font$4.lineGap) || 0;\n  return lineGap * scale(run);\n};\n\n/**\n * Get run height\n *\n * @param run - Run\n * @returns Height\n */\nconst height$1 = run => {\n  var _run$attributes5;\n  const lineHeight = (_run$attributes5 = run.attributes) === null || _run$attributes5 === void 0 ? void 0 : _run$attributes5.lineHeight;\n  return lineHeight || lineGap(run) + ascent$1(run) - descent(run);\n};\n\n/**\n * Returns attributed string height\n *\n * @param attributedString - Attributed string\n * @returns Height\n */\nconst height = attributedString => {\n  const reducer = (acc, run) => Math.max(acc, height$1(run));\n  return attributedString.runs.reduce(reducer, 0);\n};\n\n/**\n * Checks if two rects intersect each other\n *\n * @param a - Rect A\n * @param b - Rect B\n * @returns Whether rects intersect\n */\nconst intersects = (a, b) => {\n  const x = Math.max(a.x, b.x);\n  const num1 = Math.min(a.x + a.width, b.x + b.width);\n  const y = Math.max(a.y, b.y);\n  const num2 = Math.min(a.y + a.height, b.y + b.height);\n  return num1 >= x && num2 >= y;\n};\nconst getLineFragment = (lineRect, excludeRect) => {\n  if (!intersects(excludeRect, lineRect)) return [lineRect];\n  const eStart = excludeRect.x;\n  const eEnd = excludeRect.x + excludeRect.width;\n  const lStart = lineRect.x;\n  const lEnd = lineRect.x + lineRect.width;\n  const a = Object.assign({}, lineRect, {\n    width: eStart - lStart\n  });\n  const b = Object.assign({}, lineRect, {\n    x: eEnd,\n    width: lEnd - eEnd\n  });\n  return [a, b].filter(r => r.width > 0);\n};\nconst getLineFragments = (rect, excludeRects) => {\n  let fragments = [rect];\n  for (let i = 0; i < excludeRects.length; i += 1) {\n    const excludeRect = excludeRects[i];\n    fragments = fragments.reduce((acc, fragment) => {\n      const pieces = getLineFragment(fragment, excludeRect);\n      return acc.concat(pieces);\n    }, []);\n  }\n  return fragments;\n};\nconst generateLineRects = (container, height) => {\n  const {\n      excludeRects\n    } = container,\n    rect = _objectWithoutProperties(container, _excluded);\n  if (!excludeRects) return [rect];\n  const lineRects = [];\n  const maxY = Math.max(...excludeRects.map(r => r.y + r.height));\n  let currentRect = rect;\n  while (currentRect.y < maxY) {\n    const [lineRect, rest] = partition(currentRect, height);\n    const lineRectFragments = getLineFragments(lineRect, excludeRects);\n    currentRect = rest;\n    lineRects.push(...lineRectFragments);\n  }\n  return [...lineRects, currentRect];\n};\nconst ATTACHMENT_CODE$1 = '\\ufffc'; // 65532\n/**\n * Remove attachment attribute if no char present\n *\n * @param line - Line\n * @returns Line\n */\nconst purgeAttachments = line => {\n  const shouldPurge = !line.string.includes(ATTACHMENT_CODE$1);\n  if (!shouldPurge) return line;\n  const runs = line.runs.map(run => omit('attachment', run));\n  return Object.assign({}, line, {\n    runs\n  });\n};\n/**\n * Layout paragraphs inside rectangle\n *\n * @param rects - Rects\n * @param lines - Attributed strings\n * @param indent\n * @returns layout blocks\n */\nconst layoutLines = (rects, lines, indent) => {\n  let rect = rects.shift();\n  let currentY = rect.y;\n  return lines.map((line, i) => {\n    var _line$runs;\n    const lineIndent = i === 0 ? indent : 0;\n    const style = ((_line$runs = line.runs) === null || _line$runs === void 0 || (_line$runs = _line$runs[0]) === null || _line$runs === void 0 ? void 0 : _line$runs.attributes) || {};\n    const height$1 = Math.max(height(line), style.lineHeight);\n    if (currentY + height$1 > rect.y + rect.height && rects.length > 0) {\n      rect = rects.shift();\n      currentY = rect.y;\n    }\n    const newLine = {\n      string: line.string,\n      runs: line.runs,\n      box: {\n        x: rect.x + lineIndent,\n        y: currentY,\n        width: rect.width - lineIndent,\n        height: height$1\n      }\n    };\n    currentY += height$1;\n    return purgeAttachments(newLine);\n  });\n};\n/**\n * Performs line breaking and layout\n *\n * @param engines - Engines\n * @param options - Layout options\n */\nconst layoutParagraph = function (engines) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  /**\n   * @param container - Container\n   * @param paragraph - Attributed string\n   * @returns Layout block\n   */\n  return (container, paragraph) => {\n    var _paragraph$runs;\n    const height$1 = height(paragraph);\n    const indent = ((_paragraph$runs = paragraph.runs) === null || _paragraph$runs === void 0 || (_paragraph$runs = _paragraph$runs[0]) === null || _paragraph$runs === void 0 || (_paragraph$runs = _paragraph$runs.attributes) === null || _paragraph$runs === void 0 ? void 0 : _paragraph$runs.indent) || 0;\n    const rects = generateLineRects(container, height$1);\n    const availableWidths = rects.map(r => r.width);\n    availableWidths.unshift(availableWidths[0] - indent);\n    const lines = engines.linebreaker(options)(paragraph, availableWidths);\n    return layoutLines(rects, lines, indent);\n  };\n};\n\n/**\n * Slice block at given height\n *\n * @param height - Height\n * @param paragraph - Paragraph\n * @returns Sliced paragraph\n */\nconst sliceAtHeight = (height, paragraph) => {\n  const newBlock = [];\n  let counter = 0;\n  for (let i = 0; i < paragraph.length; i += 1) {\n    const line = paragraph[i];\n    counter += line.box.height;\n    if (counter < height) {\n      newBlock.push(line);\n    } else {\n      break;\n    }\n  }\n  return newBlock;\n};\n\n/**\n * Layout paragraphs inside container until it does not\n * fit anymore, performing line wrapping in the process.\n *\n * @param  engines - Engines\n * @param  options - Layout options\n * @param container - Container\n */\nconst typesetter = (engines, options, container) => {\n  /**\n   * @param attributedStrings - Attributed strings (paragraphs)\n   * @returns Paragraph blocks\n   */\n  return attributedStrings => {\n    const result = [];\n    const paragraphs = [...attributedStrings];\n    const layout = layoutParagraph(engines, options);\n    const maxLines = isNil(container.maxLines) ? Infinity : container.maxLines;\n    const truncateEllipsis = container.truncateMode === 'ellipsis';\n    let linesCount = maxLines;\n    let paragraphRect = copy(container);\n    let nextParagraph = paragraphs.shift();\n    while (linesCount > 0 && nextParagraph) {\n      const paragraph = layout(paragraphRect, nextParagraph);\n      const slicedBlock = paragraph.slice(0, linesCount);\n      const linesHeight = height$2(slicedBlock);\n      const shouldTruncate = truncateEllipsis && paragraph.length !== slicedBlock.length;\n      linesCount -= slicedBlock.length;\n      if (paragraphRect.height >= linesHeight) {\n        result.push(shouldTruncate ? truncate(slicedBlock) : slicedBlock);\n        paragraphRect = crop(linesHeight, paragraphRect);\n        nextParagraph = paragraphs.shift();\n      } else {\n        result.push(truncate(sliceAtHeight(paragraphRect.height, slicedBlock)));\n        break;\n      }\n    }\n    return result;\n  };\n};\n\n/**\n * Get attributed string start value\n *\n * @param attributedString - Attributed string\n * @returns Start\n */\nconst start = attributedString => {\n  const {\n    runs\n  } = attributedString;\n  return runs.length === 0 ? 0 : runs[0].start;\n};\n\n/**\n * Get attributed string end value\n *\n * @param attributedString - Attributed string\n * @returns End\n */\nconst end = attributedString => {\n  const {\n    runs\n  } = attributedString;\n  return runs.length === 0 ? 0 : last(runs).end;\n};\n\n/**\n * Get attributed string length\n *\n * @param attributedString - Attributed string\n * @returns End\n */\nconst length$1 = attributedString => {\n  return end(attributedString) - start(attributedString);\n};\nconst bidi$2 = bidiFactory();\nconst getBidiLevels$1 = runs => {\n  return runs.reduce((acc, run) => {\n    const length = run.end - run.start;\n    const levels = repeat(run.attributes.bidiLevel, length);\n    return acc.concat(levels);\n  }, []);\n};\nconst getReorderedIndices = (string, segments) => {\n  // Fill an array with indices\n  const indices = [];\n  for (let i = 0; i < string.length; i += 1) {\n    indices[i] = i;\n  }\n  // Reverse each segment in order\n  segments.forEach(_ref => {\n    let [start, end] = _ref;\n    const slice = indices.slice(start, end + 1);\n    for (let i = slice.length - 1; i >= 0; i -= 1) {\n      indices[end - i] = slice[i];\n    }\n  });\n  return indices;\n};\nconst getItemAtIndex = (runs, objectName, index) => {\n  for (let i = 0; i < runs.length; i += 1) {\n    const run = runs[i];\n    const updatedIndex = run.glyphIndices[index - run.start];\n    if (index >= run.start && index < run.end) {\n      return run[objectName][updatedIndex];\n    }\n  }\n  throw new Error(\"index \".concat(index, \" out of range\"));\n};\nconst reorderLine = line => {\n  var _line$runs$;\n  const levels = getBidiLevels$1(line.runs);\n  const direction = (_line$runs$ = line.runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes.direction;\n  const level = direction === 'rtl' ? 1 : 0;\n  const end = length$1(line) - 1;\n  const paragraphs = [{\n    start: 0,\n    end,\n    level\n  }];\n  const embeddingLevels = {\n    paragraphs,\n    levels\n  };\n  const segments = bidi$2.getReorderSegments(line.string, embeddingLevels);\n  // No need for bidi reordering\n  if (segments.length === 0) return line;\n  const indices = getReorderedIndices(line.string, segments);\n  const updatedString = bidi$2.getReorderedString(line.string, embeddingLevels);\n  const updatedRuns = line.runs.map(run => {\n    const selectedIndices = indices.slice(run.start, run.end);\n    const updatedGlyphs = [];\n    const updatedPositions = [];\n    const addedGlyphs = new Set();\n    for (let i = 0; i < selectedIndices.length; i += 1) {\n      const index = selectedIndices[i];\n      const glyph = getItemAtIndex(line.runs, 'glyphs', index);\n      if (addedGlyphs.has(glyph.id)) continue;\n      updatedGlyphs.push(glyph);\n      updatedPositions.push(getItemAtIndex(line.runs, 'positions', index));\n      if (glyph.isLigature) {\n        addedGlyphs.add(glyph.id);\n      }\n    }\n    return _objectSpread(_objectSpread({}, run), {}, {\n      glyphs: updatedGlyphs,\n      positions: updatedPositions\n    });\n  });\n  return {\n    box: line.box,\n    runs: updatedRuns,\n    string: updatedString\n  };\n};\nconst reorderParagraph = paragraph => paragraph.map(reorderLine);\n/**\n * Perform bidi reordering\n *\n * @returns Reordered paragraphs\n */\nconst bidiReordering = () => {\n  /**\n   * @param paragraphs - Paragraphs\n   * @returns Reordered paragraphs\n   */\n  return paragraphs => paragraphs.map(reorderParagraph);\n};\nconst DUMMY_CODEPOINT = 123;\n/**\n * Resolve string indices based on glyphs code points\n *\n * @param glyphs\n * @returns Glyph indices\n */\nconst resolve = function () {\n  let glyphs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return glyphs.reduce((acc, glyph) => {\n    const codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [DUMMY_CODEPOINT];\n    if (acc.length === 0) return codePoints.map(() => 0);\n    const last = acc[acc.length - 1];\n    const next = codePoints.map(() => last + 1);\n    return [...acc, ...next];\n  }, []);\n};\nconst getCharacterSpacing = run => {\n  var _run$attributes6;\n  return ((_run$attributes6 = run.attributes) === null || _run$attributes6 === void 0 ? void 0 : _run$attributes6.characterSpacing) || 0;\n};\n/**\n * Scale run positions\n *\n * @param  run\n * @param  positions\n * @returns Scaled positions\n */\nconst scalePositions = (run, positions) => {\n  const runScale = scale(run);\n  const characterSpacing = getCharacterSpacing(run);\n  return positions.map((position, i) => {\n    const isLast = i === positions.length;\n    const xSpacing = isLast ? 0 : characterSpacing;\n    return Object.assign({}, position, {\n      xAdvance: position.xAdvance * runScale + xSpacing,\n      yAdvance: position.yAdvance * runScale,\n      xOffset: position.xOffset * runScale,\n      yOffset: position.yOffset * runScale\n    });\n  });\n};\n/**\n * Create glyph run\n *\n * @param string string\n */\nconst layoutRun = string => {\n  /**\n   * @param run - Run\n   * @returns Glyph run\n   */\n  return run => {\n    const {\n      start,\n      end,\n      attributes = {}\n    } = run;\n    const {\n      font\n    } = attributes;\n    if (!font) return _objectSpread(_objectSpread({}, run), {}, {\n      glyphs: [],\n      glyphIndices: [],\n      positions: []\n    });\n    const runString = string.slice(start, end);\n    if (typeof font === 'string') throw new Error('Invalid font');\n    // passing LTR To force fontkit to not reverse the string\n    const glyphRun = font[0].layout(runString, undefined, undefined, undefined, 'ltr');\n    const positions = scalePositions(run, glyphRun.positions);\n    const glyphIndices = resolve(glyphRun.glyphs);\n    const result = _objectSpread(_objectSpread({}, run), {}, {\n      positions,\n      glyphIndices,\n      glyphs: glyphRun.glyphs\n    });\n    return result;\n  };\n};\n/**\n * Generate glyphs for single attributed string\n */\nconst generateGlyphs = () => {\n  /**\n   * @param attributedString - Attributed string\n   * @returns Attributed string with glyphs\n   */\n  return attributedString => {\n    const runs = attributedString.runs.map(layoutRun(attributedString.string));\n    const res = Object.assign({}, attributedString, {\n      runs\n    });\n    return res;\n  };\n};\n\n/**\n * Resolves yOffset for run\n *\n * @param run - Run\n * @returns Run\n */\nconst resolveRunYOffset = run => {\n  var _run$attributes7, _run$attributes8;\n  if (!run.positions) return run;\n  const unitsPerEm = ((_run$attributes7 = run.attributes) === null || _run$attributes7 === void 0 || (_run$attributes7 = _run$attributes7.font) === null || _run$attributes7 === void 0 || (_run$attributes7 = _run$attributes7[0]) === null || _run$attributes7 === void 0 ? void 0 : _run$attributes7.unitsPerEm) || 0;\n  const yOffset = (((_run$attributes8 = run.attributes) === null || _run$attributes8 === void 0 ? void 0 : _run$attributes8.yOffset) || 0) * unitsPerEm;\n  const positions = run.positions.map(p => Object.assign({}, p, {\n    yOffset\n  }));\n  return Object.assign({}, run, {\n    positions\n  });\n};\n/**\n * Resolves yOffset for multiple paragraphs\n */\nconst resolveYOffset = () => {\n  /**\n   * @param attributedString - Attributed string\n   * @returns Attributed string\n   */\n  return attributedString => {\n    const runs = attributedString.runs.map(resolveRunYOffset);\n    const res = Object.assign({}, attributedString, {\n      runs\n    });\n    return res;\n  };\n};\n\n/**\n * Sort runs in ascending order\n *\n * @param runs\n * @returns Sorted runs\n */\nconst sort = runs => {\n  return runs.sort((a, b) => a.start - b.start || a.end - b.end);\n};\n\n/**\n * Is run empty (start === end)\n *\n * @param run - Run\n * @returns Is run empty\n */\nconst isEmpty = run => {\n  return run.start === run.end;\n};\n\n/**\n * Sort points in ascending order\n * @param a - First point\n * @param b - Second point\n * @returns Sort order\n */\nconst sortPoints = (a, b) => {\n  return a[1] - b[1] || a[3] - b[3];\n};\n/**\n * @param runs\n * @returns Points\n */\nconst generatePoints = runs => {\n  const result = runs.reduce((acc, run, i) => {\n    return acc.concat([['start', run.start, run.attributes, i], ['end', run.end, run.attributes, i]]);\n  }, []);\n  return result.sort(sortPoints);\n};\n/**\n * @param runs\n * @returns Merged runs\n */\nconst mergeRuns = runs => {\n  return runs.reduce((acc, run) => {\n    const attributes = Object.assign({}, acc.attributes, run.attributes);\n    return Object.assign({}, run, {\n      attributes\n    });\n  }, {});\n};\n/**\n * @param runs\n * @returns Grouped runs\n */\nconst groupEmptyRuns = runs => {\n  const groups = runs.reduce((acc, run) => {\n    if (!acc[run.start]) acc[run.start] = [];\n    acc[run.start].push(run);\n    return acc;\n  }, []);\n  return Object.values(groups);\n};\n/**\n * @param runs\n * @returns Flattened runs\n */\nconst flattenEmptyRuns = runs => {\n  return groupEmptyRuns(runs).map(mergeRuns);\n};\n/**\n * @param runs\n * @returns Flattened runs\n */\nconst flattenRegularRuns = runs => {\n  const res = [];\n  const points = generatePoints(runs);\n  let start = -1;\n  let attrs = {};\n  const stack = [];\n  for (let i = 0; i < points.length; i += 1) {\n    const [type, offset, attributes] = points[i];\n    if (start !== -1 && start < offset) {\n      res.push({\n        start,\n        end: offset,\n        attributes: attrs,\n        glyphIndices: [],\n        glyphs: [],\n        positions: []\n      });\n    }\n    if (type === 'start') {\n      stack.push(attributes);\n      attrs = Object.assign({}, attrs, attributes);\n    } else {\n      attrs = {};\n      for (let j = 0; j < stack.length; j += 1) {\n        if (stack[j] === attributes) {\n          stack.splice(j--, 1);\n        } else {\n          attrs = Object.assign({}, attrs, stack[j]);\n        }\n      }\n    }\n    start = offset;\n  }\n  return res;\n};\n/**\n * Flatten many runs\n *\n * @param runs\n * @returns Flattened runs\n */\nconst flatten = function () {\n  let runs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  const emptyRuns = flattenEmptyRuns(runs.filter(run => isEmpty(run)));\n  const regularRuns = flattenRegularRuns(runs.filter(run => !isEmpty(run)));\n  return sort(emptyRuns.concat(regularRuns));\n};\n\n/**\n * Returns empty attributed string\n *\n * @returns Empty attributed string\n */\nconst empty = () => ({\n  string: '',\n  runs: []\n});\n\n/**\n *\n * @param attributedString\n * @returns Attributed string without font\n */\nconst omitFont = attributedString => {\n  const runs = attributedString.runs.map(run => omit('font', run));\n  return Object.assign({}, attributedString, {\n    runs\n  });\n};\n/**\n * Performs font substitution and script itemization on attributed string\n *\n * @param engines - engines\n */\nconst preprocessRuns = engines => {\n  /**\n   * @param attributedString - Attributed string\n   * @returns Processed attributed string\n   */\n  return attributedString => {\n    if (isNil(attributedString)) return empty();\n    const {\n      string\n    } = attributedString;\n    const {\n      fontSubstitution,\n      scriptItemizer,\n      bidi\n    } = engines;\n    const {\n      runs: omittedFontRuns\n    } = omitFont(attributedString);\n    const {\n      runs: itemizationRuns\n    } = scriptItemizer()(attributedString);\n    const {\n      runs: substitutedRuns\n    } = fontSubstitution()(attributedString);\n    const {\n      runs: bidiRuns\n    } = bidi()(attributedString);\n    const runs = bidiRuns.concat(substitutedRuns).concat(itemizationRuns).concat(omittedFontRuns);\n    return {\n      string,\n      runs: flatten(runs)\n    };\n  };\n};\n\n/**\n * Breaks attributed string into paragraphs\n */\nconst splitParagraphs = () => {\n  /**\n   * @param attributedString - Attributed string\n   * @returns Paragraphs attributed strings\n   */\n  return attributedString => {\n    const paragraphs = [];\n    let start = 0;\n    let breakPoint = attributedString.string.indexOf('\\n') + 1;\n    while (breakPoint > 0) {\n      paragraphs.push(slice(start, breakPoint, attributedString));\n      start = breakPoint;\n      breakPoint = attributedString.string.indexOf('\\n', breakPoint) + 1;\n    }\n    if (start === 0) {\n      paragraphs.push(attributedString);\n    } else if (start < attributedString.string.length) {\n      paragraphs.push(slice(start, length$1(attributedString), attributedString));\n    }\n    return paragraphs;\n  };\n};\n\n/**\n * Return positions advance width\n *\n * @param positions - Positions\n * @returns {number} advance width\n */\nconst advanceWidth$2 = positions => {\n  return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);\n};\n\n/**\n * Return run advance width\n *\n * @param run - Run\n * @returns Advance width\n */\nconst advanceWidth$1 = run => {\n  return advanceWidth$2(run.positions || []);\n};\n\n/**\n * Returns attributed string advancewidth\n *\n * @param attributedString - Attributed string\n * @returns Advance width\n */\nconst advanceWidth = attributedString => {\n  const reducer = (acc, run) => acc + advanceWidth$1(run);\n  return attributedString.runs.reduce(reducer, 0);\n};\nconst WHITE_SPACES_CODE = 32;\n/**\n * Check if glyph is white space\n *\n * @param glyph - Glyph\n * @returns Whether glyph is white space\n * */\nconst isWhiteSpace = glyph => {\n  const codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];\n  return codePoints.includes(WHITE_SPACES_CODE);\n};\n\n/**\n * Get white space leading positions\n *\n * @param run - Run\n * @returns White space leading positions\n */\nconst leadingPositions = run => {\n  const glyphs = run.glyphs || [];\n  const positions = run.positions || [];\n  const leadingWhitespaces = glyphs.findIndex(g => !isWhiteSpace(g));\n  return positions.slice(0, leadingWhitespaces);\n};\n/**\n * Get run leading white space offset\n *\n * @param run - Run\n * @returns Leading white space offset\n */\nconst leadingOffset$1 = run => {\n  const positions = leadingPositions(run);\n  return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);\n};\n\n/**\n * Get attributed string leading white space offset\n *\n * @param attributedString - Attributed string\n * @returns Leading white space offset\n */\nconst leadingOffset = attributedString => {\n  const runs = attributedString.runs || [];\n  return leadingOffset$1(runs[0]);\n};\n\n/**\n * Get white space trailing positions\n *\n * @param run run\n * @returns White space trailing positions\n */\nconst trailingPositions = run => {\n  const glyphs = reverse(run.glyphs || []);\n  const positions = reverse(run.positions || []);\n  const leadingWhitespaces = glyphs.findIndex(g => !isWhiteSpace(g));\n  return positions.slice(0, leadingWhitespaces);\n};\n/**\n * Get run trailing white space offset\n *\n * @param run - Run\n * @returns Trailing white space offset\n */\nconst trailingOffset$1 = run => {\n  const positions = trailingPositions(run);\n  return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);\n};\n\n/**\n * Get attributed string trailing white space offset\n *\n * @param attributedString - Attributed string\n * @returns Trailing white space offset\n */\nconst trailingOffset = attributedString => {\n  const runs = attributedString.runs || [];\n  return trailingOffset$1(last(runs));\n};\n\n/**\n * Drop last char of run\n *\n * @param run - Run\n * @returns Run without last char\n */\nconst dropLast$1 = run => {\n  return slice$1(0, run.end - run.start - 1, run);\n};\n\n/**\n * Drop last glyph\n *\n * @param attributedString - Attributed string\n * @returns Attributed string with new glyph\n */\nconst dropLast = attributedString => {\n  const string = dropLast$2(attributedString.string);\n  const runs = adjust(-1, dropLast$1, attributedString.runs);\n  return Object.assign({}, attributedString, {\n    string,\n    runs\n  });\n};\nconst ALIGNMENT_FACTORS = {\n  center: 0.5,\n  right: 1\n};\n/**\n * Remove new line char at the end of line if present\n *\n * @param line\n * @returns Line\n */\nconst removeNewLine = line => {\n  return last(line.string) === '\\n' ? dropLast(line) : line;\n};\nconst getOverflowLeft = line => {\n  return leadingOffset(line) + (line.overflowLeft || 0);\n};\nconst getOverflowRight = line => {\n  return trailingOffset(line) + (line.overflowRight || 0);\n};\n/**\n * Ignore whitespace at the start and end of a line for alignment\n *\n * @param line\n * @returns Line\n */\nconst adjustOverflow = line => {\n  const overflowLeft = getOverflowLeft(line);\n  const overflowRight = getOverflowRight(line);\n  const x = line.box.x - overflowLeft;\n  const width = line.box.width + overflowLeft + overflowRight;\n  const box = Object.assign({}, line.box, {\n    x,\n    width\n  });\n  return Object.assign({}, line, {\n    box,\n    overflowLeft,\n    overflowRight\n  });\n};\n/**\n * Performs line justification by calling appropiate engine\n *\n * @param engines - Engines\n * @param options - Layout options\n * @param align - Text align\n */\nconst justifyLine$1 = (engines, options, align) => {\n  /**\n   * @param line - Line\n   * @returns Line\n   */\n  return line => {\n    const lineWidth = advanceWidth(line);\n    const alignFactor = ALIGNMENT_FACTORS[align] || 0;\n    const remainingWidth = Math.max(0, line.box.width - lineWidth);\n    const shouldJustify = align === 'justify' || lineWidth > line.box.width;\n    const x = line.box.x + remainingWidth * alignFactor;\n    const box = Object.assign({}, line.box, {\n      x\n    });\n    const newLine = Object.assign({}, line, {\n      box\n    });\n    return shouldJustify ? engines.justification(options)(newLine) : newLine;\n  };\n};\nconst finalizeLine = line => {\n  let lineAscent = 0;\n  let lineDescent = 0;\n  let lineHeight = 0;\n  let lineXAdvance = 0;\n  const runs = line.runs.map(run => {\n    const height = height$1(run);\n    const ascent = ascent$1(run);\n    const descent$1 = descent(run);\n    const xAdvance = advanceWidth$1(run);\n    lineHeight = Math.max(lineHeight, height);\n    lineAscent = Math.max(lineAscent, ascent);\n    lineDescent = Math.max(lineDescent, descent$1);\n    lineXAdvance += xAdvance;\n    return Object.assign({}, run, {\n      height,\n      ascent,\n      descent: descent$1,\n      xAdvance\n    });\n  });\n  return Object.assign({}, line, {\n    runs,\n    height: lineHeight,\n    ascent: lineAscent,\n    descent: lineDescent,\n    xAdvance: lineXAdvance\n  });\n};\n/**\n * Finalize line by performing line justification\n * and text decoration (using appropiate engines)\n *\n * @param engines - Engines\n * @param options - Layout options\n */\nconst finalizeBlock = (engines, options) => {\n  /**\n   * @param line - Line\n   * @param i - Line index\n   * @param lines - Total lines\n   * @returns Line\n   */\n  return (line, index, lines) => {\n    var _line$runs2;\n    const isLastFragment = index === lines.length - 1;\n    const style = ((_line$runs2 = line.runs) === null || _line$runs2 === void 0 || (_line$runs2 = _line$runs2[0]) === null || _line$runs2 === void 0 ? void 0 : _line$runs2.attributes) || {};\n    const align = isLastFragment ? style.alignLastLine : style.align;\n    return compose(finalizeLine, engines.textDecoration(), justifyLine$1(engines, options, align), adjustOverflow, removeNewLine)(line);\n  };\n};\n/**\n * Finalize line block by performing line justification\n * and text decoration (using appropiate engines)\n *\n * @param engines - Engines\n * @param options - Layout options\n */\nconst finalizeFragments = (engines, options) => {\n  /**\n   * @param paragraphs - Paragraphs\n   * @returns Paragraphs\n   */\n  return paragraphs => {\n    const blockFinalizer = finalizeBlock(engines, options);\n    return paragraphs.map(paragraph => paragraph.map(blockFinalizer));\n  };\n};\nconst ATTACHMENT_CODE = 0xfffc; // 65532\nconst isReplaceGlyph = glyph => glyph.codePoints.includes(ATTACHMENT_CODE);\n/**\n * Resolve attachments of run\n *\n * @param run\n * @returns Run\n */\nconst resolveRunAttachments = run => {\n  var _run$attributes9;\n  if (!run.positions) return run;\n  const glyphs = run.glyphs || [];\n  const attachment = (_run$attributes9 = run.attributes) === null || _run$attributes9 === void 0 ? void 0 : _run$attributes9.attachment;\n  if (!attachment) return run;\n  const positions = run.positions.map((position, i) => {\n    const glyph = glyphs[i];\n    if (attachment.width && isReplaceGlyph(glyph)) {\n      return Object.assign({}, position, {\n        xAdvance: attachment.width\n      });\n    }\n    return Object.assign({}, position);\n  });\n  return Object.assign({}, run, {\n    positions\n  });\n};\n/**\n * Resolve attachments for multiple paragraphs\n */\nconst resolveAttachments = () => {\n  /**\n   * @param attributedString - Attributed string\n   * @returns Attributed string\n   */\n  return attributedString => {\n    const runs = attributedString.runs.map(resolveRunAttachments);\n    const res = Object.assign({}, attributedString, {\n      runs\n    });\n    return res;\n  };\n};\n\n/**\n * @param attributes - Attributes\n * @returns Attributes with defaults\n */\nconst applyAttributes = a => {\n  return {\n    align: a.align || (a.direction === 'rtl' ? 'right' : 'left'),\n    alignLastLine: a.alignLastLine || (a.align === 'justify' ? 'left' : a.align || 'left'),\n    attachment: a.attachment || null,\n    backgroundColor: a.backgroundColor || null,\n    bullet: a.bullet || null,\n    characterSpacing: a.characterSpacing || 0,\n    color: a.color || 'black',\n    direction: a.direction || 'ltr',\n    features: a.features || [],\n    fill: a.fill !== false,\n    font: a.font || [],\n    fontSize: a.fontSize || 12,\n    hangingPunctuation: a.hangingPunctuation || false,\n    hyphenationFactor: a.hyphenationFactor || 0,\n    indent: a.indent || 0,\n    justificationFactor: a.justificationFactor || 1,\n    lineHeight: a.lineHeight || null,\n    lineSpacing: a.lineSpacing || 0,\n    link: a.link || null,\n    marginLeft: a.marginLeft || a.margin || 0,\n    marginRight: a.marginRight || a.margin || 0,\n    opacity: a.opacity,\n    paddingTop: a.paddingTop || a.padding || 0,\n    paragraphSpacing: a.paragraphSpacing || 0,\n    script: a.script || null,\n    shrinkFactor: a.shrinkFactor || 0,\n    strike: a.strike || false,\n    strikeColor: a.strikeColor || a.color || 'black',\n    strikeStyle: a.strikeStyle || 'solid',\n    stroke: a.stroke || false,\n    underline: a.underline || false,\n    underlineColor: a.underlineColor || a.color || 'black',\n    underlineStyle: a.underlineStyle || 'solid',\n    verticalAlign: a.verticalAlign || null,\n    wordSpacing: a.wordSpacing || 0,\n    yOffset: a.yOffset || 0\n  };\n};\n/**\n * Apply default style to run\n *\n * @param run - Run\n * @returns Run with default styles\n */\nconst applyRunStyles = run => {\n  const attributes = applyAttributes(run.attributes);\n  return Object.assign({}, run, {\n    attributes\n  });\n};\n/**\n * Apply default attributes for an attributed string\n */\nconst applyDefaultStyles = () => {\n  return attributedString => {\n    const string = attributedString.string || '';\n    const runs = (attributedString.runs || []).map(applyRunStyles);\n    return {\n      string,\n      runs\n    };\n  };\n};\n\n/**\n * Apply scaling and yOffset for verticalAlign 'sub' and 'super'.\n */\nconst verticalAlignment = () => {\n  /**\n   * @param attributedString - Attributed string\n   * @returns Attributed string\n   */\n  return attributedString => {\n    attributedString.runs.forEach(run => {\n      const {\n        attributes\n      } = run;\n      const {\n        verticalAlign\n      } = attributes;\n      if (verticalAlign === 'sub') {\n        attributes.yOffset = -0.2;\n      } else if (verticalAlign === 'super') {\n        attributes.yOffset = 0.4;\n      }\n    });\n    return attributedString;\n  };\n};\nconst bidi$1 = bidiFactory();\n/**\n * @param runs\n * @returns Bidi levels\n */\nconst getBidiLevels = runs => {\n  return runs.reduce((acc, run) => {\n    const length = run.end - run.start;\n    const levels = repeat(run.attributes.bidiLevel, length);\n    return acc.concat(levels);\n  }, []);\n};\n/**\n * Perform bidi mirroring\n */\nconst mirrorString = () => {\n  /**\n   * @param attributedString - Attributed string\n   * @returns Attributed string\n   */\n  return attributedString => {\n    const levels = getBidiLevels(attributedString.runs);\n    let updatedString = '';\n    attributedString.string.split('').forEach((char, index) => {\n      const isRTL = levels[index] % 2 === 1;\n      const mirroredChar = isRTL ? bidi$1.getMirroredCharacter(attributedString.string.charAt(index)) : null;\n      updatedString += mirroredChar || char;\n    });\n    const result = _objectSpread(_objectSpread({}, attributedString), {}, {\n      string: updatedString\n    });\n    return result;\n  };\n};\n\n/**\n * A LayoutEngine is the main object that performs text layout.\n * It accepts an AttributedString and a Container object\n * to layout text into, and uses several helper objects to perform\n * various layout tasks. These objects can be overridden to customize\n * layout behavior.\n */\nconst layoutEngine = engines => {\n  return function (attributedString, container) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const processParagraph = compose(resolveYOffset(), resolveAttachments(), verticalAlignment(), wrapWords(engines, options), generateGlyphs(), mirrorString(), preprocessRuns(engines));\n    const processParagraphs = paragraphs => paragraphs.map(processParagraph);\n    return compose(finalizeFragments(engines, options), bidiReordering(), typesetter(engines, options, container), processParagraphs, splitParagraphs(), applyDefaultStyles())(attributedString);\n  };\n};\nconst bidi = bidiFactory();\nconst bidiEngine = () => {\n  /**\n   * @param attributedString - Attributed string\n   * @returns Attributed string\n   */\n  return attributedString => {\n    var _attributedString$run;\n    const {\n      string\n    } = attributedString;\n    const direction = (_attributedString$run = attributedString.runs[0]) === null || _attributedString$run === void 0 ? void 0 : _attributedString$run.attributes.direction;\n    const {\n      levels\n    } = bidi.getEmbeddingLevels(string, direction);\n    let lastLevel = null;\n    let lastIndex = 0;\n    let index = 0;\n    const runs = [];\n    for (let i = 0; i < levels.length; i += 1) {\n      const level = levels[i];\n      if (level !== lastLevel) {\n        if (lastLevel !== null) {\n          runs.push({\n            start: lastIndex,\n            end: index,\n            attributes: {\n              bidiLevel: lastLevel\n            }\n          });\n        }\n        lastIndex = index;\n        lastLevel = level;\n      }\n      index += 1;\n    }\n    if (lastIndex < string.length) {\n      runs.push({\n        start: lastIndex,\n        end: string.length,\n        attributes: {\n          bidiLevel: lastLevel\n        }\n      });\n    }\n    const result = {\n      string,\n      runs\n    };\n    return result;\n  };\n};\nconst INFINITY = 10000;\nconst getNextBreakpoint = (subnodes, widths, lineNumber) => {\n  let position = null;\n  let minimumBadness = Infinity;\n  const sum = {\n    width: 0,\n    stretch: 0,\n    shrink: 0\n  };\n  const lineLength = widths[Math.min(lineNumber, widths.length - 1)];\n  const calculateRatio = node => {\n    const stretch = 'stretch' in node ? node.stretch : null;\n    if (sum.width < lineLength) {\n      if (!stretch) return INFINITY;\n      return sum.stretch - stretch > 0 ? (lineLength - sum.width) / sum.stretch : INFINITY;\n    }\n    const shrink = 'shrink' in node ? node.shrink : null;\n    if (sum.width > lineLength) {\n      if (!shrink) return INFINITY;\n      return sum.shrink - shrink > 0 ? (lineLength - sum.width) / sum.shrink : INFINITY;\n    }\n    return 0;\n  };\n  for (let i = 0; i < subnodes.length; i += 1) {\n    const node = subnodes[i];\n    if (node.type === 'box') {\n      sum.width += node.width;\n    }\n    if (node.type === 'glue') {\n      sum.width += node.width;\n      sum.stretch += node.stretch;\n      sum.shrink += node.shrink;\n    }\n    if (sum.width - sum.shrink > lineLength) {\n      if (position === null) {\n        let j = i === 0 ? i + 1 : i;\n        while (j < subnodes.length && (subnodes[j].type === 'glue' || subnodes[j].type === 'penalty')) {\n          j++;\n        }\n        position = j - 1;\n      }\n      break;\n    }\n    if (node.type === 'penalty' || node.type === 'glue') {\n      const ratio = calculateRatio(node);\n      const penalty = node.type === 'penalty' ? node.penalty : 0;\n      const badness = 100 * Math.abs(ratio) ** 3 + penalty;\n      if (minimumBadness >= badness) {\n        position = i;\n        minimumBadness = badness;\n      }\n    }\n  }\n  return sum.width - sum.shrink > lineLength ? position : null;\n};\nconst applyBestFit = (nodes, widths) => {\n  let count = 0;\n  let lineNumber = 0;\n  let subnodes = nodes;\n  const breakpoints = [0];\n  while (subnodes.length > 0) {\n    const breakpoint = getNextBreakpoint(subnodes, widths, lineNumber);\n    if (breakpoint !== null) {\n      count += breakpoint;\n      breakpoints.push(count);\n      subnodes = subnodes.slice(breakpoint + 1, subnodes.length);\n      count++;\n      lineNumber++;\n    } else {\n      subnodes = [];\n    }\n  }\n  return breakpoints;\n};\n\n/* eslint-disable max-classes-per-file */\nclass LinkedListNode {\n  constructor(data) {\n    _defineProperty(this, \"data\", void 0);\n    _defineProperty(this, \"prev\", void 0);\n    _defineProperty(this, \"next\", void 0);\n    this.data = data;\n    this.prev = null;\n    this.next = null;\n  }\n}\nclass LinkedList {\n  constructor() {\n    _defineProperty(this, \"head\", void 0);\n    _defineProperty(this, \"tail\", void 0);\n    _defineProperty(this, \"listSize\", void 0);\n    _defineProperty(this, \"listLength\", void 0);\n    this.head = null;\n    this.tail = null;\n    this.listSize = 0;\n    this.listLength = 0;\n  }\n  isLinked(node) {\n    return !(node && node.prev === null && node.next === null && this.tail !== node && this.head !== node || this.isEmpty());\n  }\n  size() {\n    return this.listSize;\n  }\n  isEmpty() {\n    return this.listSize === 0;\n  }\n  first() {\n    return this.head;\n  }\n  last() {\n    return this.last;\n  }\n  forEach(callback) {\n    let node = this.head;\n    while (node !== null) {\n      callback(node);\n      node = node.next;\n    }\n  }\n  at(i) {\n    let node = this.head;\n    let index = 0;\n    if (i >= this.listLength || i < 0) {\n      return null;\n    }\n    while (node !== null) {\n      if (i === index) {\n        return node;\n      }\n      node = node.next;\n      index += 1;\n    }\n    return null;\n  }\n  insertAfter(node, newNode) {\n    if (!this.isLinked(node)) return this;\n    newNode.prev = node;\n    newNode.next = node.next;\n    if (node.next === null) {\n      this.tail = newNode;\n    } else {\n      node.next.prev = newNode;\n    }\n    node.next = newNode;\n    this.listSize += 1;\n    return this;\n  }\n  insertBefore(node, newNode) {\n    if (!this.isLinked(node)) return this;\n    newNode.prev = node.prev;\n    newNode.next = node;\n    if (node.prev === null) {\n      this.head = newNode;\n    } else {\n      node.prev.next = newNode;\n    }\n    node.prev = newNode;\n    this.listSize += 1;\n    return this;\n  }\n  push(node) {\n    if (this.head === null) {\n      this.unshift(node);\n    } else {\n      this.insertAfter(this.tail, node);\n    }\n    return this;\n  }\n  unshift(node) {\n    if (this.head === null) {\n      this.head = node;\n      this.tail = node;\n      node.prev = null;\n      node.next = null;\n      this.listSize += 1;\n    } else {\n      this.insertBefore(this.head, node);\n    }\n    return this;\n  }\n  remove(node) {\n    if (!this.isLinked(node)) return this;\n    if (node.prev === null) {\n      this.head = node.next;\n    } else {\n      node.prev.next = node.next;\n    }\n    if (node.next === null) {\n      this.tail = node.prev;\n    } else {\n      node.next.prev = node.prev;\n    }\n    this.listSize -= 1;\n    return this;\n  }\n}\n\n/**\n * Licensed under the new BSD License.\n * Copyright 2009-2010, Bram Stein\n * All rights reserved.\n */\n_defineProperty(LinkedList, \"Node\", LinkedListNode);\nfunction breakpoint(position, demerits, line, fitnessClass, totals, previous) {\n  return {\n    position,\n    demerits,\n    line,\n    fitnessClass,\n    totals: totals || {\n      width: 0,\n      stretch: 0,\n      shrink: 0\n    },\n    previous\n  };\n}\nfunction computeCost(nodes, lineLengths, sum, end, active, currentLine) {\n  let width = sum.width - active.totals.width;\n  let stretch = 0;\n  let shrink = 0;\n  // If the current line index is within the list of linelengths, use it, otherwise use\n  // the last line length of the list.\n  const lineLength = currentLine < lineLengths.length ? lineLengths[currentLine - 1] : lineLengths[lineLengths.length - 1];\n  if (nodes[end].type === 'penalty') {\n    width += nodes[end].width;\n  }\n  // Calculate the stretch ratio\n  if (width < lineLength) {\n    stretch = sum.stretch - active.totals.stretch;\n    if (stretch > 0) {\n      return (lineLength - width) / stretch;\n    }\n    return linebreak.infinity;\n  }\n  // Calculate the shrink ratio\n  if (width > lineLength) {\n    shrink = sum.shrink - active.totals.shrink;\n    if (shrink > 0) {\n      return (lineLength - width) / shrink;\n    }\n    return linebreak.infinity;\n  }\n  // perfect match\n  return 0;\n}\n// Add width, stretch and shrink values from the current\n// break point up to the next box or forced penalty.\nfunction computeSum(nodes, sum, breakPointIndex) {\n  const result = {\n    width: sum.width,\n    stretch: sum.stretch,\n    shrink: sum.shrink\n  };\n  for (let i = breakPointIndex; i < nodes.length; i += 1) {\n    const node = nodes[i];\n    if (node.type === 'glue') {\n      result.width += node.width;\n      result.stretch += node.stretch;\n      result.shrink += node.shrink;\n    } else if (node.type === 'box' || node.type === 'penalty' && node.penalty === -linebreak.infinity && i > breakPointIndex) {\n      break;\n    }\n  }\n  return result;\n}\nfunction findBestBreakpoints(activeNodes) {\n  const breakpoints = [];\n  if (activeNodes.size() === 0) return [];\n  let tmp = {\n    data: {\n      demerits: Infinity\n    }\n  };\n  // Find the best active node (the one with the least total demerits.)\n  activeNodes.forEach(node => {\n    if (node.data.demerits < tmp.data.demerits) {\n      tmp = node;\n    }\n  });\n  while (tmp !== null) {\n    breakpoints.push(tmp.data.position);\n    tmp = tmp.data.previous;\n  }\n  return breakpoints.reverse();\n}\n/**\n * @param nodes\n * @param availableWidths\n * @param tolerance\n * @preserve Knuth and Plass line breaking algorithm in JavaScript\n */\nconst linebreak = (nodes, availableWidths, tolerance) => {\n  // Demerits are used as a way to penalize bad line breaks\n  //  - line: applied to each line, depending on how much spaces need to stretch or shrink\n  //  - flagged: applied when consecutive lines end in hyphenation\n  //  - fitness: algorithm groups lines into fitness classes based on how loose or tight the spacing is.\n  //             if a paragraph has consecutive lines from different fitness classes,\n  //             a fitness demerit is applied to maintain visual consistency.\n  const options = {\n    demerits: {\n      line: 10,\n      flagged: 100,\n      fitness: 3000\n    },\n    tolerance: tolerance || 3\n  };\n  const activeNodes = new LinkedList();\n  const sum = {\n    width: 0,\n    stretch: 0,\n    shrink: 0\n  };\n  const lineLengths = availableWidths;\n  // Add an active node for the start of the paragraph.\n  activeNodes.push(new LinkedList.Node(breakpoint(0, 0, 0, 0, undefined, null)));\n  // The main loop of the algorithm\n  function mainLoop(node, index, nodes) {\n    let active = activeNodes.first();\n    // The inner loop iterates through all the active nodes with line < currentLine and then\n    // breaks out to insert the new active node candidates before looking at the next active\n    // nodes for the next lines. The result of this is that the active node list is always\n    // sorted by line number.\n    while (active !== null) {\n      let currentLine = 0;\n      // Candidates fo each fitness class\n      const candidates = [{\n        active: undefined,\n        demerits: Infinity\n      }, {\n        active: undefined,\n        demerits: Infinity\n      }, {\n        active: undefined,\n        demerits: Infinity\n      }, {\n        active: undefined,\n        demerits: Infinity\n      }];\n      // Iterate through the linked list of active nodes to find new potential active nodes and deactivate current active nodes.\n      while (active !== null) {\n        currentLine = active.data.line + 1;\n        const ratio = computeCost(nodes, lineLengths, sum, index, active.data, currentLine);\n        // Deactive nodes when the distance between the current active node and the\n        // current node becomes too large (i.e. it exceeds the stretch limit and the stretch\n        // ratio becomes negative) or when the current node is a forced break (i.e. the end\n        // of the paragraph when we want to remove all active nodes, but possibly have a final\n        // candidate active node---if the paragraph can be set using the given tolerance value.)\n        if (ratio < -1 || node.type === 'penalty' && node.penalty === -linebreak.infinity) {\n          activeNodes.remove(active);\n        }\n        // If the ratio is within the valid range of -1 <= ratio <= tolerance calculate the\n        // total demerits and record a candidate active node.\n        if (ratio >= -1 && ratio <= options.tolerance) {\n          const badness = 100 * Math.pow(Math.abs(ratio), 3);\n          let demerits = 0;\n          // Positive penalty\n          if (node.type === 'penalty' && node.penalty >= 0) {\n            demerits = Math.pow(options.demerits.line + badness, 2) + Math.pow(node.penalty, 2);\n            // Negative penalty but not a forced break\n          } else if (node.type === 'penalty' && node.penalty !== -linebreak.infinity) {\n            demerits = Math.pow(options.demerits.line + badness, 2) - Math.pow(node.penalty, 2);\n            // All other cases\n          } else {\n            demerits = Math.pow(options.demerits.line + badness, 2);\n          }\n          if (node.type === 'penalty' && nodes[active.data.position].type === 'penalty') {\n            demerits += options.demerits.flagged * node.flagged *\n            // @ts-expect-error node is penalty here\n            nodes[active.data.position].flagged;\n          }\n          // Calculate the fitness class for this candidate active node.\n          let currentClass;\n          if (ratio < -0.5) {\n            currentClass = 0;\n          } else if (ratio <= 0.5) {\n            currentClass = 1;\n          } else if (ratio <= 1) {\n            currentClass = 2;\n          } else {\n            currentClass = 3;\n          }\n          // Add a fitness penalty to the demerits if the fitness classes of two adjacent lines differ too much.\n          if (Math.abs(currentClass - active.data.fitnessClass) > 1) {\n            demerits += options.demerits.fitness;\n          }\n          // Add the total demerits of the active node to get the total demerits of this candidate node.\n          demerits += active.data.demerits;\n          // Only store the best candidate for each fitness class\n          if (demerits < candidates[currentClass].demerits) {\n            candidates[currentClass] = {\n              active,\n              demerits\n            };\n          }\n        }\n        active = active.next;\n        // Stop iterating through active nodes to insert new candidate active nodes in the active list\n        // before moving on to the active nodes for the next line.\n        // TODO: The Knuth and Plass paper suggests a conditional for currentLine < j0. This means paragraphs\n        // with identical line lengths will not be sorted by line number. Find out if that is a desirable outcome.\n        // For now I left this out, as it only adds minimal overhead to the algorithm and keeping the active node\n        // list sorted has a higher priority.\n        if (active !== null && active.data.line >= currentLine) {\n          break;\n        }\n      }\n      const tmpSum = computeSum(nodes, sum, index);\n      for (let fitnessClass = 0; fitnessClass < candidates.length; fitnessClass += 1) {\n        const candidate = candidates[fitnessClass];\n        if (candidate.demerits === Infinity) continue;\n        const newNode = new LinkedList.Node(breakpoint(index, candidate.demerits, candidate.active.data.line + 1, fitnessClass, tmpSum, candidate.active));\n        if (active !== null) {\n          activeNodes.insertBefore(active, newNode);\n        } else {\n          activeNodes.push(newNode);\n        }\n      }\n    }\n  }\n  nodes.forEach((node, index, nodes) => {\n    if (node.type === 'box') {\n      sum.width += node.width;\n      return;\n    }\n    if (node.type === 'glue') {\n      const precedesBox = index > 0 && nodes[index - 1].type === 'box';\n      if (precedesBox) mainLoop(node, index, nodes);\n      sum.width += node.width;\n      sum.stretch += node.stretch;\n      sum.shrink += node.shrink;\n      return;\n    }\n    if (node.type === 'penalty' && node.penalty !== linebreak.infinity) {\n      mainLoop(node, index, nodes);\n    }\n  });\n  return findBestBreakpoints(activeNodes);\n};\nlinebreak.infinity = 10000;\nlinebreak.glue = (width, start, end, stretch, shrink) => ({\n  type: 'glue',\n  start,\n  end,\n  width,\n  stretch,\n  shrink\n});\nlinebreak.box = function (width, start, end) {\n  let hyphenated = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  return {\n    type: 'box',\n    width,\n    start,\n    end,\n    hyphenated\n  };\n};\nlinebreak.penalty = (width, penalty, flagged) => ({\n  type: 'penalty',\n  width,\n  penalty,\n  flagged\n});\n\n/**\n * Add scalar to run\n *\n * @param index - Scalar\n * @param run - Run\n * @returns Added run\n */\nconst add = (index, run) => {\n  const start = run.start + index;\n  const end = run.end + index;\n  return Object.assign({}, run, {\n    start,\n    end\n  });\n};\n\n/**\n * Get run length\n *\n * @param run - Run\n * @returns Length\n */\nconst length = run => {\n  return run.end - run.start;\n};\n\n/**\n * Concats two runs into one\n *\n * @param runA - First run\n * @param runB - Second run\n * @returns Concatenated run\n */\nconst concat = (runA, runB) => {\n  const end = runA.end + length(runB);\n  const glyphs = (runA.glyphs || []).concat(runB.glyphs || []);\n  const positions = (runA.positions || []).concat(runB.positions || []);\n  const attributes = Object.assign({}, runA.attributes, runB.attributes);\n  const runAIndices = runA.glyphIndices || [];\n  const runALastIndex = last(runAIndices) || 0;\n  const runBIndices = (runB.glyphIndices || []).map(i => i + runALastIndex + 1);\n  const glyphIndices = normalize(runAIndices.concat(runBIndices));\n  return Object.assign({}, runA, {\n    end,\n    glyphs,\n    positions,\n    attributes,\n    glyphIndices\n  });\n};\n\n/**\n * Insert glyph to run in the given index\n *\n * @param index - Index\n * @param glyph - Glyph\n * @param run - Run\n * @returns Run with glyph\n */\nconst insertGlyph$1 = (index, glyph, run) => {\n  if (!glyph) return run;\n  // Split resolves ligature splitting in case new glyph breaks some\n  const leadingRun = slice$1(0, index, run);\n  const trailingRun = slice$1(index, Infinity, run);\n  return concat(append$1(glyph, leadingRun), trailingRun);\n};\n/**\n * Insert either glyph or code point to run in the given index\n *\n * @param index - Index\n * @param value - Glyph or codePoint\n * @param run - Run\n * @returns Run with glyph\n */\nconst insert = (index, value, run) => {\n  const font = getFont(run);\n  const glyph = isNumber(value) ? fromCodePoint(value, font) : value;\n  return insertGlyph$1(index, glyph, run);\n};\n\n/**\n * Get run index at char index\n *\n * @param index - Char index\n * @param attributedString - Attributed string\n * @returns Run index\n */\nconst runIndexAt = (index, attributedString) => {\n  return runIndexAt$1(index, attributedString.runs);\n};\n\n/**\n * Insert glyph into attributed string\n *\n * @param index - Index\n * @param glyph - Glyph or code point\n * @param attributedString - Attributed string\n * @returns Attributed string with new glyph\n */\nconst insertGlyph = (index, glyph, attributedString) => {\n  const runIndex = runIndexAt(index, attributedString);\n  // Add glyph to the end if run index invalid\n  if (runIndex === -1) return append(glyph, attributedString);\n  const codePoints = [glyph];\n  const string = attributedString.string.slice(0, index) + stringFromCodePoints(codePoints) + attributedString.string.slice(index);\n  const runs = attributedString.runs.map((run, i) => {\n    if (i === runIndex) return insert(index - run.start, glyph, run);\n    if (i > runIndex) return add(codePoints.length, run);\n    return run;\n  });\n  return Object.assign({}, attributedString, {\n    string,\n    runs\n  });\n};\n\n/**\n * Advance width between two string indices\n *\n * @param start - Glyph index\n * @param end - Glyph index\n * @param run - Run\n * @returns Advanced width run\n */\nconst advanceWidthBetween$1 = (start, end, run) => {\n  const runStart = run.start || 0;\n  const glyphStartIndex = Math.max(0, glyphIndexAt(start - runStart, run));\n  const glyphEndIndex = Math.max(0, glyphIndexAt(end - runStart, run));\n  const positions = (run.positions || []).slice(glyphStartIndex, glyphEndIndex);\n  return advanceWidth$2(positions);\n};\n\n/**\n * Advance width between start and end\n * Does not consider ligature splitting for the moment.\n * Check performance impact on supporting this\n *\n * @param start - Start offset\n * @param end - End offset\n * @param attributedString\n * @returns Advance width\n */\nconst advanceWidthBetween = (start, end, attributedString) => {\n  const runs = filter(start, end, attributedString.runs);\n  return runs.reduce((acc, run) => acc + advanceWidthBetween$1(start, end, run), 0);\n};\nconst HYPHEN = 0x002d;\nconst TOLERANCE_STEPS = 5;\nconst TOLERANCE_LIMIT = 50;\nconst opts = {\n  width: 3,\n  stretch: 6,\n  shrink: 9\n};\n/**\n * Slice attributed string to many lines\n *\n * @param attributedString - Attributed string\n * @param nodes\n * @param breaks\n * @returns Attributed strings\n */\nconst breakLines = (attributedString, nodes, breaks) => {\n  let start = 0;\n  let end = null;\n  const lines = breaks.reduce((acc, breakPoint) => {\n    const node = nodes[breakPoint];\n    const prevNode = nodes[breakPoint - 1];\n    // Last breakpoint corresponds to K&P mandatory final glue\n    if (breakPoint === nodes.length - 1) return acc;\n    let line;\n    if (node.type === 'penalty') {\n      // @ts-expect-error penalty node will always preceed box or glue node\n      end = prevNode.end;\n      line = slice(start, end, attributedString);\n      line = insertGlyph(line.string.length, HYPHEN, line);\n    } else {\n      end = node.end;\n      line = slice(start, end, attributedString);\n    }\n    start = end;\n    return [...acc, line];\n  }, []);\n  // Last line\n  lines.push(slice(start, attributedString.string.length, attributedString));\n  return lines;\n};\n/**\n * Return Knuth & Plass nodes based on line and previously calculated syllables\n *\n * @param attributedString - Attributed string\n * @param attributes - Attributes\n * @param options - Layout options\n * @returns ?\n */\nconst getNodes = (attributedString, _ref2, options) => {\n  let {\n    align\n  } = _ref2;\n  let start = 0;\n  const hyphenWidth = 5;\n  const {\n    syllables\n  } = attributedString;\n  const hyphenPenalty = options.hyphenationPenalty || (align === 'justify' ? 100 : 600);\n  const result = syllables.reduce((acc, s, index) => {\n    const width = advanceWidthBetween(start, start + s.length, attributedString);\n    if (s.trim() === '') {\n      const stretch = width * opts.width / opts.stretch;\n      const shrink = width * opts.width / opts.shrink;\n      const end = start + s.length;\n      // Add glue node. Glue nodes are used to fill the space between words.\n      acc.push(linebreak.glue(width, start, end, stretch, shrink));\n    } else {\n      const hyphenated = syllables[index + 1] !== ' ';\n      const end = start + s.length;\n      // Add box node. Box nodes are used to represent words.\n      acc.push(linebreak.box(width, start, end, hyphenated));\n      if (syllables[index + 1] && hyphenated) {\n        // Add penalty node. Penalty nodes are used to represent hyphenation points.\n        acc.push(linebreak.penalty(hyphenWidth, hyphenPenalty, 1));\n      }\n    }\n    start += s.length;\n    return acc;\n  }, []);\n  // Add mandatory final glue\n  result.push(linebreak.glue(0, start, start, linebreak.infinity, 0));\n  result.push(linebreak.penalty(0, -linebreak.infinity, 1));\n  return result;\n};\n/**\n * @param attributedString - Attributed string\n * @returns Attributes\n */\nconst getAttributes = attributedString => {\n  var _attributedString$run2;\n  return ((_attributedString$run2 = attributedString.runs) === null || _attributedString$run2 === void 0 || (_attributedString$run2 = _attributedString$run2[0]) === null || _attributedString$run2 === void 0 ? void 0 : _attributedString$run2.attributes) || {};\n};\n/**\n * Performs Knuth & Plass line breaking algorithm\n * Fallbacks to best fit algorithm if latter not successful\n *\n * @param options - Layout options\n */\nconst linebreaker = options => {\n  /**\n   * @param attributedString - Attributed string\n   * @param availableWidths - Available widths\n   * @returns Attributed string\n   */\n  return (attributedString, availableWidths) => {\n    let tolerance = options.tolerance || 4;\n    const attributes = getAttributes(attributedString);\n    const nodes = getNodes(attributedString, attributes, options);\n    let breaks = linebreak(nodes, availableWidths, tolerance);\n    // Try again with a higher tolerance if the line breaking failed.\n    while (breaks.length === 0 && tolerance < TOLERANCE_LIMIT) {\n      tolerance += TOLERANCE_STEPS;\n      breaks = linebreak(nodes, availableWidths, tolerance);\n    }\n    if (breaks.length === 0 || breaks.length === 1 && breaks[0] === 0) {\n      breaks = applyBestFit(nodes, availableWidths);\n    }\n    return breakLines(attributedString, nodes, breaks.slice(1));\n  };\n};\nvar Direction;\n(function (Direction) {\n  Direction[Direction[\"GROW\"] = 0] = \"GROW\";\n  Direction[Direction[\"SHRINK\"] = 1] = \"SHRINK\";\n})(Direction || (Direction = {}));\nconst WHITESPACE_PRIORITY = 1;\nconst LETTER_PRIORITY = 2;\nconst EXPAND_WHITESPACE_FACTOR = {\n  before: 0.5,\n  after: 0.5,\n  priority: WHITESPACE_PRIORITY,\n  unconstrained: false\n};\nconst EXPAND_CHAR_FACTOR = {\n  before: 0.14453125,\n  // 37/256\n  after: 0.14453125,\n  priority: LETTER_PRIORITY,\n  unconstrained: false\n};\nconst SHRINK_WHITESPACE_FACTOR = {\n  before: -0.04296875,\n  // -11/256\n  after: -0.04296875,\n  priority: WHITESPACE_PRIORITY,\n  unconstrained: false\n};\nconst SHRINK_CHAR_FACTOR = {\n  before: -0.04296875,\n  after: -0.04296875,\n  priority: LETTER_PRIORITY,\n  unconstrained: false\n};\nconst getCharFactor = (direction, options) => {\n  const expandCharFactor = options.expandCharFactor || {};\n  const shrinkCharFactor = options.shrinkCharFactor || {};\n  return direction === Direction.GROW ? Object.assign({}, EXPAND_CHAR_FACTOR, expandCharFactor) : Object.assign({}, SHRINK_CHAR_FACTOR, shrinkCharFactor);\n};\nconst getWhitespaceFactor = (direction, options) => {\n  const expandWhitespaceFactor = options.expandWhitespaceFactor || {};\n  const shrinkWhitespaceFactor = options.shrinkWhitespaceFactor || {};\n  return direction === Direction.GROW ? Object.assign({}, EXPAND_WHITESPACE_FACTOR, expandWhitespaceFactor) : Object.assign({}, SHRINK_WHITESPACE_FACTOR, shrinkWhitespaceFactor);\n};\nconst factor = (direction, options) => glyphs => {\n  const charFactor = getCharFactor(direction, options);\n  const whitespaceFactor = getWhitespaceFactor(direction, options);\n  const factors = [];\n  for (let index = 0; index < glyphs.length; index += 1) {\n    let f;\n    const glyph = glyphs[index];\n    if (isWhiteSpace(glyph)) {\n      f = Object.assign({}, whitespaceFactor);\n      if (index === glyphs.length - 1) {\n        f.before = 0;\n        if (index > 0) {\n          factors[index - 1].after = 0;\n        }\n      }\n    } else if (glyph.isMark && index > 0) {\n      f = Object.assign({}, factors[index - 1]);\n      f.before = 0;\n      factors[index - 1].after = 0;\n    } else {\n      f = Object.assign({}, charFactor);\n    }\n    factors.push(f);\n  }\n  return factors;\n};\nconst getFactors = (gap, line, options) => {\n  const direction = gap > 0 ? Direction.GROW : Direction.SHRINK;\n  const getFactor = factor(direction, options);\n  const factors = line.runs.reduce((acc, run) => {\n    return acc.concat(getFactor(run.glyphs));\n  }, []);\n  factors[0].before = 0;\n  factors[factors.length - 1].after = 0;\n  return factors;\n};\nconst KASHIDA_PRIORITY = 0;\nconst NULL_PRIORITY = 3;\nconst getDistances = (gap, factors) => {\n  let total = 0;\n  const priorities = [];\n  const unconstrained = [];\n  for (let priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {\n    priorities[priority] = unconstrained[priority] = 0;\n  }\n  // sum the factors at each priority\n  for (let j = 0; j < factors.length; j += 1) {\n    const f = factors[j];\n    const sum = f.before + f.after;\n    total += sum;\n    priorities[f.priority] += sum;\n    if (f.unconstrained) {\n      unconstrained[f.priority] += sum;\n    }\n  }\n  // choose the priorities that need to be applied\n  let highestPriority = -1;\n  let highestPrioritySum = 0;\n  let remainingGap = gap;\n  let priority;\n  for (priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {\n    const prioritySum = priorities[priority];\n    if (prioritySum !== 0) {\n      if (highestPriority === -1) {\n        highestPriority = priority;\n        highestPrioritySum = prioritySum;\n      }\n      // if this priority covers the remaining gap, we're done\n      if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {\n        priorities[priority] = remainingGap / prioritySum;\n        unconstrained[priority] = 0;\n        remainingGap = 0;\n        break;\n      }\n      // mark that we need to use 100% of the adjustment from\n      // this priority, and subtract the space that it consumes\n      priorities[priority] = 1;\n      remainingGap -= prioritySum;\n      // if this priority has unconstrained glyphs, let them consume the remaining space\n      if (unconstrained[priority] !== 0) {\n        unconstrained[priority] = remainingGap / unconstrained[priority];\n        remainingGap = 0;\n        break;\n      }\n    }\n  }\n  // zero out remaining priorities (if any)\n  for (let p = priority + 1; p <= NULL_PRIORITY; p += 1) {\n    priorities[p] = 0;\n    unconstrained[p] = 0;\n  }\n  // if there is still space left over, assign it to the highest priority that we saw.\n  // this violates their factors, but it only happens in extreme cases\n  if (remainingGap > 0 && highestPriority > -1) {\n    priorities[highestPriority] = (highestPrioritySum + (gap - total)) / highestPrioritySum;\n  }\n  // create and return an array of distances to add to each glyph's advance\n  const distances = [];\n  for (let index = 0; index < factors.length; index += 1) {\n    // the distance to add to this glyph is the sum of the space to add\n    // after this glyph, and the space to add before the next glyph\n    const f = factors[index];\n    const next = factors[index + 1];\n    let dist = f.after * priorities[f.priority];\n    if (next) {\n      dist += next.before * priorities[next.priority];\n    }\n    // if this glyph is unconstrained, add the unconstrained distance as well\n    if (f.unconstrained) {\n      dist += f.after * unconstrained[f.priority];\n      if (next) {\n        dist += next.before * unconstrained[next.priority];\n      }\n    }\n    distances.push(dist);\n  }\n  return distances;\n};\n\n/**\n * Adjust run positions by given distances\n *\n * @param distances\n * @param line\n * @returns Line\n */\nconst justifyLine = (distances, line) => {\n  let index = 0;\n  for (const run of line.runs) {\n    for (const position of run.positions) {\n      position.xAdvance += distances[index++];\n    }\n  }\n  return line;\n};\n/**\n * A JustificationEngine is used by a Typesetter to perform line fragment\n * justification. This implementation is based on a description of Apple's\n * justification algorithm from a PDF in the Apple Font Tools package.\n *\n * @param options - Layout options\n */\nconst justification = options => {\n  /**\n   * @param line\n   * @returns Line\n   */\n  return line => {\n    const gap = line.box.width - advanceWidth(line);\n    if (gap === 0) return line; // Exact fit\n    const factors = getFactors(gap, line, options);\n    const distances = getDistances(gap, factors);\n    return justifyLine(distances, line);\n  };\n};\n\n/**\n * Returns attributed string ascent\n *\n * @param attributedString - Attributed string\n * @returns Ascent\n */\nconst ascent = attributedString => {\n  const reducer = (acc, run) => Math.max(acc, ascent$1(run));\n  return attributedString.runs.reduce(reducer, 0);\n};\n\n// The base font size used for calculating underline thickness.\nconst BASE_FONT_SIZE = 12;\n/**\n * A TextDecorationEngine is used by a Typesetter to generate\n * DecorationLines for a line fragment, including underlines\n * and strikes.\n */\nconst textDecoration = () => line => {\n  let x = line.overflowLeft || 0;\n  const overflowRight = line.overflowRight || 0;\n  const maxX = advanceWidth(line) - overflowRight;\n  line.decorationLines = [];\n  for (let i = 0; i < line.runs.length; i += 1) {\n    const run = line.runs[i];\n    const width = Math.min(maxX - x, advanceWidth$1(run));\n    const thickness = Math.max(0.5, Math.floor(run.attributes.fontSize / BASE_FONT_SIZE));\n    if (run.attributes.underline) {\n      const rect = {\n        x,\n        y: ascent(line) + thickness * 2,\n        width,\n        height: thickness\n      };\n      const decorationLine = {\n        rect,\n        opacity: run.attributes.opacity,\n        color: run.attributes.underlineColor || 'black',\n        style: run.attributes.underlineStyle || 'solid'\n      };\n      line.decorationLines.push(decorationLine);\n    }\n    if (run.attributes.strike) {\n      const y = ascent(line) - ascent$1(run) / 3;\n      const rect = {\n        x,\n        y,\n        width,\n        height: thickness\n      };\n      const decorationLine = {\n        rect,\n        opacity: run.attributes.opacity,\n        color: run.attributes.strikeColor || 'black',\n        style: run.attributes.strikeStyle || 'solid'\n      };\n      line.decorationLines.push(decorationLine);\n    }\n    x += width;\n  }\n  return line;\n};\nconst ignoredScripts = ['Common', 'Inherited', 'Unknown'];\n/**\n * Resolves unicode script in runs, grouping equal runs together\n */\nconst scriptItemizer = () => {\n  /**\n   * @param attributedString - Attributed string\n   * @returns Attributed string\n   */\n  return attributedString => {\n    const {\n      string\n    } = attributedString;\n    let lastScript = 'Unknown';\n    let lastIndex = 0;\n    let index = 0;\n    const runs = [];\n    if (!string) return empty();\n    for (let i = 0; i < string.length; i += 1) {\n      const char = string[i];\n      const codePoint = char.codePointAt(0);\n      const script = unicode.getScript(codePoint);\n      if (script !== lastScript && !ignoredScripts.includes(script)) {\n        if (lastScript !== 'Unknown') {\n          runs.push({\n            start: lastIndex,\n            end: index,\n            attributes: {\n              script: lastScript\n            }\n          });\n        }\n        lastIndex = index;\n        lastScript = script;\n      }\n      index += char.length;\n    }\n    if (lastIndex < string.length) {\n      runs.push({\n        start: lastIndex,\n        end: string.length,\n        attributes: {\n          script: lastScript\n        }\n      });\n    }\n    const result = {\n      string,\n      runs: runs\n    };\n    return result;\n  };\n};\nconst SOFT_HYPHEN = '\\u00ad';\nconst hyphenator = hyphen(pattern);\n/**\n * @param word\n * @returns Word parts\n */\nconst splitHyphen = word => {\n  return word.split(SOFT_HYPHEN);\n};\nconst cache = {};\n/**\n * @param word\n * @returns Word parts\n */\nconst getParts = word => {\n  const base = word.includes(SOFT_HYPHEN) ? word : hyphenator(word);\n  return splitHyphen(base);\n};\nconst wordHyphenation = () => {\n  /**\n   * @param word - Word\n   * @returns Word parts\n   */\n  return word => {\n    const cacheKey = \"_\".concat(word);\n    if (isNil(word)) return [];\n    if (cache[cacheKey]) return cache[cacheKey];\n    cache[cacheKey] = getParts(word);\n    return cache[cacheKey];\n  };\n};\nconst IGNORED_CODE_POINTS = [173];\nconst getFontSize = run => run.attributes.fontSize || 12;\nconst pickFontFromFontStack = (codePoint, fontStack, lastFont) => {\n  const fontStackWithFallback = [...fontStack, lastFont];\n  for (let i = 0; i < fontStackWithFallback.length; i += 1) {\n    const font = fontStackWithFallback[i];\n    if (!IGNORED_CODE_POINTS.includes(codePoint) && font && font.hasGlyphForCodePoint && font.hasGlyphForCodePoint(codePoint)) {\n      return font;\n    }\n  }\n  return fontStack.at(-1);\n};\nconst fontSubstitution = () => _ref3 => {\n  let {\n    string,\n    runs\n  } = _ref3;\n  let lastFont = null;\n  let lastFontSize = null;\n  let lastIndex = 0;\n  let index = 0;\n  const res = [];\n  for (let i = 0; i < runs.length; i += 1) {\n    const run = runs[i];\n    if (string.length === 0) {\n      res.push({\n        start: 0,\n        end: 0,\n        attributes: {\n          font: run.attributes.font\n        }\n      });\n      break;\n    }\n    const chars = string.slice(run.start, run.end);\n    for (let j = 0; j < chars.length; j += 1) {\n      const char = chars[j];\n      const codePoint = char.codePointAt(0);\n      // If the default font does not have a glyph and the fallback font does, we use it\n      const font = pickFontFromFontStack(codePoint, run.attributes.font, lastFont);\n      const fontSize = getFontSize(run);\n      // If anything that would impact res has changed, update it\n      if (font !== lastFont || fontSize !== lastFontSize || font.unitsPerEm !== lastFont.unitsPerEm) {\n        if (lastFont) {\n          res.push({\n            start: lastIndex,\n            end: index,\n            attributes: {\n              font: [lastFont],\n              scale: lastFontSize / lastFont.unitsPerEm\n            }\n          });\n        }\n        lastFont = font;\n        lastFontSize = fontSize;\n        lastIndex = index;\n      }\n      index += char.length;\n    }\n  }\n  if (lastIndex < string.length) {\n    const fontSize = getFontSize(last(runs));\n    res.push({\n      start: lastIndex,\n      end: string.length,\n      attributes: {\n        font: [lastFont],\n        scale: fontSize / lastFont.unitsPerEm\n      }\n    });\n  }\n  return {\n    string,\n    runs: res\n  };\n};\nexport { bidiEngine as bidi, layoutEngine as default, fontSubstitution, fromFragments, justification, linebreaker, scriptItemizer, textDecoration, wordHyphenation };","map":{"version":3,"names":["isNil","last","repeat","reverse","dropLast","dropLast$2","adjust","compose","bidiFactory","unicode","hyphen","pattern","fromFragments","fragments","offset","string","runs","forEach","fragment","push","_objectSpread","start","end","length","attributes","defaultHyphenationEngine","word","wrapWords","engines","arguments","undefined","options","attributedString","_engines$wordHyphenat","syllables","hyphenateWord","hyphenationCallback","wordHyphenation","call","i","run","words","slice","split","filter","Boolean","j","parts","join","result","copy","rect","Object","assign","partition","height","a","b","y","crop","height$2","paragraph","reduce","acc","block","box","calculateScale","_font$","fontSize","font","unitsPerEm","scale","_run$attributes","index","glyphIndices","value","getFont","_run$attributes2","slice$2","glyph","codePoints","String","fromCodePoint","layout","glyphs","glyphIndexAt","_run$glyphIndices","normalize","array","head","map","slice$1","_run$glyphs","_run$glyphs2","runScale","startIndex","endIndex","startGlyph","endGlyph","startOffset","startGlyphs","Infinity","endOffset","endGlyphs","sliceStart","Math","min","glyphPosition","g","xAdvance","advanceWidth","yAdvance","xOffset","yOffset","startPositions","positions","endPositions","flat","runIndexAt$1","findIndex","max","subtract","sliceRuns","sliceFirstRun","sliceLastRun","isFirst","isLast","filteredRuns","slicedRuns","findCharIndex","search","findLastCharIndex","match","lastIndexOf","trim","empty$1","isNumber","appendIndices","indices","lastIndex","newIndices","Array","fill","concat","glyphForCodePoint","appendGlyph","_glyph$codePoints","glyphLength","append$1","stringFromCodePoints","append","codePointsString","firstRuns","lastRun","ELLIPSIS_UNICODE","ELLIPSIS_STRING","fromCharCode","getEllipsisCodePoint","encode","parseInt","truncate","_last","_last2","codePoint","lastBlock","omit","ascent$1","_font$2","attachment","attachmentHeight","fontAscent","ascent","descent","_run$attributes3","_font$3","fontDescent","lineGap","_run$attributes4","_font$4","height$1","_run$attributes5","lineHeight","reducer","intersects","x","num1","width","num2","getLineFragment","lineRect","excludeRect","eStart","eEnd","lStart","lEnd","r","getLineFragments","excludeRects","pieces","generateLineRects","container","_objectWithoutProperties","_excluded","lineRects","maxY","currentRect","rest","lineRectFragments","ATTACHMENT_CODE$1","purgeAttachments","line","shouldPurge","includes","layoutLines","rects","lines","indent","shift","currentY","_line$runs","lineIndent","style","newLine","layoutParagraph","_paragraph$runs","availableWidths","unshift","linebreaker","sliceAtHeight","newBlock","counter","typesetter","attributedStrings","paragraphs","maxLines","truncateEllipsis","truncateMode","linesCount","paragraphRect","nextParagraph","slicedBlock","linesHeight","shouldTruncate","length$1","bidi$2","getBidiLevels$1","levels","bidiLevel","getReorderedIndices","segments","_ref","getItemAtIndex","objectName","updatedIndex","Error","reorderLine","_line$runs$","direction","level","embeddingLevels","getReorderSegments","updatedString","getReorderedString","updatedRuns","selectedIndices","updatedGlyphs","updatedPositions","addedGlyphs","Set","has","id","isLigature","add","reorderParagraph","bidiReordering","DUMMY_CODEPOINT","resolve","next","getCharacterSpacing","_run$attributes6","characterSpacing","scalePositions","position","xSpacing","layoutRun","runString","glyphRun","generateGlyphs","res","resolveRunYOffset","_run$attributes7","_run$attributes8","p","resolveYOffset","sort","isEmpty","sortPoints","generatePoints","mergeRuns","groupEmptyRuns","groups","values","flattenEmptyRuns","flattenRegularRuns","points","attrs","stack","type","splice","flatten","emptyRuns","regularRuns","empty","omitFont","preprocessRuns","fontSubstitution","scriptItemizer","bidi","omittedFontRuns","itemizationRuns","substitutedRuns","bidiRuns","splitParagraphs","breakPoint","indexOf","advanceWidth$2","pos","advanceWidth$1","WHITE_SPACES_CODE","isWhiteSpace","leadingPositions","leadingWhitespaces","leadingOffset$1","leadingOffset","trailingPositions","trailingOffset$1","trailingOffset","dropLast$1","ALIGNMENT_FACTORS","center","right","removeNewLine","getOverflowLeft","overflowLeft","getOverflowRight","overflowRight","adjustOverflow","justifyLine$1","align","lineWidth","alignFactor","remainingWidth","shouldJustify","justification","finalizeLine","lineAscent","lineDescent","lineXAdvance","descent$1","finalizeBlock","_line$runs2","isLastFragment","alignLastLine","textDecoration","finalizeFragments","blockFinalizer","ATTACHMENT_CODE","isReplaceGlyph","resolveRunAttachments","_run$attributes9","resolveAttachments","applyAttributes","backgroundColor","bullet","color","features","hangingPunctuation","hyphenationFactor","justificationFactor","lineSpacing","link","marginLeft","margin","marginRight","opacity","paddingTop","padding","paragraphSpacing","script","shrinkFactor","strike","strikeColor","strikeStyle","stroke","underline","underlineColor","underlineStyle","verticalAlign","wordSpacing","applyRunStyles","applyDefaultStyles","verticalAlignment","bidi$1","getBidiLevels","mirrorString","char","isRTL","mirroredChar","getMirroredCharacter","charAt","layoutEngine","processParagraph","processParagraphs","bidiEngine","_attributedString$run","getEmbeddingLevels","lastLevel","INFINITY","getNextBreakpoint","subnodes","widths","lineNumber","minimumBadness","sum","stretch","shrink","lineLength","calculateRatio","node","ratio","penalty","badness","abs","applyBestFit","nodes","count","breakpoints","breakpoint","LinkedListNode","constructor","data","_defineProperty","prev","LinkedList","tail","listSize","listLength","isLinked","size","first","callback","at","insertAfter","newNode","insertBefore","remove","demerits","fitnessClass","totals","previous","computeCost","lineLengths","active","currentLine","linebreak","infinity","computeSum","breakPointIndex","findBestBreakpoints","activeNodes","tmp","tolerance","flagged","fitness","Node","mainLoop","candidates","pow","currentClass","tmpSum","candidate","precedesBox","glue","hyphenated","runA","runB","runAIndices","runALastIndex","runBIndices","insertGlyph$1","leadingRun","trailingRun","insert","runIndexAt","insertGlyph","runIndex","advanceWidthBetween$1","runStart","glyphStartIndex","glyphEndIndex","advanceWidthBetween","HYPHEN","TOLERANCE_STEPS","TOLERANCE_LIMIT","opts","breakLines","breaks","prevNode","getNodes","_ref2","hyphenWidth","hyphenPenalty","hyphenationPenalty","s","getAttributes","_attributedString$run2","Direction","WHITESPACE_PRIORITY","LETTER_PRIORITY","EXPAND_WHITESPACE_FACTOR","before","after","priority","unconstrained","EXPAND_CHAR_FACTOR","SHRINK_WHITESPACE_FACTOR","SHRINK_CHAR_FACTOR","getCharFactor","expandCharFactor","shrinkCharFactor","GROW","getWhitespaceFactor","expandWhitespaceFactor","shrinkWhitespaceFactor","factor","charFactor","whitespaceFactor","factors","f","isMark","getFactors","gap","SHRINK","getFactor","KASHIDA_PRIORITY","NULL_PRIORITY","getDistances","total","priorities","highestPriority","highestPrioritySum","remainingGap","prioritySum","distances","dist","justifyLine","BASE_FONT_SIZE","maxX","decorationLines","thickness","floor","decorationLine","ignoredScripts","lastScript","codePointAt","getScript","SOFT_HYPHEN","hyphenator","splitHyphen","cache","getParts","base","cacheKey","IGNORED_CODE_POINTS","getFontSize","pickFontFromFontStack","fontStack","lastFont","fontStackWithFallback","hasGlyphForCodePoint","_ref3","lastFontSize","chars","default"],"sources":["C:/PreventaWeb/FrontEnd/node_modules/@react-pdf/textkit/lib/textkit.js"],"sourcesContent":["import { isNil, last, repeat, reverse, dropLast as dropLast$2, adjust, compose } from '@react-pdf/fns';\nimport bidiFactory from 'bidi-js';\nimport unicode from 'unicode-properties';\nimport hyphen from 'hyphen';\nimport pattern from 'hyphen/patterns/en-us.js';\n\n/**\n * Create attributed string from text fragments\n *\n * @param fragments - Fragments\n * @returns Attributed string\n */\nconst fromFragments = (fragments) => {\n    let offset = 0;\n    let string = '';\n    const runs = [];\n    fragments.forEach((fragment) => {\n        string += fragment.string;\n        runs.push({\n            ...fragment,\n            start: offset,\n            end: offset + fragment.string.length,\n            attributes: fragment.attributes || {},\n        });\n        offset += fragment.string.length;\n    });\n    return { string, runs };\n};\n\n/**\n * Default word hyphenation engine used when no one provided.\n * Does not perform word hyphenation at all\n *\n * @param word\n * @returns Same word\n */\nconst defaultHyphenationEngine = (word) => [word];\n/**\n * Wrap words of attribute string\n *\n * @param engines layout engines\n * @param options layout options\n */\nconst wrapWords = (engines = {}, options = {}) => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Attributed string including syllables\n     */\n    return (attributedString) => {\n        const syllables = [];\n        const fragments = [];\n        const hyphenateWord = options.hyphenationCallback ||\n            engines.wordHyphenation?.() ||\n            defaultHyphenationEngine;\n        for (let i = 0; i < attributedString.runs.length; i += 1) {\n            let string = '';\n            const run = attributedString.runs[i];\n            const words = attributedString.string\n                .slice(run.start, run.end)\n                .split(/([ ]+)/g)\n                .filter(Boolean);\n            for (let j = 0; j < words.length; j += 1) {\n                const word = words[j];\n                const parts = hyphenateWord(word);\n                syllables.push(...parts);\n                string += parts.join('');\n            }\n            fragments.push({ ...run, string });\n        }\n        const result = { ...fromFragments(fragments), syllables };\n        return result;\n    };\n};\n\n/**\n * Clone rect\n *\n * @param rect - Rect\n * @returns Cloned rect\n */\nconst copy = (rect) => {\n    return Object.assign({}, rect);\n};\n\n/**\n * Partition rect in two in the vertical direction\n *\n * @param rect - Rect\n * @param height - Height\n * @returns Partitioned rects\n */\nconst partition = (rect, height) => {\n    const a = Object.assign({}, rect, { height });\n    const b = Object.assign({}, rect, {\n        y: rect.y + height,\n        height: rect.height - height,\n    });\n    return [a, b];\n};\n\n/**\n * Crop upper section of rect\n *\n * @param height - Height\n * @param rect - Rect\n * @returns Cropped rect\n */\nconst crop = (height, rect) => {\n    const [, result] = partition(rect, height);\n    return result;\n};\n\n/**\n * Get paragraph block height\n *\n * @param paragraph - Paragraph\n * @returns Paragraph block height\n */\nconst height$2 = (paragraph) => {\n    return paragraph.reduce((acc, block) => acc + block.box.height, 0);\n};\n\n/**\n * Calculate run scale\n *\n * @param run - Run\n * @returns Scale\n */\nconst calculateScale = (run) => {\n    const attributes = run.attributes || {};\n    const fontSize = attributes.fontSize || 12;\n    const font = attributes.font;\n    const unitsPerEm = typeof font === 'string' ? null : font?.[0]?.unitsPerEm;\n    return unitsPerEm ? fontSize / unitsPerEm : 0;\n};\n/**\n * Get run scale\n *\n * @param  run\n * @returns Scale\n */\nconst scale = (run) => {\n    return run.attributes?.scale || calculateScale(run);\n};\n\n/**\n * Get ligature offset by index\n *\n * Ex. ffi ligature\n *\n *   glyphs:         l  o  f  f  i  m\n *   glyphIndices:   0  1  2  2  2  3\n *   offset:         0  0  0  1  2  0\n *\n * @param index\n * @param run - Run\n * @returns Ligature offset\n */\nconst offset = (index, run) => {\n    if (!run)\n        return 0;\n    const glyphIndices = run.glyphIndices || [];\n    const value = glyphIndices[index];\n    return glyphIndices.slice(0, index).filter((i) => i === value).length;\n};\n\n/**\n * Get run font\n *\n * @param run - Run\n * @returns Font\n */\nconst getFont = (run) => {\n    return run.attributes?.font?.[0] || null;\n};\n\n/**\n * Slice glyph between codePoints range\n * Util for breaking ligatures\n *\n * @param start - Start code point index\n * @param end - End code point index\n * @param font - Font to generate new glyph\n * @param glyph - Glyph to be sliced\n * @returns Sliced glyph parts\n */\nconst slice$2 = (start, end, font, glyph) => {\n    if (!glyph)\n        return [];\n    if (start === end)\n        return [];\n    if (start === 0 && end === glyph.codePoints.length)\n        return [glyph];\n    const codePoints = glyph.codePoints.slice(start, end);\n    const string = String.fromCodePoint(...codePoints);\n    // passing LTR To force fontkit to not reverse the string\n    return font\n        ? font.layout(string, undefined, undefined, undefined, 'ltr').glyphs\n        : [glyph];\n};\n\n/**\n * Return glyph index at string index, if glyph indices present.\n * Otherwise return string index\n *\n * @param index - Index\n * @param run - Run\n * @returns Glyph index\n */\nconst glyphIndexAt = (index, run) => {\n    const result = run?.glyphIndices?.[index];\n    return isNil(result) ? index : result;\n};\n\n/**\n * Returns new array starting with zero, and keeping same relation between consecutive values\n *\n * @param array - List\n * @returns Normalized array\n */\nconst normalize = (array) => {\n    const head = array[0];\n    return array.map((value) => value - head);\n};\n\n/**\n * Slice run between glyph indices range\n *\n * @param start - Glyph index\n * @param end - Glyph index\n * @param run - Run\n * @returns Sliced run\n */\nconst slice$1 = (start, end, run) => {\n    const runScale = scale(run);\n    const font = getFont(run);\n    // Get glyph start and end indices\n    const startIndex = glyphIndexAt(start, run);\n    const endIndex = glyphIndexAt(end, run);\n    // Get start and end glyph\n    const startGlyph = run.glyphs?.[startIndex];\n    const endGlyph = run.glyphs?.[endIndex];\n    // Get start ligature chunks (if any)\n    const startOffset = offset(start, run);\n    const startGlyphs = startOffset > 0 ? slice$2(startOffset, Infinity, font, startGlyph) : [];\n    // Get end ligature chunks (if any)\n    const endOffset = offset(end, run);\n    const endGlyphs = slice$2(0, endOffset, font, endGlyph);\n    // Compute new glyphs\n    const sliceStart = startIndex + Math.min(1, startOffset);\n    const glyphs = (run.glyphs || []).slice(sliceStart, endIndex);\n    // Compute new positions\n    const glyphPosition = (g) => ({\n        xAdvance: g.advanceWidth * runScale,\n        yAdvance: 0,\n        xOffset: 0,\n        yOffset: 0,\n    });\n    const startPositions = startGlyphs.map(glyphPosition);\n    const positions = (run.positions || []).slice(sliceStart, endIndex);\n    const endPositions = endGlyphs.map(glyphPosition);\n    return Object.assign({}, run, {\n        start: run.start + start,\n        end: Math.min(run.end, run.start + end),\n        glyphIndices: normalize((run.glyphIndices || []).slice(start, end)),\n        glyphs: [startGlyphs, glyphs, endGlyphs].flat(),\n        positions: [startPositions, positions, endPositions].flat(),\n    });\n};\n\n/**\n * Get run index that contains passed index\n *\n * @param index - Index\n * @param runs - Runs\n * @returns Run index\n */\nconst runIndexAt$1 = (index, runs) => {\n    if (!runs)\n        return -1;\n    return runs.findIndex((run) => run.start <= index && index < run.end);\n};\n\n/**\n * Filter runs contained between start and end\n *\n * @param start\n * @param end\n * @param runs\n * @returns Filtered runs\n */\nconst filter = (start, end, runs) => {\n    const startIndex = runIndexAt$1(start, runs);\n    const endIndex = Math.max(runIndexAt$1(end - 1, runs), startIndex);\n    return runs.slice(startIndex, endIndex + 1);\n};\n\n/**\n * Subtract scalar to run\n *\n * @param index - Scalar\n * @param run - Run\n * @returns Subtracted run\n */\nconst subtract = (index, run) => {\n    const start = run.start - index;\n    const end = run.end - index;\n    return Object.assign({}, run, { start, end });\n};\n\n/**\n * Slice array of runs\n *\n * @param start - Offset\n * @param end - Offset\n * @param runs\n * @returns Sliced runs\n */\nconst sliceRuns = (start, end, runs) => {\n    const sliceFirstRun = (a) => slice$1(start - a.start, end - a.start, a);\n    const sliceLastRun = (a) => slice$1(0, end - a.start, a);\n    return runs.map((run, i) => {\n        let result = run;\n        const isFirst = i === 0;\n        const isLast = !isFirst && i === runs.length - 1;\n        if (isFirst)\n            result = sliceFirstRun(run);\n        if (isLast)\n            result = sliceLastRun(run);\n        return subtract(start, result);\n    });\n};\n/**\n * Slice attributed string between two indices\n *\n * @param start - Offset\n * @param end - Offset\n * @param attributedString - Attributed string\n * @returns Attributed string\n */\nconst slice = (start, end, attributedString) => {\n    if (attributedString.string.length === 0)\n        return attributedString;\n    const string = attributedString.string.slice(start, end);\n    const filteredRuns = filter(start, end, attributedString.runs);\n    const slicedRuns = sliceRuns(start, end, filteredRuns);\n    return Object.assign({}, attributedString, { string, runs: slicedRuns });\n};\n\nconst findCharIndex = (string) => {\n    return string.search(/\\S/g);\n};\nconst findLastCharIndex = (string) => {\n    const match = string.match(/\\S/g);\n    return match ? string.lastIndexOf(match[match.length - 1]) : -1;\n};\n/**\n * Removes (strips) whitespace from both ends of the attributted string.\n *\n * @param attributedString - Attributed string\n * @returns Attributed string\n */\nconst trim = (attributedString) => {\n    const start = findCharIndex(attributedString.string);\n    const end = findLastCharIndex(attributedString.string);\n    return slice(start, end + 1, attributedString);\n};\n\n/**\n * Returns empty run\n *\n * @returns Empty run\n */\nconst empty$1 = () => {\n    return {\n        start: 0,\n        end: 0,\n        glyphIndices: [],\n        glyphs: [],\n        positions: [],\n        attributes: {},\n    };\n};\n\n/**\n * Check if value is a number\n *\n * @param value - Value to check\n * @returns Whether value is a number\n */\nconst isNumber = (value) => {\n    return typeof value === 'number';\n};\n\n/**\n * Append glyph indices with given length\n *\n * Ex. appendIndices(3, [0, 1, 2, 2]) => [0, 1, 2, 2, 3, 3, 3]\n *\n * @param length - Length\n * @param indices - Glyph indices\n * @returns Extended glyph indices\n */\nconst appendIndices = (length, indices) => {\n    const lastIndex = last(indices);\n    const value = isNil(lastIndex) ? 0 : lastIndex + 1;\n    const newIndices = Array(length).fill(value);\n    return indices.concat(newIndices);\n};\n\n/**\n * Get glyph for a given code point\n *\n * @param value - CodePoint\n * @param font - Font\n * @returns Glyph\n * */\nconst fromCodePoint = (value, font) => {\n    if (typeof font === 'string')\n        return null;\n    return font && value ? font.glyphForCodePoint(value) : null;\n};\n\n/**\n * Append glyph to run\n *\n * @param glyph - Glyph\n * @param run - Run\n * @returns Run with glyph\n */\nconst appendGlyph = (glyph, run) => {\n    const glyphLength = glyph.codePoints?.length || 0;\n    const end = run.end + glyphLength;\n    const glyphs = run.glyphs.concat(glyph);\n    const glyphIndices = appendIndices(glyphLength, run.glyphIndices);\n    if (!run.positions)\n        return Object.assign({}, run, { end, glyphs, glyphIndices });\n    const positions = run.positions.concat({\n        xAdvance: glyph.advanceWidth * scale(run),\n        yAdvance: 0,\n        xOffset: 0,\n        yOffset: 0,\n    });\n    return Object.assign({}, run, { end, glyphs, glyphIndices, positions });\n};\n/**\n * Append glyph or code point to run\n *\n * @param value - Glyph or codePoint\n * @param run - Run\n * @returns Run with glyph\n */\nconst append$1 = (value, run) => {\n    if (!value)\n        return run;\n    const font = getFont(run);\n    const glyph = isNumber(value) ? fromCodePoint(value, font) : value;\n    return appendGlyph(glyph, run);\n};\n\n/**\n * Get string from array of code points\n *\n * @param codePoints - Points\n * @returns String\n */\nconst stringFromCodePoints = (codePoints) => {\n    return String.fromCodePoint(...(codePoints || []));\n};\n\n/**\n * Append glyph into last run of attributed string\n *\n * @param glyph - Glyph or code point\n * @param attributedString - Attributed string\n * @returns Attributed string with new glyph\n */\nconst append = (glyph, attributedString) => {\n    const codePoints = typeof glyph === 'number' ? [glyph] : glyph?.codePoints;\n    const codePointsString = stringFromCodePoints(codePoints || []);\n    const string = attributedString.string + codePointsString;\n    const firstRuns = attributedString.runs.slice(0, -1);\n    const lastRun = last(attributedString.runs) || empty$1();\n    const runs = firstRuns.concat(append$1(glyph, lastRun));\n    return Object.assign({}, attributedString, { string, runs });\n};\n\nconst ELLIPSIS_UNICODE = 8230;\nconst ELLIPSIS_STRING = String.fromCharCode(ELLIPSIS_UNICODE);\n/**\n * Get ellipsis codepoint. This may be different in standard and embedded fonts\n *\n * @param font\n * @returns Ellipsis codepoint\n */\nconst getEllipsisCodePoint = (font) => {\n    if (!font.encode)\n        return ELLIPSIS_UNICODE;\n    const [codePoints] = font.encode(ELLIPSIS_STRING);\n    return parseInt(codePoints[0], 16);\n};\n/**\n * Trucante block with ellipsis\n *\n * @param paragraph - Paragraph\n * @returns Sliced paragraph\n */\nconst truncate = (paragraph) => {\n    const runs = last(paragraph)?.runs || [];\n    const font = last(runs)?.attributes?.font[0];\n    if (font) {\n        const index = paragraph.length - 1;\n        const codePoint = getEllipsisCodePoint(font);\n        const glyph = font.glyphForCodePoint(codePoint);\n        const lastBlock = append(glyph, trim(paragraph[index]));\n        return Object.assign([], paragraph, { [index]: lastBlock });\n    }\n    return paragraph;\n};\n\n/**\n * Omit attribute from run\n *\n * @param value - Attribute key\n * @param run - Run\n * @returns Run without ommited attribute\n */\nconst omit = (value, run) => {\n    const attributes = Object.assign({}, run.attributes);\n    delete attributes[value];\n    return Object.assign({}, run, { attributes });\n};\n\n/**\n * Get run ascent\n *\n * @param run - Run\n * @returns Ascent\n */\nconst ascent$1 = (run) => {\n    const { font, attachment } = run.attributes;\n    const attachmentHeight = attachment?.height || 0;\n    const fontAscent = typeof font === 'string' ? 0 : font?.[0]?.ascent || 0;\n    return Math.max(attachmentHeight, fontAscent * scale(run));\n};\n\n/**\n * Get run descent\n *\n * @param run - Run\n * @returns Descent\n */\nconst descent = (run) => {\n    const font = run.attributes?.font;\n    const fontDescent = typeof font === 'string' ? 0 : font?.[0]?.descent || 0;\n    return scale(run) * fontDescent;\n};\n\n/**\n * Get run lineGap\n *\n * @param run - Run\n * @returns LineGap\n */\nconst lineGap = (run) => {\n    const font = run.attributes?.font;\n    const lineGap = typeof font === 'string' ? 0 : font?.[0]?.lineGap || 0;\n    return lineGap * scale(run);\n};\n\n/**\n * Get run height\n *\n * @param run - Run\n * @returns Height\n */\nconst height$1 = (run) => {\n    const lineHeight = run.attributes?.lineHeight;\n    return lineHeight || lineGap(run) + ascent$1(run) - descent(run);\n};\n\n/**\n * Returns attributed string height\n *\n * @param attributedString - Attributed string\n * @returns Height\n */\nconst height = (attributedString) => {\n    const reducer = (acc, run) => Math.max(acc, height$1(run));\n    return attributedString.runs.reduce(reducer, 0);\n};\n\n/**\n * Checks if two rects intersect each other\n *\n * @param a - Rect A\n * @param b - Rect B\n * @returns Whether rects intersect\n */\nconst intersects = (a, b) => {\n    const x = Math.max(a.x, b.x);\n    const num1 = Math.min(a.x + a.width, b.x + b.width);\n    const y = Math.max(a.y, b.y);\n    const num2 = Math.min(a.y + a.height, b.y + b.height);\n    return num1 >= x && num2 >= y;\n};\n\nconst getLineFragment = (lineRect, excludeRect) => {\n    if (!intersects(excludeRect, lineRect))\n        return [lineRect];\n    const eStart = excludeRect.x;\n    const eEnd = excludeRect.x + excludeRect.width;\n    const lStart = lineRect.x;\n    const lEnd = lineRect.x + lineRect.width;\n    const a = Object.assign({}, lineRect, { width: eStart - lStart });\n    const b = Object.assign({}, lineRect, { x: eEnd, width: lEnd - eEnd });\n    return [a, b].filter((r) => r.width > 0);\n};\nconst getLineFragments = (rect, excludeRects) => {\n    let fragments = [rect];\n    for (let i = 0; i < excludeRects.length; i += 1) {\n        const excludeRect = excludeRects[i];\n        fragments = fragments.reduce((acc, fragment) => {\n            const pieces = getLineFragment(fragment, excludeRect);\n            return acc.concat(pieces);\n        }, []);\n    }\n    return fragments;\n};\nconst generateLineRects = (container, height) => {\n    const { excludeRects, ...rect } = container;\n    if (!excludeRects)\n        return [rect];\n    const lineRects = [];\n    const maxY = Math.max(...excludeRects.map((r) => r.y + r.height));\n    let currentRect = rect;\n    while (currentRect.y < maxY) {\n        const [lineRect, rest] = partition(currentRect, height);\n        const lineRectFragments = getLineFragments(lineRect, excludeRects);\n        currentRect = rest;\n        lineRects.push(...lineRectFragments);\n    }\n    return [...lineRects, currentRect];\n};\n\nconst ATTACHMENT_CODE$1 = '\\ufffc'; // 65532\n/**\n * Remove attachment attribute if no char present\n *\n * @param line - Line\n * @returns Line\n */\nconst purgeAttachments = (line) => {\n    const shouldPurge = !line.string.includes(ATTACHMENT_CODE$1);\n    if (!shouldPurge)\n        return line;\n    const runs = line.runs.map((run) => omit('attachment', run));\n    return Object.assign({}, line, { runs });\n};\n/**\n * Layout paragraphs inside rectangle\n *\n * @param rects - Rects\n * @param lines - Attributed strings\n * @param indent\n * @returns layout blocks\n */\nconst layoutLines = (rects, lines, indent) => {\n    let rect = rects.shift();\n    let currentY = rect.y;\n    return lines.map((line, i) => {\n        const lineIndent = i === 0 ? indent : 0;\n        const style = line.runs?.[0]?.attributes || {};\n        const height$1 = Math.max(height(line), style.lineHeight);\n        if (currentY + height$1 > rect.y + rect.height && rects.length > 0) {\n            rect = rects.shift();\n            currentY = rect.y;\n        }\n        const newLine = {\n            string: line.string,\n            runs: line.runs,\n            box: {\n                x: rect.x + lineIndent,\n                y: currentY,\n                width: rect.width - lineIndent,\n                height: height$1,\n            },\n        };\n        currentY += height$1;\n        return purgeAttachments(newLine);\n    });\n};\n/**\n * Performs line breaking and layout\n *\n * @param engines - Engines\n * @param options - Layout options\n */\nconst layoutParagraph = (engines, options = {}) => {\n    /**\n     * @param container - Container\n     * @param paragraph - Attributed string\n     * @returns Layout block\n     */\n    return (container, paragraph) => {\n        const height$1 = height(paragraph);\n        const indent = paragraph.runs?.[0]?.attributes?.indent || 0;\n        const rects = generateLineRects(container, height$1);\n        const availableWidths = rects.map((r) => r.width);\n        availableWidths.unshift(availableWidths[0] - indent);\n        const lines = engines.linebreaker(options)(paragraph, availableWidths);\n        return layoutLines(rects, lines, indent);\n    };\n};\n\n/**\n * Slice block at given height\n *\n * @param height - Height\n * @param paragraph - Paragraph\n * @returns Sliced paragraph\n */\nconst sliceAtHeight = (height, paragraph) => {\n    const newBlock = [];\n    let counter = 0;\n    for (let i = 0; i < paragraph.length; i += 1) {\n        const line = paragraph[i];\n        counter += line.box.height;\n        if (counter < height) {\n            newBlock.push(line);\n        }\n        else {\n            break;\n        }\n    }\n    return newBlock;\n};\n\n/**\n * Layout paragraphs inside container until it does not\n * fit anymore, performing line wrapping in the process.\n *\n * @param  engines - Engines\n * @param  options - Layout options\n * @param container - Container\n */\nconst typesetter = (engines, options, container) => {\n    /**\n     * @param attributedStrings - Attributed strings (paragraphs)\n     * @returns Paragraph blocks\n     */\n    return (attributedStrings) => {\n        const result = [];\n        const paragraphs = [...attributedStrings];\n        const layout = layoutParagraph(engines, options);\n        const maxLines = isNil(container.maxLines) ? Infinity : container.maxLines;\n        const truncateEllipsis = container.truncateMode === 'ellipsis';\n        let linesCount = maxLines;\n        let paragraphRect = copy(container);\n        let nextParagraph = paragraphs.shift();\n        while (linesCount > 0 && nextParagraph) {\n            const paragraph = layout(paragraphRect, nextParagraph);\n            const slicedBlock = paragraph.slice(0, linesCount);\n            const linesHeight = height$2(slicedBlock);\n            const shouldTruncate = truncateEllipsis && paragraph.length !== slicedBlock.length;\n            linesCount -= slicedBlock.length;\n            if (paragraphRect.height >= linesHeight) {\n                result.push(shouldTruncate ? truncate(slicedBlock) : slicedBlock);\n                paragraphRect = crop(linesHeight, paragraphRect);\n                nextParagraph = paragraphs.shift();\n            }\n            else {\n                result.push(truncate(sliceAtHeight(paragraphRect.height, slicedBlock)));\n                break;\n            }\n        }\n        return result;\n    };\n};\n\n/**\n * Get attributed string start value\n *\n * @param attributedString - Attributed string\n * @returns Start\n */\nconst start = (attributedString) => {\n    const { runs } = attributedString;\n    return runs.length === 0 ? 0 : runs[0].start;\n};\n\n/**\n * Get attributed string end value\n *\n * @param attributedString - Attributed string\n * @returns End\n */\nconst end = (attributedString) => {\n    const { runs } = attributedString;\n    return runs.length === 0 ? 0 : last(runs).end;\n};\n\n/**\n * Get attributed string length\n *\n * @param attributedString - Attributed string\n * @returns End\n */\nconst length$1 = (attributedString) => {\n    return end(attributedString) - start(attributedString);\n};\n\nconst bidi$2 = bidiFactory();\nconst getBidiLevels$1 = (runs) => {\n    return runs.reduce((acc, run) => {\n        const length = run.end - run.start;\n        const levels = repeat(run.attributes.bidiLevel, length);\n        return acc.concat(levels);\n    }, []);\n};\nconst getReorderedIndices = (string, segments) => {\n    // Fill an array with indices\n    const indices = [];\n    for (let i = 0; i < string.length; i += 1) {\n        indices[i] = i;\n    }\n    // Reverse each segment in order\n    segments.forEach(([start, end]) => {\n        const slice = indices.slice(start, end + 1);\n        for (let i = slice.length - 1; i >= 0; i -= 1) {\n            indices[end - i] = slice[i];\n        }\n    });\n    return indices;\n};\nconst getItemAtIndex = (runs, objectName, index) => {\n    for (let i = 0; i < runs.length; i += 1) {\n        const run = runs[i];\n        const updatedIndex = run.glyphIndices[index - run.start];\n        if (index >= run.start && index < run.end) {\n            return run[objectName][updatedIndex];\n        }\n    }\n    throw new Error(`index ${index} out of range`);\n};\nconst reorderLine = (line) => {\n    const levels = getBidiLevels$1(line.runs);\n    const direction = line.runs[0]?.attributes.direction;\n    const level = direction === 'rtl' ? 1 : 0;\n    const end = length$1(line) - 1;\n    const paragraphs = [{ start: 0, end, level }];\n    const embeddingLevels = { paragraphs, levels };\n    const segments = bidi$2.getReorderSegments(line.string, embeddingLevels);\n    // No need for bidi reordering\n    if (segments.length === 0)\n        return line;\n    const indices = getReorderedIndices(line.string, segments);\n    const updatedString = bidi$2.getReorderedString(line.string, embeddingLevels);\n    const updatedRuns = line.runs.map((run) => {\n        const selectedIndices = indices.slice(run.start, run.end);\n        const updatedGlyphs = [];\n        const updatedPositions = [];\n        const addedGlyphs = new Set();\n        for (let i = 0; i < selectedIndices.length; i += 1) {\n            const index = selectedIndices[i];\n            const glyph = getItemAtIndex(line.runs, 'glyphs', index);\n            if (addedGlyphs.has(glyph.id))\n                continue;\n            updatedGlyphs.push(glyph);\n            updatedPositions.push(getItemAtIndex(line.runs, 'positions', index));\n            if (glyph.isLigature) {\n                addedGlyphs.add(glyph.id);\n            }\n        }\n        return {\n            ...run,\n            glyphs: updatedGlyphs,\n            positions: updatedPositions,\n        };\n    });\n    return {\n        box: line.box,\n        runs: updatedRuns,\n        string: updatedString,\n    };\n};\nconst reorderParagraph = (paragraph) => paragraph.map(reorderLine);\n/**\n * Perform bidi reordering\n *\n * @returns Reordered paragraphs\n */\nconst bidiReordering = () => {\n    /**\n     * @param paragraphs - Paragraphs\n     * @returns Reordered paragraphs\n     */\n    return (paragraphs) => paragraphs.map(reorderParagraph);\n};\n\nconst DUMMY_CODEPOINT = 123;\n/**\n * Resolve string indices based on glyphs code points\n *\n * @param glyphs\n * @returns Glyph indices\n */\nconst resolve = (glyphs = []) => {\n    return glyphs.reduce((acc, glyph) => {\n        const codePoints = glyph?.codePoints || [DUMMY_CODEPOINT];\n        if (acc.length === 0)\n            return codePoints.map(() => 0);\n        const last = acc[acc.length - 1];\n        const next = codePoints.map(() => last + 1);\n        return [...acc, ...next];\n    }, []);\n};\n\nconst getCharacterSpacing = (run) => {\n    return run.attributes?.characterSpacing || 0;\n};\n/**\n * Scale run positions\n *\n * @param  run\n * @param  positions\n * @returns Scaled positions\n */\nconst scalePositions = (run, positions) => {\n    const runScale = scale(run);\n    const characterSpacing = getCharacterSpacing(run);\n    return positions.map((position, i) => {\n        const isLast = i === positions.length;\n        const xSpacing = isLast ? 0 : characterSpacing;\n        return Object.assign({}, position, {\n            xAdvance: position.xAdvance * runScale + xSpacing,\n            yAdvance: position.yAdvance * runScale,\n            xOffset: position.xOffset * runScale,\n            yOffset: position.yOffset * runScale,\n        });\n    });\n};\n/**\n * Create glyph run\n *\n * @param string string\n */\nconst layoutRun = (string) => {\n    /**\n     * @param run - Run\n     * @returns Glyph run\n     */\n    return (run) => {\n        const { start, end, attributes = {} } = run;\n        const { font } = attributes;\n        if (!font)\n            return { ...run, glyphs: [], glyphIndices: [], positions: [] };\n        const runString = string.slice(start, end);\n        if (typeof font === 'string')\n            throw new Error('Invalid font');\n        // passing LTR To force fontkit to not reverse the string\n        const glyphRun = font[0].layout(runString, undefined, undefined, undefined, 'ltr');\n        const positions = scalePositions(run, glyphRun.positions);\n        const glyphIndices = resolve(glyphRun.glyphs);\n        const result = {\n            ...run,\n            positions,\n            glyphIndices,\n            glyphs: glyphRun.glyphs,\n        };\n        return result;\n    };\n};\n/**\n * Generate glyphs for single attributed string\n */\nconst generateGlyphs = () => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Attributed string with glyphs\n     */\n    return (attributedString) => {\n        const runs = attributedString.runs.map(layoutRun(attributedString.string));\n        const res = Object.assign({}, attributedString, { runs });\n        return res;\n    };\n};\n\n/**\n * Resolves yOffset for run\n *\n * @param run - Run\n * @returns Run\n */\nconst resolveRunYOffset = (run) => {\n    if (!run.positions)\n        return run;\n    const unitsPerEm = run.attributes?.font?.[0]?.unitsPerEm || 0;\n    const yOffset = (run.attributes?.yOffset || 0) * unitsPerEm;\n    const positions = run.positions.map((p) => Object.assign({}, p, { yOffset }));\n    return Object.assign({}, run, { positions });\n};\n/**\n * Resolves yOffset for multiple paragraphs\n */\nconst resolveYOffset = () => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Attributed string\n     */\n    return (attributedString) => {\n        const runs = attributedString.runs.map(resolveRunYOffset);\n        const res = Object.assign({}, attributedString, { runs });\n        return res;\n    };\n};\n\n/**\n * Sort runs in ascending order\n *\n * @param runs\n * @returns Sorted runs\n */\nconst sort = (runs) => {\n    return runs.sort((a, b) => a.start - b.start || a.end - b.end);\n};\n\n/**\n * Is run empty (start === end)\n *\n * @param run - Run\n * @returns Is run empty\n */\nconst isEmpty = (run) => {\n    return run.start === run.end;\n};\n\n/**\n * Sort points in ascending order\n * @param a - First point\n * @param b - Second point\n * @returns Sort order\n */\nconst sortPoints = (a, b) => {\n    return a[1] - b[1] || a[3] - b[3];\n};\n/**\n * @param runs\n * @returns Points\n */\nconst generatePoints = (runs) => {\n    const result = runs.reduce((acc, run, i) => {\n        return acc.concat([\n            ['start', run.start, run.attributes, i],\n            ['end', run.end, run.attributes, i],\n        ]);\n    }, []);\n    return result.sort(sortPoints);\n};\n/**\n * @param runs\n * @returns Merged runs\n */\nconst mergeRuns = (runs) => {\n    return runs.reduce((acc, run) => {\n        const attributes = Object.assign({}, acc.attributes, run.attributes);\n        return Object.assign({}, run, { attributes });\n    }, {});\n};\n/**\n * @param runs\n * @returns Grouped runs\n */\nconst groupEmptyRuns = (runs) => {\n    const groups = runs.reduce((acc, run) => {\n        if (!acc[run.start])\n            acc[run.start] = [];\n        acc[run.start].push(run);\n        return acc;\n    }, []);\n    return Object.values(groups);\n};\n/**\n * @param runs\n * @returns Flattened runs\n */\nconst flattenEmptyRuns = (runs) => {\n    return groupEmptyRuns(runs).map(mergeRuns);\n};\n/**\n * @param runs\n * @returns Flattened runs\n */\nconst flattenRegularRuns = (runs) => {\n    const res = [];\n    const points = generatePoints(runs);\n    let start = -1;\n    let attrs = {};\n    const stack = [];\n    for (let i = 0; i < points.length; i += 1) {\n        const [type, offset, attributes] = points[i];\n        if (start !== -1 && start < offset) {\n            res.push({\n                start,\n                end: offset,\n                attributes: attrs,\n                glyphIndices: [],\n                glyphs: [],\n                positions: [],\n            });\n        }\n        if (type === 'start') {\n            stack.push(attributes);\n            attrs = Object.assign({}, attrs, attributes);\n        }\n        else {\n            attrs = {};\n            for (let j = 0; j < stack.length; j += 1) {\n                if (stack[j] === attributes) {\n                    stack.splice(j--, 1);\n                }\n                else {\n                    attrs = Object.assign({}, attrs, stack[j]);\n                }\n            }\n        }\n        start = offset;\n    }\n    return res;\n};\n/**\n * Flatten many runs\n *\n * @param runs\n * @returns Flattened runs\n */\nconst flatten = (runs = []) => {\n    const emptyRuns = flattenEmptyRuns(runs.filter((run) => isEmpty(run)));\n    const regularRuns = flattenRegularRuns(runs.filter((run) => !isEmpty(run)));\n    return sort(emptyRuns.concat(regularRuns));\n};\n\n/**\n * Returns empty attributed string\n *\n * @returns Empty attributed string\n */\nconst empty = () => ({ string: '', runs: [] });\n\n/**\n *\n * @param attributedString\n * @returns Attributed string without font\n */\nconst omitFont = (attributedString) => {\n    const runs = attributedString.runs.map((run) => omit('font', run));\n    return Object.assign({}, attributedString, { runs });\n};\n/**\n * Performs font substitution and script itemization on attributed string\n *\n * @param engines - engines\n */\nconst preprocessRuns = (engines) => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Processed attributed string\n     */\n    return (attributedString) => {\n        if (isNil(attributedString))\n            return empty();\n        const { string } = attributedString;\n        const { fontSubstitution, scriptItemizer, bidi } = engines;\n        const { runs: omittedFontRuns } = omitFont(attributedString);\n        const { runs: itemizationRuns } = scriptItemizer()(attributedString);\n        const { runs: substitutedRuns } = fontSubstitution()(attributedString);\n        const { runs: bidiRuns } = bidi()(attributedString);\n        const runs = bidiRuns\n            .concat(substitutedRuns)\n            .concat(itemizationRuns)\n            .concat(omittedFontRuns);\n        return { string, runs: flatten(runs) };\n    };\n};\n\n/**\n * Breaks attributed string into paragraphs\n */\nconst splitParagraphs = () => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Paragraphs attributed strings\n     */\n    return (attributedString) => {\n        const paragraphs = [];\n        let start = 0;\n        let breakPoint = attributedString.string.indexOf('\\n') + 1;\n        while (breakPoint > 0) {\n            paragraphs.push(slice(start, breakPoint, attributedString));\n            start = breakPoint;\n            breakPoint = attributedString.string.indexOf('\\n', breakPoint) + 1;\n        }\n        if (start === 0) {\n            paragraphs.push(attributedString);\n        }\n        else if (start < attributedString.string.length) {\n            paragraphs.push(slice(start, length$1(attributedString), attributedString));\n        }\n        return paragraphs;\n    };\n};\n\n/**\n * Return positions advance width\n *\n * @param positions - Positions\n * @returns {number} advance width\n */\nconst advanceWidth$2 = (positions) => {\n    return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);\n};\n\n/**\n * Return run advance width\n *\n * @param run - Run\n * @returns Advance width\n */\nconst advanceWidth$1 = (run) => {\n    return advanceWidth$2(run.positions || []);\n};\n\n/**\n * Returns attributed string advancewidth\n *\n * @param attributedString - Attributed string\n * @returns Advance width\n */\nconst advanceWidth = (attributedString) => {\n    const reducer = (acc, run) => acc + advanceWidth$1(run);\n    return attributedString.runs.reduce(reducer, 0);\n};\n\nconst WHITE_SPACES_CODE = 32;\n/**\n * Check if glyph is white space\n *\n * @param glyph - Glyph\n * @returns Whether glyph is white space\n * */\nconst isWhiteSpace = (glyph) => {\n    const codePoints = glyph?.codePoints || [];\n    return codePoints.includes(WHITE_SPACES_CODE);\n};\n\n/**\n * Get white space leading positions\n *\n * @param run - Run\n * @returns White space leading positions\n */\nconst leadingPositions = (run) => {\n    const glyphs = run.glyphs || [];\n    const positions = run.positions || [];\n    const leadingWhitespaces = glyphs.findIndex((g) => !isWhiteSpace(g));\n    return positions.slice(0, leadingWhitespaces);\n};\n/**\n * Get run leading white space offset\n *\n * @param run - Run\n * @returns Leading white space offset\n */\nconst leadingOffset$1 = (run) => {\n    const positions = leadingPositions(run);\n    return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);\n};\n\n/**\n * Get attributed string leading white space offset\n *\n * @param attributedString - Attributed string\n * @returns Leading white space offset\n */\nconst leadingOffset = (attributedString) => {\n    const runs = attributedString.runs || [];\n    return leadingOffset$1(runs[0]);\n};\n\n/**\n * Get white space trailing positions\n *\n * @param run run\n * @returns White space trailing positions\n */\nconst trailingPositions = (run) => {\n    const glyphs = reverse(run.glyphs || []);\n    const positions = reverse(run.positions || []);\n    const leadingWhitespaces = glyphs.findIndex((g) => !isWhiteSpace(g));\n    return positions.slice(0, leadingWhitespaces);\n};\n/**\n * Get run trailing white space offset\n *\n * @param run - Run\n * @returns Trailing white space offset\n */\nconst trailingOffset$1 = (run) => {\n    const positions = trailingPositions(run);\n    return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);\n};\n\n/**\n * Get attributed string trailing white space offset\n *\n * @param attributedString - Attributed string\n * @returns Trailing white space offset\n */\nconst trailingOffset = (attributedString) => {\n    const runs = attributedString.runs || [];\n    return trailingOffset$1(last(runs));\n};\n\n/**\n * Drop last char of run\n *\n * @param run - Run\n * @returns Run without last char\n */\nconst dropLast$1 = (run) => {\n    return slice$1(0, run.end - run.start - 1, run);\n};\n\n/**\n * Drop last glyph\n *\n * @param attributedString - Attributed string\n * @returns Attributed string with new glyph\n */\nconst dropLast = (attributedString) => {\n    const string = dropLast$2(attributedString.string);\n    const runs = adjust(-1, dropLast$1, attributedString.runs);\n    return Object.assign({}, attributedString, { string, runs });\n};\n\nconst ALIGNMENT_FACTORS = { center: 0.5, right: 1 };\n/**\n * Remove new line char at the end of line if present\n *\n * @param line\n * @returns Line\n */\nconst removeNewLine = (line) => {\n    return last(line.string) === '\\n' ? dropLast(line) : line;\n};\nconst getOverflowLeft = (line) => {\n    return leadingOffset(line) + (line.overflowLeft || 0);\n};\nconst getOverflowRight = (line) => {\n    return trailingOffset(line) + (line.overflowRight || 0);\n};\n/**\n * Ignore whitespace at the start and end of a line for alignment\n *\n * @param line\n * @returns Line\n */\nconst adjustOverflow = (line) => {\n    const overflowLeft = getOverflowLeft(line);\n    const overflowRight = getOverflowRight(line);\n    const x = line.box.x - overflowLeft;\n    const width = line.box.width + overflowLeft + overflowRight;\n    const box = Object.assign({}, line.box, { x, width });\n    return Object.assign({}, line, { box, overflowLeft, overflowRight });\n};\n/**\n * Performs line justification by calling appropiate engine\n *\n * @param engines - Engines\n * @param options - Layout options\n * @param align - Text align\n */\nconst justifyLine$1 = (engines, options, align) => {\n    /**\n     * @param line - Line\n     * @returns Line\n     */\n    return (line) => {\n        const lineWidth = advanceWidth(line);\n        const alignFactor = ALIGNMENT_FACTORS[align] || 0;\n        const remainingWidth = Math.max(0, line.box.width - lineWidth);\n        const shouldJustify = align === 'justify' || lineWidth > line.box.width;\n        const x = line.box.x + remainingWidth * alignFactor;\n        const box = Object.assign({}, line.box, { x });\n        const newLine = Object.assign({}, line, { box });\n        return shouldJustify ? engines.justification(options)(newLine) : newLine;\n    };\n};\nconst finalizeLine = (line) => {\n    let lineAscent = 0;\n    let lineDescent = 0;\n    let lineHeight = 0;\n    let lineXAdvance = 0;\n    const runs = line.runs.map((run) => {\n        const height = height$1(run);\n        const ascent = ascent$1(run);\n        const descent$1 = descent(run);\n        const xAdvance = advanceWidth$1(run);\n        lineHeight = Math.max(lineHeight, height);\n        lineAscent = Math.max(lineAscent, ascent);\n        lineDescent = Math.max(lineDescent, descent$1);\n        lineXAdvance += xAdvance;\n        return Object.assign({}, run, { height, ascent, descent: descent$1, xAdvance });\n    });\n    return Object.assign({}, line, {\n        runs,\n        height: lineHeight,\n        ascent: lineAscent,\n        descent: lineDescent,\n        xAdvance: lineXAdvance,\n    });\n};\n/**\n * Finalize line by performing line justification\n * and text decoration (using appropiate engines)\n *\n * @param engines - Engines\n * @param options - Layout options\n */\nconst finalizeBlock = (engines, options) => {\n    /**\n     * @param line - Line\n     * @param i - Line index\n     * @param lines - Total lines\n     * @returns Line\n     */\n    return (line, index, lines) => {\n        const isLastFragment = index === lines.length - 1;\n        const style = line.runs?.[0]?.attributes || {};\n        const align = isLastFragment ? style.alignLastLine : style.align;\n        return compose(finalizeLine, engines.textDecoration(), justifyLine$1(engines, options, align), adjustOverflow, removeNewLine)(line);\n    };\n};\n/**\n * Finalize line block by performing line justification\n * and text decoration (using appropiate engines)\n *\n * @param engines - Engines\n * @param options - Layout options\n */\nconst finalizeFragments = (engines, options) => {\n    /**\n     * @param paragraphs - Paragraphs\n     * @returns Paragraphs\n     */\n    return (paragraphs) => {\n        const blockFinalizer = finalizeBlock(engines, options);\n        return paragraphs.map((paragraph) => paragraph.map(blockFinalizer));\n    };\n};\n\nconst ATTACHMENT_CODE = 0xfffc; // 65532\nconst isReplaceGlyph = (glyph) => glyph.codePoints.includes(ATTACHMENT_CODE);\n/**\n * Resolve attachments of run\n *\n * @param run\n * @returns Run\n */\nconst resolveRunAttachments = (run) => {\n    if (!run.positions)\n        return run;\n    const glyphs = run.glyphs || [];\n    const attachment = run.attributes?.attachment;\n    if (!attachment)\n        return run;\n    const positions = run.positions.map((position, i) => {\n        const glyph = glyphs[i];\n        if (attachment.width && isReplaceGlyph(glyph)) {\n            return Object.assign({}, position, { xAdvance: attachment.width });\n        }\n        return Object.assign({}, position);\n    });\n    return Object.assign({}, run, { positions });\n};\n/**\n * Resolve attachments for multiple paragraphs\n */\nconst resolveAttachments = () => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Attributed string\n     */\n    return (attributedString) => {\n        const runs = attributedString.runs.map(resolveRunAttachments);\n        const res = Object.assign({}, attributedString, { runs });\n        return res;\n    };\n};\n\n/**\n * @param attributes - Attributes\n * @returns Attributes with defaults\n */\nconst applyAttributes = (a) => {\n    return {\n        align: a.align || (a.direction === 'rtl' ? 'right' : 'left'),\n        alignLastLine: a.alignLastLine || (a.align === 'justify' ? 'left' : a.align || 'left'),\n        attachment: a.attachment || null,\n        backgroundColor: a.backgroundColor || null,\n        bullet: a.bullet || null,\n        characterSpacing: a.characterSpacing || 0,\n        color: a.color || 'black',\n        direction: a.direction || 'ltr',\n        features: a.features || [],\n        fill: a.fill !== false,\n        font: a.font || [],\n        fontSize: a.fontSize || 12,\n        hangingPunctuation: a.hangingPunctuation || false,\n        hyphenationFactor: a.hyphenationFactor || 0,\n        indent: a.indent || 0,\n        justificationFactor: a.justificationFactor || 1,\n        lineHeight: a.lineHeight || null,\n        lineSpacing: a.lineSpacing || 0,\n        link: a.link || null,\n        marginLeft: a.marginLeft || a.margin || 0,\n        marginRight: a.marginRight || a.margin || 0,\n        opacity: a.opacity,\n        paddingTop: a.paddingTop || a.padding || 0,\n        paragraphSpacing: a.paragraphSpacing || 0,\n        script: a.script || null,\n        shrinkFactor: a.shrinkFactor || 0,\n        strike: a.strike || false,\n        strikeColor: a.strikeColor || a.color || 'black',\n        strikeStyle: a.strikeStyle || 'solid',\n        stroke: a.stroke || false,\n        underline: a.underline || false,\n        underlineColor: a.underlineColor || a.color || 'black',\n        underlineStyle: a.underlineStyle || 'solid',\n        verticalAlign: a.verticalAlign || null,\n        wordSpacing: a.wordSpacing || 0,\n        yOffset: a.yOffset || 0,\n    };\n};\n/**\n * Apply default style to run\n *\n * @param run - Run\n * @returns Run with default styles\n */\nconst applyRunStyles = (run) => {\n    const attributes = applyAttributes(run.attributes);\n    return Object.assign({}, run, { attributes });\n};\n/**\n * Apply default attributes for an attributed string\n */\nconst applyDefaultStyles = () => {\n    return (attributedString) => {\n        const string = attributedString.string || '';\n        const runs = (attributedString.runs || []).map(applyRunStyles);\n        return { string, runs };\n    };\n};\n\n/**\n * Apply scaling and yOffset for verticalAlign 'sub' and 'super'.\n */\nconst verticalAlignment = () => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Attributed string\n     */\n    return (attributedString) => {\n        attributedString.runs.forEach((run) => {\n            const { attributes } = run;\n            const { verticalAlign } = attributes;\n            if (verticalAlign === 'sub') {\n                attributes.yOffset = -0.2;\n            }\n            else if (verticalAlign === 'super') {\n                attributes.yOffset = 0.4;\n            }\n        });\n        return attributedString;\n    };\n};\n\nconst bidi$1 = bidiFactory();\n/**\n * @param runs\n * @returns Bidi levels\n */\nconst getBidiLevels = (runs) => {\n    return runs.reduce((acc, run) => {\n        const length = run.end - run.start;\n        const levels = repeat(run.attributes.bidiLevel, length);\n        return acc.concat(levels);\n    }, []);\n};\n/**\n * Perform bidi mirroring\n */\nconst mirrorString = () => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Attributed string\n     */\n    return (attributedString) => {\n        const levels = getBidiLevels(attributedString.runs);\n        let updatedString = '';\n        attributedString.string.split('').forEach((char, index) => {\n            const isRTL = levels[index] % 2 === 1;\n            const mirroredChar = isRTL\n                ? bidi$1.getMirroredCharacter(attributedString.string.charAt(index))\n                : null;\n            updatedString += mirroredChar || char;\n        });\n        const result = {\n            ...attributedString,\n            string: updatedString,\n        };\n        return result;\n    };\n};\n\n/**\n * A LayoutEngine is the main object that performs text layout.\n * It accepts an AttributedString and a Container object\n * to layout text into, and uses several helper objects to perform\n * various layout tasks. These objects can be overridden to customize\n * layout behavior.\n */\nconst layoutEngine = (engines) => {\n    return (attributedString, container, options = {}) => {\n        const processParagraph = compose(resolveYOffset(), resolveAttachments(), verticalAlignment(), wrapWords(engines, options), generateGlyphs(), mirrorString(), preprocessRuns(engines));\n        const processParagraphs = (paragraphs) => paragraphs.map(processParagraph);\n        return compose(finalizeFragments(engines, options), bidiReordering(), typesetter(engines, options, container), processParagraphs, splitParagraphs(), applyDefaultStyles())(attributedString);\n    };\n};\n\nconst bidi = bidiFactory();\nconst bidiEngine = () => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Attributed string\n     */\n    return (attributedString) => {\n        const { string } = attributedString;\n        const direction = attributedString.runs[0]?.attributes.direction;\n        const { levels } = bidi.getEmbeddingLevels(string, direction);\n        let lastLevel = null;\n        let lastIndex = 0;\n        let index = 0;\n        const runs = [];\n        for (let i = 0; i < levels.length; i += 1) {\n            const level = levels[i];\n            if (level !== lastLevel) {\n                if (lastLevel !== null) {\n                    runs.push({\n                        start: lastIndex,\n                        end: index,\n                        attributes: { bidiLevel: lastLevel },\n                    });\n                }\n                lastIndex = index;\n                lastLevel = level;\n            }\n            index += 1;\n        }\n        if (lastIndex < string.length) {\n            runs.push({\n                start: lastIndex,\n                end: string.length,\n                attributes: { bidiLevel: lastLevel },\n            });\n        }\n        const result = { string, runs };\n        return result;\n    };\n};\n\nconst INFINITY = 10000;\nconst getNextBreakpoint = (subnodes, widths, lineNumber) => {\n    let position = null;\n    let minimumBadness = Infinity;\n    const sum = { width: 0, stretch: 0, shrink: 0 };\n    const lineLength = widths[Math.min(lineNumber, widths.length - 1)];\n    const calculateRatio = (node) => {\n        const stretch = 'stretch' in node ? node.stretch : null;\n        if (sum.width < lineLength) {\n            if (!stretch)\n                return INFINITY;\n            return sum.stretch - stretch > 0\n                ? (lineLength - sum.width) / sum.stretch\n                : INFINITY;\n        }\n        const shrink = 'shrink' in node ? node.shrink : null;\n        if (sum.width > lineLength) {\n            if (!shrink)\n                return INFINITY;\n            return sum.shrink - shrink > 0\n                ? (lineLength - sum.width) / sum.shrink\n                : INFINITY;\n        }\n        return 0;\n    };\n    for (let i = 0; i < subnodes.length; i += 1) {\n        const node = subnodes[i];\n        if (node.type === 'box') {\n            sum.width += node.width;\n        }\n        if (node.type === 'glue') {\n            sum.width += node.width;\n            sum.stretch += node.stretch;\n            sum.shrink += node.shrink;\n        }\n        if (sum.width - sum.shrink > lineLength) {\n            if (position === null) {\n                let j = i === 0 ? i + 1 : i;\n                while (j < subnodes.length &&\n                    (subnodes[j].type === 'glue' || subnodes[j].type === 'penalty')) {\n                    j++;\n                }\n                position = j - 1;\n            }\n            break;\n        }\n        if (node.type === 'penalty' || node.type === 'glue') {\n            const ratio = calculateRatio(node);\n            const penalty = node.type === 'penalty' ? node.penalty : 0;\n            const badness = 100 * Math.abs(ratio) ** 3 + penalty;\n            if (minimumBadness >= badness) {\n                position = i;\n                minimumBadness = badness;\n            }\n        }\n    }\n    return sum.width - sum.shrink > lineLength ? position : null;\n};\nconst applyBestFit = (nodes, widths) => {\n    let count = 0;\n    let lineNumber = 0;\n    let subnodes = nodes;\n    const breakpoints = [0];\n    while (subnodes.length > 0) {\n        const breakpoint = getNextBreakpoint(subnodes, widths, lineNumber);\n        if (breakpoint !== null) {\n            count += breakpoint;\n            breakpoints.push(count);\n            subnodes = subnodes.slice(breakpoint + 1, subnodes.length);\n            count++;\n            lineNumber++;\n        }\n        else {\n            subnodes = [];\n        }\n    }\n    return breakpoints;\n};\n\n/* eslint-disable max-classes-per-file */\nclass LinkedListNode {\n    data;\n    prev;\n    next;\n    constructor(data) {\n        this.data = data;\n        this.prev = null;\n        this.next = null;\n    }\n}\nclass LinkedList {\n    static Node = LinkedListNode;\n    head;\n    tail;\n    listSize;\n    listLength;\n    constructor() {\n        this.head = null;\n        this.tail = null;\n        this.listSize = 0;\n        this.listLength = 0;\n    }\n    isLinked(node) {\n        return !((node &&\n            node.prev === null &&\n            node.next === null &&\n            this.tail !== node &&\n            this.head !== node) ||\n            this.isEmpty());\n    }\n    size() {\n        return this.listSize;\n    }\n    isEmpty() {\n        return this.listSize === 0;\n    }\n    first() {\n        return this.head;\n    }\n    last() {\n        return this.last;\n    }\n    forEach(callback) {\n        let node = this.head;\n        while (node !== null) {\n            callback(node);\n            node = node.next;\n        }\n    }\n    at(i) {\n        let node = this.head;\n        let index = 0;\n        if (i >= this.listLength || i < 0) {\n            return null;\n        }\n        while (node !== null) {\n            if (i === index) {\n                return node;\n            }\n            node = node.next;\n            index += 1;\n        }\n        return null;\n    }\n    insertAfter(node, newNode) {\n        if (!this.isLinked(node))\n            return this;\n        newNode.prev = node;\n        newNode.next = node.next;\n        if (node.next === null) {\n            this.tail = newNode;\n        }\n        else {\n            node.next.prev = newNode;\n        }\n        node.next = newNode;\n        this.listSize += 1;\n        return this;\n    }\n    insertBefore(node, newNode) {\n        if (!this.isLinked(node))\n            return this;\n        newNode.prev = node.prev;\n        newNode.next = node;\n        if (node.prev === null) {\n            this.head = newNode;\n        }\n        else {\n            node.prev.next = newNode;\n        }\n        node.prev = newNode;\n        this.listSize += 1;\n        return this;\n    }\n    push(node) {\n        if (this.head === null) {\n            this.unshift(node);\n        }\n        else {\n            this.insertAfter(this.tail, node);\n        }\n        return this;\n    }\n    unshift(node) {\n        if (this.head === null) {\n            this.head = node;\n            this.tail = node;\n            node.prev = null;\n            node.next = null;\n            this.listSize += 1;\n        }\n        else {\n            this.insertBefore(this.head, node);\n        }\n        return this;\n    }\n    remove(node) {\n        if (!this.isLinked(node))\n            return this;\n        if (node.prev === null) {\n            this.head = node.next;\n        }\n        else {\n            node.prev.next = node.next;\n        }\n        if (node.next === null) {\n            this.tail = node.prev;\n        }\n        else {\n            node.next.prev = node.prev;\n        }\n        this.listSize -= 1;\n        return this;\n    }\n}\n\n/**\n * Licensed under the new BSD License.\n * Copyright 2009-2010, Bram Stein\n * All rights reserved.\n */\nfunction breakpoint(position, demerits, line, fitnessClass, totals, previous) {\n    return {\n        position,\n        demerits,\n        line,\n        fitnessClass,\n        totals: totals || {\n            width: 0,\n            stretch: 0,\n            shrink: 0,\n        },\n        previous,\n    };\n}\nfunction computeCost(nodes, lineLengths, sum, end, active, currentLine) {\n    let width = sum.width - active.totals.width;\n    let stretch = 0;\n    let shrink = 0;\n    // If the current line index is within the list of linelengths, use it, otherwise use\n    // the last line length of the list.\n    const lineLength = currentLine < lineLengths.length\n        ? lineLengths[currentLine - 1]\n        : lineLengths[lineLengths.length - 1];\n    if (nodes[end].type === 'penalty') {\n        width += nodes[end].width;\n    }\n    // Calculate the stretch ratio\n    if (width < lineLength) {\n        stretch = sum.stretch - active.totals.stretch;\n        if (stretch > 0) {\n            return (lineLength - width) / stretch;\n        }\n        return linebreak.infinity;\n    }\n    // Calculate the shrink ratio\n    if (width > lineLength) {\n        shrink = sum.shrink - active.totals.shrink;\n        if (shrink > 0) {\n            return (lineLength - width) / shrink;\n        }\n        return linebreak.infinity;\n    }\n    // perfect match\n    return 0;\n}\n// Add width, stretch and shrink values from the current\n// break point up to the next box or forced penalty.\nfunction computeSum(nodes, sum, breakPointIndex) {\n    const result = {\n        width: sum.width,\n        stretch: sum.stretch,\n        shrink: sum.shrink,\n    };\n    for (let i = breakPointIndex; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.type === 'glue') {\n            result.width += node.width;\n            result.stretch += node.stretch;\n            result.shrink += node.shrink;\n        }\n        else if (node.type === 'box' ||\n            (node.type === 'penalty' &&\n                node.penalty === -linebreak.infinity &&\n                i > breakPointIndex)) {\n            break;\n        }\n    }\n    return result;\n}\nfunction findBestBreakpoints(activeNodes) {\n    const breakpoints = [];\n    if (activeNodes.size() === 0)\n        return [];\n    let tmp = { data: { demerits: Infinity } };\n    // Find the best active node (the one with the least total demerits.)\n    activeNodes.forEach((node) => {\n        if (node.data.demerits < tmp.data.demerits) {\n            tmp = node;\n        }\n    });\n    while (tmp !== null) {\n        breakpoints.push(tmp.data.position);\n        tmp = tmp.data.previous;\n    }\n    return breakpoints.reverse();\n}\n/**\n * @param nodes\n * @param availableWidths\n * @param tolerance\n * @preserve Knuth and Plass line breaking algorithm in JavaScript\n */\nconst linebreak = (nodes, availableWidths, tolerance) => {\n    // Demerits are used as a way to penalize bad line breaks\n    //  - line: applied to each line, depending on how much spaces need to stretch or shrink\n    //  - flagged: applied when consecutive lines end in hyphenation\n    //  - fitness: algorithm groups lines into fitness classes based on how loose or tight the spacing is.\n    //             if a paragraph has consecutive lines from different fitness classes,\n    //             a fitness demerit is applied to maintain visual consistency.\n    const options = {\n        demerits: { line: 10, flagged: 100, fitness: 3000 },\n        tolerance: tolerance || 3,\n    };\n    const activeNodes = new LinkedList();\n    const sum = { width: 0, stretch: 0, shrink: 0 };\n    const lineLengths = availableWidths;\n    // Add an active node for the start of the paragraph.\n    activeNodes.push(new LinkedList.Node(breakpoint(0, 0, 0, 0, undefined, null)));\n    // The main loop of the algorithm\n    function mainLoop(node, index, nodes) {\n        let active = activeNodes.first();\n        // The inner loop iterates through all the active nodes with line < currentLine and then\n        // breaks out to insert the new active node candidates before looking at the next active\n        // nodes for the next lines. The result of this is that the active node list is always\n        // sorted by line number.\n        while (active !== null) {\n            let currentLine = 0;\n            // Candidates fo each fitness class\n            const candidates = [\n                { active: undefined, demerits: Infinity },\n                { active: undefined, demerits: Infinity },\n                { active: undefined, demerits: Infinity },\n                { active: undefined, demerits: Infinity },\n            ];\n            // Iterate through the linked list of active nodes to find new potential active nodes and deactivate current active nodes.\n            while (active !== null) {\n                currentLine = active.data.line + 1;\n                const ratio = computeCost(nodes, lineLengths, sum, index, active.data, currentLine);\n                // Deactive nodes when the distance between the current active node and the\n                // current node becomes too large (i.e. it exceeds the stretch limit and the stretch\n                // ratio becomes negative) or when the current node is a forced break (i.e. the end\n                // of the paragraph when we want to remove all active nodes, but possibly have a final\n                // candidate active node---if the paragraph can be set using the given tolerance value.)\n                if (ratio < -1 ||\n                    (node.type === 'penalty' && node.penalty === -linebreak.infinity)) {\n                    activeNodes.remove(active);\n                }\n                // If the ratio is within the valid range of -1 <= ratio <= tolerance calculate the\n                // total demerits and record a candidate active node.\n                if (ratio >= -1 && ratio <= options.tolerance) {\n                    const badness = 100 * Math.pow(Math.abs(ratio), 3);\n                    let demerits = 0;\n                    // Positive penalty\n                    if (node.type === 'penalty' && node.penalty >= 0) {\n                        demerits =\n                            Math.pow(options.demerits.line + badness, 2) +\n                                Math.pow(node.penalty, 2);\n                        // Negative penalty but not a forced break\n                    }\n                    else if (node.type === 'penalty' &&\n                        node.penalty !== -linebreak.infinity) {\n                        demerits =\n                            Math.pow(options.demerits.line + badness, 2) -\n                                Math.pow(node.penalty, 2);\n                        // All other cases\n                    }\n                    else {\n                        demerits = Math.pow(options.demerits.line + badness, 2);\n                    }\n                    if (node.type === 'penalty' &&\n                        nodes[active.data.position].type === 'penalty') {\n                        demerits +=\n                            options.demerits.flagged *\n                                node.flagged *\n                                // @ts-expect-error node is penalty here\n                                nodes[active.data.position].flagged;\n                    }\n                    // Calculate the fitness class for this candidate active node.\n                    let currentClass;\n                    if (ratio < -0.5) {\n                        currentClass = 0;\n                    }\n                    else if (ratio <= 0.5) {\n                        currentClass = 1;\n                    }\n                    else if (ratio <= 1) {\n                        currentClass = 2;\n                    }\n                    else {\n                        currentClass = 3;\n                    }\n                    // Add a fitness penalty to the demerits if the fitness classes of two adjacent lines differ too much.\n                    if (Math.abs(currentClass - active.data.fitnessClass) > 1) {\n                        demerits += options.demerits.fitness;\n                    }\n                    // Add the total demerits of the active node to get the total demerits of this candidate node.\n                    demerits += active.data.demerits;\n                    // Only store the best candidate for each fitness class\n                    if (demerits < candidates[currentClass].demerits) {\n                        candidates[currentClass] = { active, demerits };\n                    }\n                }\n                active = active.next;\n                // Stop iterating through active nodes to insert new candidate active nodes in the active list\n                // before moving on to the active nodes for the next line.\n                // TODO: The Knuth and Plass paper suggests a conditional for currentLine < j0. This means paragraphs\n                // with identical line lengths will not be sorted by line number. Find out if that is a desirable outcome.\n                // For now I left this out, as it only adds minimal overhead to the algorithm and keeping the active node\n                // list sorted has a higher priority.\n                if (active !== null && active.data.line >= currentLine) {\n                    break;\n                }\n            }\n            const tmpSum = computeSum(nodes, sum, index);\n            for (let fitnessClass = 0; fitnessClass < candidates.length; fitnessClass += 1) {\n                const candidate = candidates[fitnessClass];\n                if (candidate.demerits === Infinity)\n                    continue;\n                const newNode = new LinkedList.Node(breakpoint(index, candidate.demerits, candidate.active.data.line + 1, fitnessClass, tmpSum, candidate.active));\n                if (active !== null) {\n                    activeNodes.insertBefore(active, newNode);\n                }\n                else {\n                    activeNodes.push(newNode);\n                }\n            }\n        }\n    }\n    nodes.forEach((node, index, nodes) => {\n        if (node.type === 'box') {\n            sum.width += node.width;\n            return;\n        }\n        if (node.type === 'glue') {\n            const precedesBox = index > 0 && nodes[index - 1].type === 'box';\n            if (precedesBox)\n                mainLoop(node, index, nodes);\n            sum.width += node.width;\n            sum.stretch += node.stretch;\n            sum.shrink += node.shrink;\n            return;\n        }\n        if (node.type === 'penalty' && node.penalty !== linebreak.infinity) {\n            mainLoop(node, index, nodes);\n        }\n    });\n    return findBestBreakpoints(activeNodes);\n};\nlinebreak.infinity = 10000;\nlinebreak.glue = (width, start, end, stretch, shrink) => ({\n    type: 'glue',\n    start,\n    end,\n    width,\n    stretch,\n    shrink,\n});\nlinebreak.box = (width, start, end, hyphenated = false) => ({\n    type: 'box',\n    width,\n    start,\n    end,\n    hyphenated,\n});\nlinebreak.penalty = (width, penalty, flagged) => ({\n    type: 'penalty',\n    width,\n    penalty,\n    flagged,\n});\n\n/**\n * Add scalar to run\n *\n * @param index - Scalar\n * @param run - Run\n * @returns Added run\n */\nconst add = (index, run) => {\n    const start = run.start + index;\n    const end = run.end + index;\n    return Object.assign({}, run, { start, end });\n};\n\n/**\n * Get run length\n *\n * @param run - Run\n * @returns Length\n */\nconst length = (run) => {\n    return run.end - run.start;\n};\n\n/**\n * Concats two runs into one\n *\n * @param runA - First run\n * @param runB - Second run\n * @returns Concatenated run\n */\nconst concat = (runA, runB) => {\n    const end = runA.end + length(runB);\n    const glyphs = (runA.glyphs || []).concat(runB.glyphs || []);\n    const positions = (runA.positions || []).concat(runB.positions || []);\n    const attributes = Object.assign({}, runA.attributes, runB.attributes);\n    const runAIndices = runA.glyphIndices || [];\n    const runALastIndex = last(runAIndices) || 0;\n    const runBIndices = (runB.glyphIndices || []).map((i) => i + runALastIndex + 1);\n    const glyphIndices = normalize(runAIndices.concat(runBIndices));\n    return Object.assign({}, runA, {\n        end,\n        glyphs,\n        positions,\n        attributes,\n        glyphIndices,\n    });\n};\n\n/**\n * Insert glyph to run in the given index\n *\n * @param index - Index\n * @param glyph - Glyph\n * @param run - Run\n * @returns Run with glyph\n */\nconst insertGlyph$1 = (index, glyph, run) => {\n    if (!glyph)\n        return run;\n    // Split resolves ligature splitting in case new glyph breaks some\n    const leadingRun = slice$1(0, index, run);\n    const trailingRun = slice$1(index, Infinity, run);\n    return concat(append$1(glyph, leadingRun), trailingRun);\n};\n/**\n * Insert either glyph or code point to run in the given index\n *\n * @param index - Index\n * @param value - Glyph or codePoint\n * @param run - Run\n * @returns Run with glyph\n */\nconst insert = (index, value, run) => {\n    const font = getFont(run);\n    const glyph = isNumber(value) ? fromCodePoint(value, font) : value;\n    return insertGlyph$1(index, glyph, run);\n};\n\n/**\n * Get run index at char index\n *\n * @param index - Char index\n * @param attributedString - Attributed string\n * @returns Run index\n */\nconst runIndexAt = (index, attributedString) => {\n    return runIndexAt$1(index, attributedString.runs);\n};\n\n/**\n * Insert glyph into attributed string\n *\n * @param index - Index\n * @param glyph - Glyph or code point\n * @param attributedString - Attributed string\n * @returns Attributed string with new glyph\n */\nconst insertGlyph = (index, glyph, attributedString) => {\n    const runIndex = runIndexAt(index, attributedString);\n    // Add glyph to the end if run index invalid\n    if (runIndex === -1)\n        return append(glyph, attributedString);\n    const codePoints = [glyph] ;\n    const string = attributedString.string.slice(0, index) +\n        stringFromCodePoints(codePoints) +\n        attributedString.string.slice(index);\n    const runs = attributedString.runs.map((run, i) => {\n        if (i === runIndex)\n            return insert(index - run.start, glyph, run);\n        if (i > runIndex)\n            return add(codePoints.length, run);\n        return run;\n    });\n    return Object.assign({}, attributedString, { string, runs });\n};\n\n/**\n * Advance width between two string indices\n *\n * @param start - Glyph index\n * @param end - Glyph index\n * @param run - Run\n * @returns Advanced width run\n */\nconst advanceWidthBetween$1 = (start, end, run) => {\n    const runStart = run.start || 0;\n    const glyphStartIndex = Math.max(0, glyphIndexAt(start - runStart, run));\n    const glyphEndIndex = Math.max(0, glyphIndexAt(end - runStart, run));\n    const positions = (run.positions || []).slice(glyphStartIndex, glyphEndIndex);\n    return advanceWidth$2(positions);\n};\n\n/**\n * Advance width between start and end\n * Does not consider ligature splitting for the moment.\n * Check performance impact on supporting this\n *\n * @param start - Start offset\n * @param end - End offset\n * @param attributedString\n * @returns Advance width\n */\nconst advanceWidthBetween = (start, end, attributedString) => {\n    const runs = filter(start, end, attributedString.runs);\n    return runs.reduce((acc, run) => acc + advanceWidthBetween$1(start, end, run), 0);\n};\n\nconst HYPHEN = 0x002d;\nconst TOLERANCE_STEPS = 5;\nconst TOLERANCE_LIMIT = 50;\nconst opts = {\n    width: 3,\n    stretch: 6,\n    shrink: 9,\n};\n/**\n * Slice attributed string to many lines\n *\n * @param attributedString - Attributed string\n * @param nodes\n * @param breaks\n * @returns Attributed strings\n */\nconst breakLines = (attributedString, nodes, breaks) => {\n    let start = 0;\n    let end = null;\n    const lines = breaks.reduce((acc, breakPoint) => {\n        const node = nodes[breakPoint];\n        const prevNode = nodes[breakPoint - 1];\n        // Last breakpoint corresponds to K&P mandatory final glue\n        if (breakPoint === nodes.length - 1)\n            return acc;\n        let line;\n        if (node.type === 'penalty') {\n            // @ts-expect-error penalty node will always preceed box or glue node\n            end = prevNode.end;\n            line = slice(start, end, attributedString);\n            line = insertGlyph(line.string.length, HYPHEN, line);\n        }\n        else {\n            end = node.end;\n            line = slice(start, end, attributedString);\n        }\n        start = end;\n        return [...acc, line];\n    }, []);\n    // Last line\n    lines.push(slice(start, attributedString.string.length, attributedString));\n    return lines;\n};\n/**\n * Return Knuth & Plass nodes based on line and previously calculated syllables\n *\n * @param attributedString - Attributed string\n * @param attributes - Attributes\n * @param options - Layout options\n * @returns ?\n */\nconst getNodes = (attributedString, { align }, options) => {\n    let start = 0;\n    const hyphenWidth = 5;\n    const { syllables } = attributedString;\n    const hyphenPenalty = options.hyphenationPenalty || (align === 'justify' ? 100 : 600);\n    const result = syllables.reduce((acc, s, index) => {\n        const width = advanceWidthBetween(start, start + s.length, attributedString);\n        if (s.trim() === '') {\n            const stretch = (width * opts.width) / opts.stretch;\n            const shrink = (width * opts.width) / opts.shrink;\n            const end = start + s.length;\n            // Add glue node. Glue nodes are used to fill the space between words.\n            acc.push(linebreak.glue(width, start, end, stretch, shrink));\n        }\n        else {\n            const hyphenated = syllables[index + 1] !== ' ';\n            const end = start + s.length;\n            // Add box node. Box nodes are used to represent words.\n            acc.push(linebreak.box(width, start, end, hyphenated));\n            if (syllables[index + 1] && hyphenated) {\n                // Add penalty node. Penalty nodes are used to represent hyphenation points.\n                acc.push(linebreak.penalty(hyphenWidth, hyphenPenalty, 1));\n            }\n        }\n        start += s.length;\n        return acc;\n    }, []);\n    // Add mandatory final glue\n    result.push(linebreak.glue(0, start, start, linebreak.infinity, 0));\n    result.push(linebreak.penalty(0, -linebreak.infinity, 1));\n    return result;\n};\n/**\n * @param attributedString - Attributed string\n * @returns Attributes\n */\nconst getAttributes = (attributedString) => {\n    return attributedString.runs?.[0]?.attributes || {};\n};\n/**\n * Performs Knuth & Plass line breaking algorithm\n * Fallbacks to best fit algorithm if latter not successful\n *\n * @param options - Layout options\n */\nconst linebreaker = (options) => {\n    /**\n     * @param attributedString - Attributed string\n     * @param availableWidths - Available widths\n     * @returns Attributed string\n     */\n    return (attributedString, availableWidths) => {\n        let tolerance = options.tolerance || 4;\n        const attributes = getAttributes(attributedString);\n        const nodes = getNodes(attributedString, attributes, options);\n        let breaks = linebreak(nodes, availableWidths, tolerance);\n        // Try again with a higher tolerance if the line breaking failed.\n        while (breaks.length === 0 && tolerance < TOLERANCE_LIMIT) {\n            tolerance += TOLERANCE_STEPS;\n            breaks = linebreak(nodes, availableWidths, tolerance);\n        }\n        if (breaks.length === 0 || (breaks.length === 1 && breaks[0] === 0)) {\n            breaks = applyBestFit(nodes, availableWidths);\n        }\n        return breakLines(attributedString, nodes, breaks.slice(1));\n    };\n};\n\nvar Direction;\n(function (Direction) {\n    Direction[Direction[\"GROW\"] = 0] = \"GROW\";\n    Direction[Direction[\"SHRINK\"] = 1] = \"SHRINK\";\n})(Direction || (Direction = {}));\nconst WHITESPACE_PRIORITY = 1;\nconst LETTER_PRIORITY = 2;\nconst EXPAND_WHITESPACE_FACTOR = {\n    before: 0.5,\n    after: 0.5,\n    priority: WHITESPACE_PRIORITY,\n    unconstrained: false,\n};\nconst EXPAND_CHAR_FACTOR = {\n    before: 0.14453125, // 37/256\n    after: 0.14453125,\n    priority: LETTER_PRIORITY,\n    unconstrained: false,\n};\nconst SHRINK_WHITESPACE_FACTOR = {\n    before: -0.04296875, // -11/256\n    after: -0.04296875,\n    priority: WHITESPACE_PRIORITY,\n    unconstrained: false,\n};\nconst SHRINK_CHAR_FACTOR = {\n    before: -0.04296875,\n    after: -0.04296875,\n    priority: LETTER_PRIORITY,\n    unconstrained: false,\n};\nconst getCharFactor = (direction, options) => {\n    const expandCharFactor = options.expandCharFactor || {};\n    const shrinkCharFactor = options.shrinkCharFactor || {};\n    return direction === Direction.GROW\n        ? Object.assign({}, EXPAND_CHAR_FACTOR, expandCharFactor)\n        : Object.assign({}, SHRINK_CHAR_FACTOR, shrinkCharFactor);\n};\nconst getWhitespaceFactor = (direction, options) => {\n    const expandWhitespaceFactor = options.expandWhitespaceFactor || {};\n    const shrinkWhitespaceFactor = options.shrinkWhitespaceFactor || {};\n    return direction === Direction.GROW\n        ? Object.assign({}, EXPAND_WHITESPACE_FACTOR, expandWhitespaceFactor)\n        : Object.assign({}, SHRINK_WHITESPACE_FACTOR, shrinkWhitespaceFactor);\n};\nconst factor = (direction, options) => (glyphs) => {\n    const charFactor = getCharFactor(direction, options);\n    const whitespaceFactor = getWhitespaceFactor(direction, options);\n    const factors = [];\n    for (let index = 0; index < glyphs.length; index += 1) {\n        let f;\n        const glyph = glyphs[index];\n        if (isWhiteSpace(glyph)) {\n            f = Object.assign({}, whitespaceFactor);\n            if (index === glyphs.length - 1) {\n                f.before = 0;\n                if (index > 0) {\n                    factors[index - 1].after = 0;\n                }\n            }\n        }\n        else if (glyph.isMark && index > 0) {\n            f = Object.assign({}, factors[index - 1]);\n            f.before = 0;\n            factors[index - 1].after = 0;\n        }\n        else {\n            f = Object.assign({}, charFactor);\n        }\n        factors.push(f);\n    }\n    return factors;\n};\nconst getFactors = (gap, line, options) => {\n    const direction = gap > 0 ? Direction.GROW : Direction.SHRINK;\n    const getFactor = factor(direction, options);\n    const factors = line.runs.reduce((acc, run) => {\n        return acc.concat(getFactor(run.glyphs));\n    }, []);\n    factors[0].before = 0;\n    factors[factors.length - 1].after = 0;\n    return factors;\n};\n\nconst KASHIDA_PRIORITY = 0;\nconst NULL_PRIORITY = 3;\nconst getDistances = (gap, factors) => {\n    let total = 0;\n    const priorities = [];\n    const unconstrained = [];\n    for (let priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {\n        priorities[priority] = unconstrained[priority] = 0;\n    }\n    // sum the factors at each priority\n    for (let j = 0; j < factors.length; j += 1) {\n        const f = factors[j];\n        const sum = f.before + f.after;\n        total += sum;\n        priorities[f.priority] += sum;\n        if (f.unconstrained) {\n            unconstrained[f.priority] += sum;\n        }\n    }\n    // choose the priorities that need to be applied\n    let highestPriority = -1;\n    let highestPrioritySum = 0;\n    let remainingGap = gap;\n    let priority;\n    for (priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {\n        const prioritySum = priorities[priority];\n        if (prioritySum !== 0) {\n            if (highestPriority === -1) {\n                highestPriority = priority;\n                highestPrioritySum = prioritySum;\n            }\n            // if this priority covers the remaining gap, we're done\n            if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {\n                priorities[priority] = remainingGap / prioritySum;\n                unconstrained[priority] = 0;\n                remainingGap = 0;\n                break;\n            }\n            // mark that we need to use 100% of the adjustment from\n            // this priority, and subtract the space that it consumes\n            priorities[priority] = 1;\n            remainingGap -= prioritySum;\n            // if this priority has unconstrained glyphs, let them consume the remaining space\n            if (unconstrained[priority] !== 0) {\n                unconstrained[priority] = remainingGap / unconstrained[priority];\n                remainingGap = 0;\n                break;\n            }\n        }\n    }\n    // zero out remaining priorities (if any)\n    for (let p = priority + 1; p <= NULL_PRIORITY; p += 1) {\n        priorities[p] = 0;\n        unconstrained[p] = 0;\n    }\n    // if there is still space left over, assign it to the highest priority that we saw.\n    // this violates their factors, but it only happens in extreme cases\n    if (remainingGap > 0 && highestPriority > -1) {\n        priorities[highestPriority] =\n            (highestPrioritySum + (gap - total)) / highestPrioritySum;\n    }\n    // create and return an array of distances to add to each glyph's advance\n    const distances = [];\n    for (let index = 0; index < factors.length; index += 1) {\n        // the distance to add to this glyph is the sum of the space to add\n        // after this glyph, and the space to add before the next glyph\n        const f = factors[index];\n        const next = factors[index + 1];\n        let dist = f.after * priorities[f.priority];\n        if (next) {\n            dist += next.before * priorities[next.priority];\n        }\n        // if this glyph is unconstrained, add the unconstrained distance as well\n        if (f.unconstrained) {\n            dist += f.after * unconstrained[f.priority];\n            if (next) {\n                dist += next.before * unconstrained[next.priority];\n            }\n        }\n        distances.push(dist);\n    }\n    return distances;\n};\n\n/**\n * Adjust run positions by given distances\n *\n * @param distances\n * @param line\n * @returns Line\n */\nconst justifyLine = (distances, line) => {\n    let index = 0;\n    for (const run of line.runs) {\n        for (const position of run.positions) {\n            position.xAdvance += distances[index++];\n        }\n    }\n    return line;\n};\n/**\n * A JustificationEngine is used by a Typesetter to perform line fragment\n * justification. This implementation is based on a description of Apple's\n * justification algorithm from a PDF in the Apple Font Tools package.\n *\n * @param options - Layout options\n */\nconst justification = (options) => {\n    /**\n     * @param line\n     * @returns Line\n     */\n    return (line) => {\n        const gap = line.box.width - advanceWidth(line);\n        if (gap === 0)\n            return line; // Exact fit\n        const factors = getFactors(gap, line, options);\n        const distances = getDistances(gap, factors);\n        return justifyLine(distances, line);\n    };\n};\n\n/**\n * Returns attributed string ascent\n *\n * @param attributedString - Attributed string\n * @returns Ascent\n */\nconst ascent = (attributedString) => {\n    const reducer = (acc, run) => Math.max(acc, ascent$1(run));\n    return attributedString.runs.reduce(reducer, 0);\n};\n\n// The base font size used for calculating underline thickness.\nconst BASE_FONT_SIZE = 12;\n/**\n * A TextDecorationEngine is used by a Typesetter to generate\n * DecorationLines for a line fragment, including underlines\n * and strikes.\n */\nconst textDecoration = () => (line) => {\n    let x = line.overflowLeft || 0;\n    const overflowRight = line.overflowRight || 0;\n    const maxX = advanceWidth(line) - overflowRight;\n    line.decorationLines = [];\n    for (let i = 0; i < line.runs.length; i += 1) {\n        const run = line.runs[i];\n        const width = Math.min(maxX - x, advanceWidth$1(run));\n        const thickness = Math.max(0.5, Math.floor(run.attributes.fontSize / BASE_FONT_SIZE));\n        if (run.attributes.underline) {\n            const rect = {\n                x,\n                y: ascent(line) + thickness * 2,\n                width,\n                height: thickness,\n            };\n            const decorationLine = {\n                rect,\n                opacity: run.attributes.opacity,\n                color: run.attributes.underlineColor || 'black',\n                style: run.attributes.underlineStyle || 'solid',\n            };\n            line.decorationLines.push(decorationLine);\n        }\n        if (run.attributes.strike) {\n            const y = ascent(line) - ascent$1(run) / 3;\n            const rect = { x, y, width, height: thickness };\n            const decorationLine = {\n                rect,\n                opacity: run.attributes.opacity,\n                color: run.attributes.strikeColor || 'black',\n                style: run.attributes.strikeStyle || 'solid',\n            };\n            line.decorationLines.push(decorationLine);\n        }\n        x += width;\n    }\n    return line;\n};\n\nconst ignoredScripts = ['Common', 'Inherited', 'Unknown'];\n/**\n * Resolves unicode script in runs, grouping equal runs together\n */\nconst scriptItemizer = () => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Attributed string\n     */\n    return (attributedString) => {\n        const { string } = attributedString;\n        let lastScript = 'Unknown';\n        let lastIndex = 0;\n        let index = 0;\n        const runs = [];\n        if (!string)\n            return empty();\n        for (let i = 0; i < string.length; i += 1) {\n            const char = string[i];\n            const codePoint = char.codePointAt(0);\n            const script = unicode.getScript(codePoint);\n            if (script !== lastScript && !ignoredScripts.includes(script)) {\n                if (lastScript !== 'Unknown') {\n                    runs.push({\n                        start: lastIndex,\n                        end: index,\n                        attributes: { script: lastScript },\n                    });\n                }\n                lastIndex = index;\n                lastScript = script;\n            }\n            index += char.length;\n        }\n        if (lastIndex < string.length) {\n            runs.push({\n                start: lastIndex,\n                end: string.length,\n                attributes: { script: lastScript },\n            });\n        }\n        const result = { string, runs: runs };\n        return result;\n    };\n};\n\nconst SOFT_HYPHEN = '\\u00ad';\nconst hyphenator = hyphen(pattern);\n/**\n * @param word\n * @returns Word parts\n */\nconst splitHyphen = (word) => {\n    return word.split(SOFT_HYPHEN);\n};\nconst cache = {};\n/**\n * @param word\n * @returns Word parts\n */\nconst getParts = (word) => {\n    const base = word.includes(SOFT_HYPHEN) ? word : hyphenator(word);\n    return splitHyphen(base);\n};\nconst wordHyphenation = () => {\n    /**\n     * @param word - Word\n     * @returns Word parts\n     */\n    return (word) => {\n        const cacheKey = `_${word}`;\n        if (isNil(word))\n            return [];\n        if (cache[cacheKey])\n            return cache[cacheKey];\n        cache[cacheKey] = getParts(word);\n        return cache[cacheKey];\n    };\n};\n\nconst IGNORED_CODE_POINTS = [173];\nconst getFontSize = (run) => run.attributes.fontSize || 12;\nconst pickFontFromFontStack = (codePoint, fontStack, lastFont) => {\n    const fontStackWithFallback = [...fontStack, lastFont];\n    for (let i = 0; i < fontStackWithFallback.length; i += 1) {\n        const font = fontStackWithFallback[i];\n        if (!IGNORED_CODE_POINTS.includes(codePoint) &&\n            font &&\n            font.hasGlyphForCodePoint &&\n            font.hasGlyphForCodePoint(codePoint)) {\n            return font;\n        }\n    }\n    return fontStack.at(-1);\n};\nconst fontSubstitution = () => ({ string, runs }) => {\n    let lastFont = null;\n    let lastFontSize = null;\n    let lastIndex = 0;\n    let index = 0;\n    const res = [];\n    for (let i = 0; i < runs.length; i += 1) {\n        const run = runs[i];\n        if (string.length === 0) {\n            res.push({\n                start: 0,\n                end: 0,\n                attributes: { font: run.attributes.font },\n            });\n            break;\n        }\n        const chars = string.slice(run.start, run.end);\n        for (let j = 0; j < chars.length; j += 1) {\n            const char = chars[j];\n            const codePoint = char.codePointAt(0);\n            // If the default font does not have a glyph and the fallback font does, we use it\n            const font = pickFontFromFontStack(codePoint, run.attributes.font, lastFont);\n            const fontSize = getFontSize(run);\n            // If anything that would impact res has changed, update it\n            if (font !== lastFont ||\n                fontSize !== lastFontSize ||\n                font.unitsPerEm !== lastFont.unitsPerEm) {\n                if (lastFont) {\n                    res.push({\n                        start: lastIndex,\n                        end: index,\n                        attributes: {\n                            font: [lastFont],\n                            scale: lastFontSize / lastFont.unitsPerEm,\n                        },\n                    });\n                }\n                lastFont = font;\n                lastFontSize = fontSize;\n                lastIndex = index;\n            }\n            index += char.length;\n        }\n    }\n    if (lastIndex < string.length) {\n        const fontSize = getFontSize(last(runs));\n        res.push({\n            start: lastIndex,\n            end: string.length,\n            attributes: {\n                font: [lastFont],\n                scale: fontSize / lastFont.unitsPerEm,\n            },\n        });\n    }\n    return { string, runs: res };\n};\n\nexport { bidiEngine as bidi, layoutEngine as default, fontSubstitution, fromFragments, justification, linebreaker, scriptItemizer, textDecoration, wordHyphenation };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
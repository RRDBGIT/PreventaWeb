{"ast":null,"code":"import _objectSpread from \"C:/PreventaWeb/FrontEnd/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport * as P from '@react-pdf/primitives';\nimport { isNil, matchPercent } from '@react-pdf/fns';\nimport absPath from 'abs-svg-path';\nimport parsePath from 'parse-svg-path';\nimport normalizePath from 'normalize-svg-path';\nimport colorString from 'color-string';\nconst renderPath = (ctx, node) => {\n  var _node$props;\n  const d = (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.d;\n  if (d) ctx.path(node.props.d);\n};\nconst KAPPA$3 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst renderRect = (ctx, node) => {\n  var _node$props2, _node$props3, _node$props4, _node$props5, _node$props6, _node$props7;\n  const x = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.x) || 0;\n  const y = ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.y) || 0;\n  const rx = ((_node$props4 = node.props) === null || _node$props4 === void 0 ? void 0 : _node$props4.rx) || 0;\n  const ry = ((_node$props5 = node.props) === null || _node$props5 === void 0 ? void 0 : _node$props5.ry) || 0;\n  const width = ((_node$props6 = node.props) === null || _node$props6 === void 0 ? void 0 : _node$props6.width) || 0;\n  const height = ((_node$props7 = node.props) === null || _node$props7 === void 0 ? void 0 : _node$props7.height) || 0;\n  if (!width || !height) return;\n  if (rx && ry) {\n    const krx = rx * KAPPA$3;\n    const kry = ry * KAPPA$3;\n    ctx.moveTo(x + rx, y);\n    ctx.lineTo(x - rx + width, y);\n    ctx.bezierCurveTo(x - rx + width + krx, y, x + width, y + ry - kry, x + width, y + ry);\n    ctx.lineTo(x + width, y + height - ry);\n    ctx.bezierCurveTo(x + width, y + height - ry + kry, x - rx + width + krx, y + height, x - rx + width, y + height);\n    ctx.lineTo(x + rx, y + height);\n    ctx.bezierCurveTo(x + rx - krx, y + height, x, y + height - ry + kry, x, y + height - ry);\n    ctx.lineTo(x, y + ry);\n    ctx.bezierCurveTo(x, y + ry - kry, x + rx - krx, y, x + rx, y);\n  } else {\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + width, y);\n    ctx.lineTo(x + width, y + height);\n    ctx.lineTo(x, y + height);\n  }\n  ctx.closePath();\n};\nconst renderLine$1 = (ctx, node) => {\n  const {\n    x1,\n    x2,\n    y1,\n    y2\n  } = node.props || {};\n  ctx.moveTo(x1, y1);\n  ctx.lineTo(x2, y2);\n};\nconst renderGroup = () => {\n  // noop\n};\nconst KAPPA$2 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst drawEllipse = function (ctx, rx, ry) {\n  let cx = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let cy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  const x = cx - rx;\n  const y = cy - ry;\n  const ox = rx * KAPPA$2;\n  const oy = ry * KAPPA$2;\n  const xe = x + rx * 2;\n  const ye = y + ry * 2;\n  const xm = x + rx;\n  const ym = y + ry;\n  ctx.moveTo(x, ym);\n  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n  ctx.closePath();\n};\nconst renderEllipse = (ctx, node) => {\n  const {\n    cx,\n    cy,\n    rx,\n    ry\n  } = node.props || {};\n  drawEllipse(ctx, rx, ry, cx, cy);\n};\nconst renderCircle = (ctx, node) => {\n  var _node$props8, _node$props9, _node$props0;\n  const cx = (_node$props8 = node.props) === null || _node$props8 === void 0 ? void 0 : _node$props8.cx;\n  const cy = (_node$props9 = node.props) === null || _node$props9 === void 0 ? void 0 : _node$props9.cy;\n  const r = (_node$props0 = node.props) === null || _node$props0 === void 0 ? void 0 : _node$props0.r;\n  drawEllipse(ctx, r, r, cx, cy);\n};\n\n/* eslint-disable no-return-assign */\nconst number = n => {\n  if (n > -1e21 && n < 1e21) {\n    return Math.round(n * 1e6) / 1e6;\n  }\n  throw new Error(\"unsupported number: \".concat(n));\n};\nconst _renderGlyphs = (ctx, encoded, positions, x, y) => {\n  const commands = [];\n  const scale = ctx._fontSize / 1000;\n  let i;\n  let last = 0;\n  let hadOffset = false;\n  ctx.save();\n  // flip coordinate system\n  ctx.transform(1, 0, 0, -1, 0, ctx.page.height);\n  y = ctx.page.height - y;\n  // add current font to page if necessary\n  if (ctx.page.fonts[ctx._font.id] == null) {\n    ctx.page.fonts[ctx._font.id] = ctx._font.ref();\n  }\n  // begin the text object\n  ctx.addContent('BT');\n  // text position\n  ctx.addContent(\"1 0 0 1 \".concat(number(x), \" \").concat(number(y), \" Tm\"));\n  // font and font size\n  ctx.addContent(\"/\".concat(ctx._font.id, \" \").concat(number(ctx._fontSize), \" Tf\"));\n  // Adds a segment of text to the TJ command buffer\n  const addSegment = cur => {\n    if (last < cur) {\n      const hex = encoded.slice(last, cur).join('');\n      const advance = positions[cur - 1].xAdvance - positions[cur - 1].advanceWidth;\n      commands.push(\"<\".concat(hex, \"> \").concat(number(-advance)));\n    }\n    return last = cur;\n  };\n  // Flushes the current TJ commands to the output stream\n  const flush = s => {\n    addSegment(s);\n    if (commands.length > 0) {\n      ctx.addContent(\"[\".concat(commands.join(' '), \"] TJ\"));\n      return commands.length = 0;\n    }\n  };\n  for (i = 0; i < positions.length; i += 1) {\n    // If we have an x or y offset, we have to break out of the current TJ command\n    // so we can move the text position.\n    const pos = positions[i];\n    if (pos.xOffset || pos.yOffset) {\n      // Flush the current buffer\n      flush(i);\n      // Move the text position and flush just the current character\n      ctx.addContent(\"1 0 0 1 \".concat(number(x + pos.xOffset * scale), \" \").concat(number(y + pos.yOffset * scale), \" Tm\"));\n      flush(i + 1);\n      hadOffset = true;\n    } else {\n      // If the last character had an offset, reset the text position\n      if (hadOffset) {\n        ctx.addContent(\"1 0 0 1 \".concat(number(x), \" \").concat(number(y), \" Tm\"));\n        hadOffset = false;\n      }\n      // Group segments that don't have any advance adjustments\n      if (pos.xAdvance - pos.advanceWidth !== 0) {\n        addSegment(i + 1);\n      }\n    }\n    x += pos.xAdvance * scale;\n  }\n  // Flush any remaining commands\n  flush(i);\n  // end the text object\n  ctx.addContent('ET');\n  // restore flipped coordinate system\n  return ctx.restore();\n};\nconst renderGlyphs = (ctx, glyphs, positions, x, y) => {\n  const scale = 1000 / ctx._fontSize;\n  const unitsPerEm = ctx._font.font.unitsPerEm || 1000;\n  const advanceWidthScale = 1000 / unitsPerEm;\n  // Glyph encoding and positioning\n  const encodedGlyphs = ctx._font.encodeGlyphs(glyphs);\n  const encodedPositions = positions.map((pos, i) => ({\n    xAdvance: pos.xAdvance * scale,\n    yAdvance: pos.yAdvance * scale,\n    xOffset: pos.xOffset,\n    yOffset: pos.yOffset,\n    advanceWidth: glyphs[i].advanceWidth * advanceWidthScale\n  }));\n  return _renderGlyphs(ctx, encodedGlyphs, encodedPositions, x, y);\n};\nconst renderRun$1 = (ctx, run) => {\n  var _run$attributes$font;\n  if (!run.glyphs) return;\n  if (!run.positions) return;\n  const runAdvanceWidth = run.xAdvance;\n  const font = (_run$attributes$font = run.attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font[0];\n  const {\n    fontSize,\n    color,\n    opacity\n  } = run.attributes;\n  if (color) ctx.fillColor(color);\n  ctx.fillOpacity(opacity);\n  if (font) {\n    ctx.font(font.type === 'STANDARD' ? font.fullName : font, fontSize);\n  }\n  try {\n    renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);\n  } catch (error) {\n    console.log(error);\n  }\n  ctx.translate(runAdvanceWidth, 0);\n};\nconst renderSpan = (ctx, line, textAnchor, dominantBaseline) => {\n  var _line$box, _line$box2, _line$runs$, _line$runs$2;\n  ctx.save();\n  const x = ((_line$box = line.box) === null || _line$box === void 0 ? void 0 : _line$box.x) || 0;\n  const y = ((_line$box2 = line.box) === null || _line$box2 === void 0 ? void 0 : _line$box2.y) || 0;\n  const font = (_line$runs$ = line.runs[0]) === null || _line$runs$ === void 0 || (_line$runs$ = _line$runs$.attributes.font) === null || _line$runs$ === void 0 ? void 0 : _line$runs$[0];\n  const scale = ((_line$runs$2 = line.runs[0]) === null || _line$runs$2 === void 0 || (_line$runs$2 = _line$runs$2.attributes) === null || _line$runs$2 === void 0 ? void 0 : _line$runs$2.scale) || 1;\n  const width = line.xAdvance;\n  if (!font) return;\n  const ascent = font.ascent * scale;\n  const xHeight = font.xHeight * scale;\n  const descent = font.descent * scale;\n  const capHeight = font.capHeight * scale;\n  let xTranslate = x;\n  let yTranslate = y;\n  switch (textAnchor) {\n    case 'middle':\n      xTranslate = x - width / 2;\n      break;\n    case 'end':\n      xTranslate = x - width;\n      break;\n    default:\n      xTranslate = x;\n      break;\n  }\n  switch (dominantBaseline) {\n    case 'middle':\n    case 'central':\n      yTranslate = y + capHeight / 2;\n      break;\n    case 'hanging':\n      yTranslate = y + capHeight;\n      break;\n    case 'mathematical':\n      yTranslate = y + xHeight;\n      break;\n    case 'text-after-edge':\n      yTranslate = y + descent;\n      break;\n    case 'text-before-edge':\n      yTranslate = y + ascent;\n      break;\n    default:\n      yTranslate = y;\n      break;\n  }\n  ctx.translate(xTranslate, yTranslate);\n  line.runs.forEach(run => renderRun$1(ctx, run));\n  ctx.restore();\n};\nconst renderSvgText = (ctx, node) => {\n  const children = node.children;\n  children.forEach(span => renderSpan(ctx, span.lines[0], span.props.textAnchor, span.props.dominantBaseline));\n};\nconst pairs = values => {\n  const result = [];\n  for (let i = 0; i < values.length; i += 2) {\n    result.push([values[i], values[i + 1]]);\n  }\n  return result;\n};\n/**\n * Parse svg-like points into number arrays\n *\n * @param points string ex. \"20,30 50,60\"\n * @returns points array ex. [[20, 30], [50, 60]]\n */\nconst parsePoints = points => {\n  let values = (points || '').trim().replace(/,/g, ' ').replace(/(\\d)-(\\d)/g, '$1 -$2').split(/\\s+/);\n  if (values.length % 2 !== 0) {\n    values = values.slice(0, -1);\n  }\n  const mappedValues = values.map(parseFloat);\n  return pairs(mappedValues);\n};\nconst drawPolyline = (ctx, points) => {\n  if (points.length > 0) {\n    ctx.moveTo(points[0][0], points[0][1]);\n    points.slice(1).forEach(p => ctx.lineTo(p[0], p[1]));\n  }\n};\nconst renderPolyline = (ctx, node) => {\n  const points = parsePoints(node.props.points || '');\n  drawPolyline(ctx, points);\n};\nconst renderPolygon = (ctx, node) => {\n  const points = parsePoints(node.props.points || '');\n  drawPolyline(ctx, points);\n  ctx.closePath();\n};\nconst renderImage$1 = (ctx, node) => {\n  var _node$image;\n  if (!node.box) return;\n  if (!((_node$image = node.image) !== null && _node$image !== void 0 && _node$image.data)) return;\n  const {\n    x = 0,\n    y = 0\n  } = node.props;\n  const {\n    width,\n    height,\n    opacity\n  } = node.style;\n  const paddingTop = node.box.paddingLeft || 0;\n  const paddingLeft = node.box.paddingLeft || 0;\n  if (width === 0 || height === 0) {\n    console.warn(\"Image with src '\".concat(node.props.href, \"' skipped due to invalid dimensions\"));\n    return;\n  }\n  if (typeof width === 'string' || typeof height === 'string') {\n    console.warn(\"Image with src '\".concat(node.props.href, \"' skipped due to percentage width or height\"));\n    return;\n  }\n  ctx.save();\n  ctx.fillOpacity(opacity || 1).image(node.image.data, x + paddingLeft, y + paddingTop, {\n    width,\n    height\n  });\n  ctx.restore();\n};\n\n// This constant is used to approximate a symmetrical arc using a cubic\n// Bezier curve.\nconst KAPPA$1 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst clipNode = (ctx, node) => {\n  if (!node.box) return;\n  if (!node.style) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const {\n    borderTopLeftRadius = 0,\n    borderTopRightRadius = 0,\n    borderBottomRightRadius = 0,\n    borderBottomLeftRadius = 0\n  } = node.style;\n  // Border top\n  // @ts-expect-error this is always a number due to resolve border radius step\n  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  const ctr = rtr * (1.0 - KAPPA$1);\n  ctx.moveTo(left + rtr, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - ctr, top, left + width, top + ctr, left + width, top + rtr);\n  // Border right\n  // @ts-expect-error this is always a number due to resolve border radius step\n  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  const cbr = rbr * (1.0 - KAPPA$1);\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - cbr, left + width - cbr, top + height, left + width - rbr, top + height);\n  // Border bottom\n  // @ts-expect-error this is always a number due to resolve border radius step\n  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  const cbl = rbl * (1.0 - KAPPA$1);\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + cbl, top + height, left, top + height - cbl, left, top + height - rbl);\n  // Border left\n  // @ts-expect-error this is always a number due to resolve border radius step\n  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  const ctl = rtl * (1.0 - KAPPA$1);\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + ctl, left + ctl, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip();\n};\nconst applySingleTransformation = (ctx, transform, origin) => {\n  const {\n    operation,\n    value\n  } = transform;\n  switch (operation) {\n    case 'scale':\n      {\n        const [scaleX, scaleY] = value;\n        ctx.scale(scaleX, scaleY, {\n          origin\n        });\n        break;\n      }\n    case 'rotate':\n      {\n        const [angle] = value;\n        ctx.rotate(angle, {\n          origin\n        });\n        break;\n      }\n    case 'translate':\n      {\n        const [x, y = 0] = value;\n        ctx.translate(x, y, {\n          origin\n        });\n        break;\n      }\n    case 'skew':\n      {\n        const [xAngle = 0, yAngle = 0] = value;\n        const radx = xAngle * Math.PI / 180;\n        const rady = yAngle * Math.PI / 180;\n        const tanx = Math.tan(radx);\n        const tany = Math.tan(rady);\n        let x = 0;\n        let y = 0;\n        if (origin != null) {\n          [x, y] = Array.from(origin);\n          const x1 = x + tanx * y;\n          const y1 = y + tany * x;\n          x -= x1;\n          y -= y1;\n        }\n        ctx.transform(1, tany, tanx, 1, x, y);\n        break;\n      }\n    case 'matrix':\n      {\n        ctx.transform(...value);\n        break;\n      }\n    default:\n      {\n        console.error(\"Transform operation: '\".concat(operation, \"' doesn't supported\"));\n      }\n  }\n};\nconst applyTransformations = (ctx, node) => {\n  if (!node.origin) return;\n  const {\n    props,\n    style\n  } = node;\n  const origin = [node.origin.left, node.origin.top];\n  const propsTransform = 'transform' in props ? props.transform : undefined;\n  const operations = (style === null || style === void 0 ? void 0 : style.transform) || propsTransform || [];\n  operations.forEach(operation => {\n    applySingleTransformation(ctx, operation, origin);\n  });\n};\n\n// From https://github.com/dy/svg-path-bounds/blob/master/index.js\nconst getPathBoundingBox = node => {\n  var _node$props1;\n  const path = normalizePath(absPath(parsePath(((_node$props1 = node.props) === null || _node$props1 === void 0 ? void 0 : _node$props1.d) || '')));\n  if (!path.length) return [0, 0, 0, 0];\n  const bounds = [Infinity, Infinity, -Infinity, -Infinity];\n  for (let i = 0, l = path.length; i < l; i += 1) {\n    const points = path[i].slice(1);\n    for (let j = 0; j < points.length; j += 2) {\n      if (points[j + 0] < bounds[0]) bounds[0] = points[j + 0];\n      if (points[j + 1] < bounds[1]) bounds[1] = points[j + 1];\n      if (points[j + 0] > bounds[2]) bounds[2] = points[j + 0];\n      if (points[j + 1] > bounds[3]) bounds[3] = points[j + 1];\n    }\n  }\n  return bounds;\n};\nconst getCircleBoundingBox = node => {\n  var _node$props10, _node$props11, _node$props12;\n  const r = ((_node$props10 = node.props) === null || _node$props10 === void 0 ? void 0 : _node$props10.r) || 0;\n  const cx = ((_node$props11 = node.props) === null || _node$props11 === void 0 ? void 0 : _node$props11.cx) || 0;\n  const cy = ((_node$props12 = node.props) === null || _node$props12 === void 0 ? void 0 : _node$props12.cy) || 0;\n  return [cx - r, cy - r, cx + r, cy + r];\n};\nconst getEllipseBoundingBox = node => {\n  var _node$props13, _node$props14, _node$props15, _node$props16;\n  const cx = ((_node$props13 = node.props) === null || _node$props13 === void 0 ? void 0 : _node$props13.cx) || 0;\n  const cy = ((_node$props14 = node.props) === null || _node$props14 === void 0 ? void 0 : _node$props14.cy) || 0;\n  const rx = ((_node$props15 = node.props) === null || _node$props15 === void 0 ? void 0 : _node$props15.rx) || 0;\n  const ry = ((_node$props16 = node.props) === null || _node$props16 === void 0 ? void 0 : _node$props16.ry) || 0;\n  return [cx - rx, cy - ry, cx + rx, cy + ry];\n};\nconst getLineBoundingBox = node => {\n  var _node$props17, _node$props18, _node$props19, _node$props20;\n  const x1 = ((_node$props17 = node.props) === null || _node$props17 === void 0 ? void 0 : _node$props17.x1) || 0;\n  const y1 = ((_node$props18 = node.props) === null || _node$props18 === void 0 ? void 0 : _node$props18.y1) || 0;\n  const x2 = ((_node$props19 = node.props) === null || _node$props19 === void 0 ? void 0 : _node$props19.x2) || 0;\n  const y2 = ((_node$props20 = node.props) === null || _node$props20 === void 0 ? void 0 : _node$props20.y2) || 0;\n  return [Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2), Math.max(y1, y2)];\n};\nconst getRectBoundingBox = node => {\n  var _node$props21, _node$props22, _node$props23, _node$props24;\n  const x = ((_node$props21 = node.props) === null || _node$props21 === void 0 ? void 0 : _node$props21.x) || 0;\n  const y = ((_node$props22 = node.props) === null || _node$props22 === void 0 ? void 0 : _node$props22.y) || 0;\n  const width = ((_node$props23 = node.props) === null || _node$props23 === void 0 ? void 0 : _node$props23.width) || 0;\n  const height = ((_node$props24 = node.props) === null || _node$props24 === void 0 ? void 0 : _node$props24.height) || 0;\n  return [x, y, x + width, y + height];\n};\nconst max = values => Math.max(-Infinity, ...values);\nconst min = values => Math.min(Infinity, ...values);\nconst getPolylineBoundingBox = node => {\n  var _node$props25;\n  const points = parsePoints((_node$props25 = node.props) === null || _node$props25 === void 0 ? void 0 : _node$props25.points);\n  const xValues = points.map(p => p[0]);\n  const yValues = points.map(p => p[1]);\n  return [min(xValues), min(yValues), max(xValues), max(yValues)];\n};\nconst boundingBoxFns = {\n  [P.Rect]: getRectBoundingBox,\n  [P.Line]: getLineBoundingBox,\n  [P.Path]: getPathBoundingBox,\n  [P.Circle]: getCircleBoundingBox,\n  [P.Ellipse]: getEllipseBoundingBox,\n  [P.Polygon]: getPolylineBoundingBox,\n  [P.Polyline]: getPolylineBoundingBox\n};\nconst getBoundingBox = node => {\n  const boundingBoxFn = boundingBoxFns[node.type];\n  return boundingBoxFn ? boundingBoxFn(node) : [0, 0, 0, 0];\n};\nconst setStrokeWidth = (ctx, node) => {\n  if (!node.props) return;\n  if (!('strokeWidth' in node.props)) return;\n  const lineWidth = node.props.strokeWidth;\n  if (lineWidth) ctx.lineWidth(lineWidth);\n};\nconst setStrokeColor = (ctx, node) => {\n  if (!node.props) return;\n  if (!('stroke' in node.props)) return;\n  const strokeColor = node.props.stroke;\n  if (strokeColor) ctx.strokeColor(strokeColor);\n};\nconst setOpacity = (ctx, node) => {\n  if (!node.props) return;\n  if (!('opacity' in node.props)) return;\n  const opacity = node.props.opacity;\n  if (!isNil(opacity)) ctx.opacity(opacity);\n};\nconst setFillOpacity = (ctx, node) => {\n  if (!node.props) return;\n  if (!('fillOpacity' in node.props)) return;\n  const fillOpacity = node.props.fillOpacity || null;\n  if (!isNil(fillOpacity)) ctx.fillOpacity(fillOpacity);\n};\nconst setStrokeOpacity = (ctx, node) => {\n  var _node$props26;\n  if (!node.props) return;\n  if (!('strokeOpacity' in node.props)) return;\n  const strokeOpacity = (_node$props26 = node.props) === null || _node$props26 === void 0 ? void 0 : _node$props26.strokeOpacity;\n  if (!isNil(strokeOpacity)) ctx.strokeOpacity(strokeOpacity);\n};\nconst setLineJoin = (ctx, node) => {\n  if (!node.props) return;\n  if (!('strokeLinejoin' in node.props)) return;\n  const lineJoin = node.props.strokeLinejoin;\n  if (lineJoin) ctx.lineJoin(lineJoin);\n};\nconst setLineCap = (ctx, node) => {\n  var _node$props27;\n  if (!node.props) return;\n  if (!('strokeLinecap' in node.props)) return;\n  const lineCap = (_node$props27 = node.props) === null || _node$props27 === void 0 ? void 0 : _node$props27.strokeLinecap;\n  if (lineCap) ctx.lineCap(lineCap);\n};\nconst setLineDash = (ctx, node) => {\n  var _node$props28;\n  if (!node.props) return;\n  if (!('strokeDasharray' in node.props)) return;\n  const value = ((_node$props28 = node.props) === null || _node$props28 === void 0 ? void 0 : _node$props28.strokeDasharray) || null;\n  // @ts-expect-error check this works as expected\n  if (value) ctx.dash(value.split(/[\\s,]+/).map(Number));\n};\nconst hasLinearGradientFill = node => {\n  var _node$props$fill;\n  if (!node.props) return false;\n  if (!('fill' in node.props)) return false;\n  if (typeof node.props.fill === 'string') return false;\n  return ((_node$props$fill = node.props.fill) === null || _node$props$fill === void 0 ? void 0 : _node$props$fill.type) === P.LinearGradient;\n};\nconst hasRadialGradientFill = node => {\n  var _node$props$fill2;\n  if (!node.props) return false;\n  if (!('fill' in node.props)) return false;\n  if (typeof node.props.fill === 'string') return false;\n  return ((_node$props$fill2 = node.props.fill) === null || _node$props$fill2 === void 0 ? void 0 : _node$props$fill2.type) === P.RadialGradient;\n};\nfunction multiplyMatrices(m1, m2) {\n  const a = m1[0] * m2[0] + m1[2] * m2[1];\n  const b = m1[1] * m2[0] + m1[3] * m2[1];\n  const c = m1[0] * m2[2] + m1[2] * m2[3];\n  const d = m1[1] * m2[2] + m1[3] * m2[3];\n  const e = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n  const f = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n  return [a, b, c, d, e, f];\n}\nconst transformGradient = (grad, transforms, bbox, units) => {\n  const matrices = transforms.map(transform => {\n    switch (transform.operation) {\n      case 'scale':\n        {\n          const value = transform.value;\n          return [value[0], 0, 0, value[1], 0, 0];\n        }\n      case 'translate':\n        {\n          const value = transform.value;\n          let x = value[0] || 0;\n          let y = value[1] || 0;\n          if (units === 'objectBoundingBox') {\n            x = (bbox[2] - bbox[0]) * x;\n            y = (bbox[3] - bbox[1]) * y;\n          }\n          return [1, 0, 0, 1, x, y];\n        }\n      case 'rotate':\n        {\n          const value = transform.value;\n          const cos = Math.cos(value[0]);\n          const sin = Math.sin(value[0]);\n          return [cos, sin, -sin, cos, 0, 0];\n        }\n      case 'skew':\n        {\n          const value = transform.value;\n          return [1, Math.tan(value[0]), Math.tan(value[1]), 1, 0, 0];\n        }\n      case 'matrix':\n        {\n          const value = transform.value;\n          let x = value[4] || 0;\n          let y = value[5] || 0;\n          if (units === 'objectBoundingBox') {\n            x = (bbox[2] - bbox[0]) * x;\n            y = (bbox[3] - bbox[1]) * y;\n          }\n          return [value[0], value[1], value[2], value[3], x, y];\n        }\n      default:\n        return [1, 0, 0, 1, 0, 0];\n    }\n  });\n  const matrix = matrices.reduce(multiplyMatrices, [1, 0, 0, 1, 0, 0]);\n  grad.setTransform(...matrix);\n};\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L104\nconst setLinearGradientFill = (ctx, node) => {\n  var _node$props29, _gradient$children;\n  if (!node.props) return;\n  if (!('fill' in node.props)) return;\n  const bbox = getBoundingBox(node);\n  const gradient = (_node$props29 = node.props) === null || _node$props29 === void 0 ? void 0 : _node$props29.fill;\n  if (!gradient) return;\n  const units = gradient.props.gradientUnits || 'objectBoundingBox';\n  const transforms = gradient.props.gradientTransform || [];\n  let x1 = gradient.props.x1 || 0;\n  let y1 = gradient.props.y1 || 0;\n  let x2 = gradient.props.x2 || 1;\n  let y2 = gradient.props.y2 || 0;\n  if (units === 'objectBoundingBox') {\n    const m0 = bbox[2] - bbox[0];\n    const m3 = bbox[3] - bbox[1];\n    const m4 = bbox[0];\n    const m5 = bbox[1];\n    x1 = m0 * x1 + m4;\n    y1 = m3 * y1 + m5;\n    x2 = m0 * x2 + m4;\n    y2 = m3 * y2 + m5;\n  }\n  const grad = ctx.linearGradient(x1, y1, x2, y2);\n  transformGradient(grad, transforms, bbox, units);\n  (_gradient$children = gradient.children) === null || _gradient$children === void 0 || _gradient$children.forEach(stop => {\n    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n  });\n  ctx.fill(grad);\n};\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L155\nconst setRadialGradientFill = (ctx, node) => {\n  var _node$props30, _gradient$children2;\n  if (!node.props) return;\n  if (!('fill' in node.props)) return;\n  const bbox = getBoundingBox(node);\n  const gradient = (_node$props30 = node.props) === null || _node$props30 === void 0 ? void 0 : _node$props30.fill;\n  if (!gradient) return;\n  const units = gradient.props.gradientUnits || 'objectBoundingBox';\n  const transforms = gradient.props.gradientTransform || [];\n  let r = gradient.props.r || 0.5;\n  let cx = gradient.props.cx || 0.5;\n  let cy = gradient.props.cy || 0.5;\n  let fx = gradient.props.fx || cx;\n  let fy = gradient.props.fy || cy;\n  if (units === 'objectBoundingBox') {\n    const m0 = bbox[2] - bbox[0];\n    const m3 = bbox[3] - bbox[1];\n    const m4 = bbox[0];\n    const m5 = bbox[1];\n    r = r * m0;\n    cx = m0 * cx + m4;\n    cy = m3 * cy + m5;\n    fx = m0 * fx + m4;\n    fy = m3 * fy + m5;\n  }\n  const grad = ctx.radialGradient(cx, cy, 0, fx, fy, r);\n  transformGradient(grad, transforms, bbox, units);\n  (_gradient$children2 = gradient.children) === null || _gradient$children2 === void 0 || _gradient$children2.forEach(stop => {\n    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n  });\n  ctx.fill(grad);\n};\nconst setFillColor = (ctx, node) => {\n  var _node$props31;\n  if (!node.props) return;\n  if (!('fill' in node.props)) return;\n  const fillColor = (_node$props31 = node.props) === null || _node$props31 === void 0 ? void 0 : _node$props31.fill;\n  if (fillColor) ctx.fillColor(fillColor);\n};\nconst setFill = (ctx, node) => {\n  if (hasLinearGradientFill(node)) return setLinearGradientFill(ctx, node);\n  if (hasRadialGradientFill(node)) return setRadialGradientFill(ctx, node);\n  return setFillColor(ctx, node);\n};\nconst draw = (ctx, node) => {\n  const props = node.props || {};\n  if ('fill' in props && 'stroke' in props && props.fill && props.stroke) {\n    ctx.fillAndStroke(props.fillRule);\n  } else if ('fill' in props && props.fill) {\n    ctx.fill(props.fillRule);\n  } else if ('stroke' in props && props.stroke) {\n    ctx.stroke();\n  } else {\n    ctx.save();\n    ctx.opacity(0);\n    ctx.fill(null);\n    ctx.restore();\n  }\n};\nconst noop = () => {};\nconst renderFns$1 = {\n  [P.Tspan]: noop,\n  [P.TextInstance]: noop,\n  [P.Path]: renderPath,\n  [P.Rect]: renderRect,\n  [P.Line]: renderLine$1,\n  [P.G]: renderGroup,\n  [P.Text]: renderSvgText,\n  [P.Circle]: renderCircle,\n  [P.Image]: renderImage$1,\n  [P.Ellipse]: renderEllipse,\n  [P.Polygon]: renderPolygon,\n  [P.Polyline]: renderPolyline\n};\nconst renderNode$1 = (ctx, node) => {\n  const renderFn = renderFns$1[node.type];\n  if (renderFn) {\n    renderFn(ctx, node);\n  } else {\n    console.warn(\"SVG node of type \".concat(node.type, \" is not currently supported\"));\n  }\n};\nconst drawNode = (ctx, node) => {\n  setLineCap(ctx, node);\n  setLineDash(ctx, node);\n  setLineJoin(ctx, node);\n  setStrokeWidth(ctx, node);\n  setStrokeColor(ctx, node);\n  setFill(ctx, node);\n  setStrokeOpacity(ctx, node);\n  setFillOpacity(ctx, node);\n  setOpacity(ctx, node);\n  applyTransformations(ctx, node);\n  renderNode$1(ctx, node);\n  draw(ctx, node);\n};\nconst clipPath = (ctx, node) => {\n  if (!node.props) return;\n  if (!('clipPath' in node.props)) return;\n  const value = node.props.clipPath;\n  if (value) {\n    const children = value.children || [];\n    children.forEach(child => renderNode$1(ctx, child));\n    ctx.clip();\n  }\n};\nconst drawChildren = (ctx, node) => {\n  const children = node.children || [];\n  children.forEach(child => {\n    ctx.save();\n    clipPath(ctx, child);\n    drawNode(ctx, child);\n    drawChildren(ctx, child);\n    ctx.restore();\n  });\n};\nconst resolveAspectRatio = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    width,\n    height\n  } = node.box;\n  const {\n    viewBox,\n    preserveAspectRatio\n  } = node.props;\n  const {\n    meetOrSlice = 'meet',\n    align = 'xMidYMid'\n  } = preserveAspectRatio || {};\n  if (viewBox == null || width == null || height == null) return;\n  const x = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.minX) || 0;\n  const y = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.minY) || 0;\n  const logicalWidth = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.maxX) || width;\n  const logicalHeight = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.maxY) || height;\n  const logicalRatio = logicalWidth / logicalHeight;\n  const physicalRatio = width / height;\n  const scaleX = width / logicalWidth;\n  const scaleY = height / logicalHeight;\n  if (align === 'none') {\n    ctx.scale(scaleX, scaleY);\n    ctx.translate(-x, -y);\n    return;\n  }\n  if (logicalRatio < physicalRatio && meetOrSlice === 'meet' || logicalRatio >= physicalRatio && meetOrSlice === 'slice') {\n    ctx.scale(scaleY, scaleY);\n    switch (align) {\n      case 'xMinYMin':\n      case 'xMinYMid':\n      case 'xMinYMax':\n        ctx.translate(-x, -y);\n        break;\n      case 'xMidYMin':\n      case 'xMidYMid':\n      case 'xMidYMax':\n        ctx.translate(-x - (logicalWidth - width * logicalHeight / height) / 2, -y);\n        break;\n      default:\n        ctx.translate(-x - (logicalWidth - width * logicalHeight / height), -y);\n    }\n  } else {\n    ctx.scale(scaleX, scaleX);\n    switch (align) {\n      case 'xMinYMin':\n      case 'xMidYMin':\n      case 'xMaxYMin':\n        ctx.translate(-x, -y);\n        break;\n      case 'xMinYMid':\n      case 'xMidYMid':\n      case 'xMaxYMid':\n        ctx.translate(-x, -y - (logicalHeight - height * logicalWidth / width) / 2);\n        break;\n      default:\n        ctx.translate(-x, -y - (logicalHeight - height * logicalWidth / width));\n    }\n  }\n};\nconst moveToOrigin = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    top,\n    left\n  } = node.box;\n  const paddingLeft = node.box.paddingLeft || 0;\n  const paddingTop = node.box.paddingTop || 0;\n  ctx.translate(left + paddingLeft, top + paddingTop);\n};\nconst renderSvg = (ctx, node) => {\n  ctx.save();\n  clipNode(ctx, node);\n  moveToOrigin(ctx, node);\n  resolveAspectRatio(ctx, node);\n  drawChildren(ctx, node);\n  ctx.restore();\n};\nconst black = {\n  value: '#000',\n  opacity: 1\n};\n// TODO: parse to number[] in layout to avoid this step\nconst parseColor = hex => {\n  if (!hex) return black;\n  const parsed = colorString.get(hex);\n  if (!parsed) return black;\n  const value = colorString.to.hex(parsed.value.slice(0, 3));\n  const opacity = parsed.value[3];\n  return {\n    value,\n    opacity\n  };\n};\nconst DEST_REGEXP = /^#.+/;\nconst isSrcId$1 = src => src.match(DEST_REGEXP);\nconst renderAttachment = (ctx, attachment) => {\n  const {\n    xOffset = 0,\n    yOffset = 0,\n    width,\n    height,\n    image\n  } = attachment;\n  ctx.translate(-width + xOffset, -height + yOffset);\n  ctx.image(image, 0, 0, {\n    fit: [width, height],\n    align: 'center',\n    valign: 'bottom'\n  });\n};\nconst renderAttachments = (ctx, run) => {\n  var _run$attributes$font2;\n  if (!run.glyphs) return;\n  if (!run.positions) return;\n  const font = (_run$attributes$font2 = run.attributes.font) === null || _run$attributes$font2 === void 0 ? void 0 : _run$attributes$font2[0];\n  if (!font) return;\n  ctx.save();\n  const space = font.glyphForCodePoint(0x20);\n  const objectReplacement = font.glyphForCodePoint(0xfffc);\n  let attachmentAdvance = 0;\n  for (let i = 0; i < run.glyphs.length; i += 1) {\n    const position = run.positions[i];\n    const glyph = run.glyphs[i];\n    attachmentAdvance += position.xAdvance || 0;\n    if (glyph.id === objectReplacement.id && run.attributes.attachment) {\n      ctx.translate(attachmentAdvance, position.yOffset || 0);\n      renderAttachment(ctx, run.attributes.attachment);\n      run.glyphs[i] = space;\n      attachmentAdvance = 0;\n    }\n  }\n  ctx.restore();\n};\nconst renderRun = (ctx, run) => {\n  var _run$attributes$font3;\n  if (!run.glyphs) return;\n  if (!run.positions) return;\n  const font = (_run$attributes$font3 = run.attributes.font) === null || _run$attributes$font3 === void 0 ? void 0 : _run$attributes$font3[0];\n  if (!font) return;\n  const {\n    fontSize,\n    link\n  } = run.attributes;\n  const color = parseColor(run.attributes.color);\n  const opacity = isNil(run.attributes.opacity) ? color.opacity : run.attributes.opacity;\n  const {\n    height = 0,\n    descent = 0,\n    xAdvance = 0\n  } = run;\n  ctx.fillColor(color.value);\n  ctx.fillOpacity(opacity);\n  if (link) {\n    if (isSrcId$1(link)) {\n      ctx.goTo(0, -height - descent, xAdvance, height, link.slice(1));\n    } else {\n      ctx.link(0, -height - descent, xAdvance, height, link);\n    }\n  }\n  renderAttachments(ctx, run);\n  ctx.font(font.type === 'STANDARD' ? font.fullName : font, fontSize);\n  try {\n    renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);\n  } catch (error) {\n    console.log(error);\n  }\n  ctx.translate(xAdvance, 0);\n};\nconst renderBackground$1 = (ctx, rect, backgroundColor) => {\n  const color = parseColor(backgroundColor);\n  ctx.save();\n  ctx.fillOpacity(color.opacity);\n  ctx.rect(rect.x, rect.y, rect.width, rect.height);\n  ctx.fill(color.value);\n  ctx.restore();\n};\nconst renderDecorationLine = (ctx, decorationLine) => {\n  ctx.save();\n  ctx.lineWidth(decorationLine.rect.height);\n  ctx.strokeOpacity(decorationLine.opacity);\n  if (/dashed/.test(decorationLine.style)) {\n    ctx.dash(3 * decorationLine.rect.height, {});\n  } else if (/dotted/.test(decorationLine.style)) {\n    ctx.dash(decorationLine.rect.height, {});\n  }\n  if (/wavy/.test(decorationLine.style)) {\n    const dist = Math.max(2, decorationLine.rect.height);\n    let step = 1.1 * dist;\n    const stepCount = Math.floor(decorationLine.rect.width / (2 * step));\n    // Adjust step to fill entire width\n    const remainingWidth = decorationLine.rect.width - stepCount * 2 * step;\n    const adjustment = remainingWidth / stepCount / 2;\n    step += adjustment;\n    const cp1y = decorationLine.rect.y + dist;\n    const cp2y = decorationLine.rect.y - dist;\n    let {\n      x\n    } = decorationLine.rect;\n    ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y);\n    for (let i = 0; i < stepCount; i += 1) {\n      ctx.bezierCurveTo(x + step, cp1y, x + step, cp2y, x + 2 * step, decorationLine.rect.y);\n      x += 2 * step;\n    }\n  } else {\n    ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y);\n    ctx.lineTo(decorationLine.rect.x + decorationLine.rect.width, decorationLine.rect.y);\n    if (/double/.test(decorationLine.style)) {\n      ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y + decorationLine.rect.height * 2);\n      ctx.lineTo(decorationLine.rect.x + decorationLine.rect.width, decorationLine.rect.y + decorationLine.rect.height * 2);\n    }\n  }\n  ctx.stroke(decorationLine.color);\n  ctx.restore();\n};\nconst renderLine = (ctx, line) => {\n  if (!line.box) return;\n  const lineAscent = line.ascent || 0;\n  ctx.save();\n  ctx.translate(line.box.x, line.box.y + lineAscent);\n  for (let i = 0; i < line.runs.length; i += 1) {\n    const run = line.runs[i];\n    const isLastRun = i === line.runs.length - 1;\n    if (run.attributes.backgroundColor) {\n      var _run$xAdvance, _line$overflowRight;\n      const xAdvance = (_run$xAdvance = run.xAdvance) !== null && _run$xAdvance !== void 0 ? _run$xAdvance : 0;\n      const overflowRight = isLastRun ? (_line$overflowRight = line.overflowRight) !== null && _line$overflowRight !== void 0 ? _line$overflowRight : 0 : 0;\n      const backgroundRect = {\n        x: 0,\n        y: -lineAscent,\n        height: line.box.height,\n        width: xAdvance - overflowRight\n      };\n      renderBackground$1(ctx, backgroundRect, run.attributes.backgroundColor);\n    }\n    renderRun(ctx, run);\n  }\n  ctx.restore();\n  ctx.save();\n  ctx.translate(line.box.x, line.box.y);\n  if (line.decorationLines) {\n    for (let i = 0; i < line.decorationLines.length; i += 1) {\n      const decorationLine = line.decorationLines[i];\n      renderDecorationLine(ctx, decorationLine);\n    }\n  }\n  ctx.restore();\n};\nconst renderBlock = (ctx, block) => {\n  block.forEach(line => {\n    renderLine(ctx, line);\n  });\n};\nconst renderText = (ctx, node) => {\n  var _node$box, _node$box2;\n  if (!node.box) return;\n  if (!node.lines) return;\n  const {\n    top,\n    left\n  } = node.box;\n  const blocks = [node.lines];\n  const paddingTop = ((_node$box = node.box) === null || _node$box === void 0 ? void 0 : _node$box.paddingTop) || 0;\n  const paddingLeft = ((_node$box2 = node.box) === null || _node$box2 === void 0 ? void 0 : _node$box2.paddingLeft) || 0;\n  const initialY = node.lines[0] ? node.lines[0].box.y : 0;\n  const offsetX = node.alignOffset || 0;\n  ctx.save();\n  ctx.translate(left + paddingLeft - offsetX, top + paddingTop - initialY);\n  blocks.forEach(block => {\n    renderBlock(ctx, block);\n  });\n  ctx.restore();\n};\nconst renderPage = (ctx, node) => {\n  var _node$props32;\n  if (!node.box) return;\n  const {\n    width,\n    height\n  } = node.box;\n  const dpi = ((_node$props32 = node.props) === null || _node$props32 === void 0 ? void 0 : _node$props32.dpi) || 72;\n  const userUnit = dpi / 72;\n  ctx.addPage({\n    size: [width, height],\n    margin: 0,\n    userUnit\n  });\n};\nconst renderNote = (ctx, node) => {\n  var _node$children, _node$style;\n  if (!node.box) return;\n  const {\n    top,\n    left\n  } = node.box;\n  const value = (node === null || node === void 0 || (_node$children = node.children) === null || _node$children === void 0 ? void 0 : _node$children[0].value) || '';\n  const color = (_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.backgroundColor;\n  ctx.note(left, top, 0, 0, value, {\n    color\n  });\n};\nconst embedImage = (ctx, node) => {\n  const src = node.image.data;\n  let image;\n  if (typeof src === 'string') {\n    image = ctx._imageRegistry[src];\n  }\n  if (!image) {\n    image = ctx.openImage(src);\n  }\n  if (!image.obj) {\n    image.embed(ctx);\n  }\n  return image;\n};\nconst isNumeric = n => {\n  return !Number.isNaN(parseFloat(n)) && Number.isFinite(n);\n};\nconst applyContainObjectFit = (cw, ch, iw, ih, px, py) => {\n  const cr = cw / ch;\n  const ir = iw / ih;\n  const pxp = matchPercent(px !== null && px !== void 0 ? px : null);\n  const pyp = matchPercent(py !== null && py !== void 0 ? py : null);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n  if (cr > ir) {\n    const height = ch;\n    const width = height * ir;\n    const yOffset = isNumeric(py) ? py : 0;\n    const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n    return {\n      width,\n      height,\n      xOffset,\n      yOffset\n    };\n  }\n  const width = cw;\n  const height = width / ir;\n  const xOffset = isNumeric(px) ? px : 0;\n  const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n  return {\n    width,\n    height,\n    yOffset,\n    xOffset\n  };\n};\nconst applyNoneObjectFit = (cw, ch, iw, ih, px, py) => {\n  const width = iw;\n  const height = ih;\n  const pxp = matchPercent(px !== null && px !== void 0 ? px : null);\n  const pyp = matchPercent(py !== null && py !== void 0 ? py : null);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n  const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n  const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n  return {\n    width,\n    height,\n    xOffset,\n    yOffset\n  };\n};\nconst applyCoverObjectFit = (cw, ch, iw, ih, px, py) => {\n  const ir = iw / ih;\n  const cr = cw / ch;\n  const pxp = matchPercent(px !== null && px !== void 0 ? px : null);\n  const pyp = matchPercent(py !== null && py !== void 0 ? py : null);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n  if (cr > ir) {\n    const width = cw;\n    const height = width / ir;\n    const xOffset = isNumeric(px) ? px : 0;\n    const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n    return {\n      width,\n      height,\n      yOffset,\n      xOffset\n    };\n  }\n  const height = ch;\n  const width = height * ir;\n  const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n  const yOffset = isNumeric(py) ? py : 0;\n  return {\n    width,\n    height,\n    xOffset,\n    yOffset\n  };\n};\nconst applyScaleDownObjectFit = (cw, ch, iw, ih, px, py) => {\n  const containDimension = applyContainObjectFit(cw, ch, iw, ih, px, py);\n  const noneDimension = applyNoneObjectFit(cw, ch, iw, ih, px, py);\n  return containDimension.width < noneDimension.width ? containDimension : noneDimension;\n};\nconst applyFillObjectFit = (cw, ch, px, py) => {\n  return {\n    width: cw,\n    height: ch,\n    xOffset: matchPercent(px !== null && px !== void 0 ? px : null) ? 0 : px || 0,\n    yOffset: matchPercent(py !== null && py !== void 0 ? py : null) ? 0 : py || 0\n  };\n};\nconst resolveObjectFit = function () {\n  let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'fill';\n  let cw = arguments.length > 1 ? arguments[1] : undefined;\n  let ch = arguments.length > 2 ? arguments[2] : undefined;\n  let iw = arguments.length > 3 ? arguments[3] : undefined;\n  let ih = arguments.length > 4 ? arguments[4] : undefined;\n  let px = arguments.length > 5 ? arguments[5] : undefined;\n  let py = arguments.length > 6 ? arguments[6] : undefined;\n  switch (type) {\n    case 'contain':\n      return applyContainObjectFit(cw, ch, iw, ih, px, py);\n    case 'cover':\n      return applyCoverObjectFit(cw, ch, iw, ih, px, py);\n    case 'none':\n      return applyNoneObjectFit(cw, ch, iw, ih, px, py);\n    case 'scale-down':\n      return applyScaleDownObjectFit(cw, ch, iw, ih, px, py);\n    default:\n      return applyFillObjectFit(cw, ch, px, py);\n  }\n};\nconst drawImage = (ctx, node, options) => {\n  var _node$style2, _node$style3, _node$style4, _node$style5;\n  if (!node.box) return;\n  if (!node.image) return;\n  const {\n    left,\n    top\n  } = node.box;\n  const opacity = (_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2.opacity;\n  const objectFit = (_node$style3 = node.style) === null || _node$style3 === void 0 ? void 0 : _node$style3.objectFit;\n  const objectPositionX = (_node$style4 = node.style) === null || _node$style4 === void 0 ? void 0 : _node$style4.objectPositionX;\n  const objectPositionY = (_node$style5 = node.style) === null || _node$style5 === void 0 ? void 0 : _node$style5.objectPositionY;\n  const paddingTop = node.box.paddingTop || 0;\n  const paddingRight = node.box.paddingRight || 0;\n  const paddingBottom = node.box.paddingBottom || 0;\n  const paddingLeft = node.box.paddingLeft || 0;\n  const imageCache = options.imageCache || new Map();\n  const {\n    width,\n    height,\n    xOffset,\n    yOffset\n  } = resolveObjectFit(objectFit, node.box.width - paddingLeft - paddingRight, node.box.height - paddingTop - paddingBottom, node.image.width, node.image.height, objectPositionX, objectPositionY);\n  if (node.image.data) {\n    if (width !== 0 && height !== 0) {\n      const cacheKey = node.image.key;\n      const image = imageCache.get(cacheKey) || embedImage(ctx, node);\n      if (cacheKey) imageCache.set(cacheKey, image);\n      const imageOpacity = isNil(opacity) ? 1 : opacity;\n      ctx.fillOpacity(imageOpacity).image(image, left + paddingLeft + xOffset, top + paddingTop + yOffset, {\n        width,\n        height\n      });\n    } else {\n      console.warn(\"Image with src '\".concat(JSON.stringify(node.props.src || node.props.source), \"' skipped due to invalid dimensions\"));\n    }\n  }\n};\nconst renderImage = (ctx, node, options) => {\n  ctx.save();\n  clipNode(ctx, node);\n  drawImage(ctx, node, options);\n  ctx.restore();\n};\nconst CONTENT_COLOR = '#a1c6e7';\nconst PADDING_COLOR = '#c4deb9';\nconst MARGIN_COLOR = '#f8cca1';\n// TODO: Draw debug boxes using clipping to enhance quality\nconst debugContent = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    left,\n    top,\n    width,\n    height,\n    paddingLeft = 0,\n    paddingTop = 0,\n    paddingRight = 0,\n    paddingBottom = 0,\n    borderLeftWidth = 0,\n    borderTopWidth = 0,\n    borderRightWidth = 0,\n    borderBottomWidth = 0\n  } = node.box;\n  ctx.fillColor(CONTENT_COLOR).opacity(0.5).rect(left + paddingLeft + borderLeftWidth, top + paddingTop + borderTopWidth, width - paddingLeft - paddingRight - borderRightWidth - borderLeftWidth, height - paddingTop - paddingBottom - borderTopWidth - borderBottomWidth).fill();\n};\nconst debugPadding = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    left,\n    top,\n    width,\n    height,\n    paddingLeft = 0,\n    paddingTop = 0,\n    paddingRight = 0,\n    paddingBottom = 0,\n    borderLeftWidth = 0,\n    borderTopWidth = 0,\n    borderRightWidth = 0,\n    borderBottomWidth = 0\n  } = node.box;\n  ctx.fillColor(PADDING_COLOR).opacity(0.5);\n  // Padding top\n  ctx.rect(left + paddingLeft + borderLeftWidth, top + borderTopWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingTop).fill();\n  // Padding left\n  ctx.rect(left + borderLeftWidth, top + borderTopWidth, paddingLeft, height - borderTopWidth - borderBottomWidth).fill();\n  // Padding right\n  ctx.rect(left + width - paddingRight - borderRightWidth, top + borderTopWidth, paddingRight, height - borderTopWidth - borderBottomWidth).fill();\n  // Padding bottom\n  ctx.rect(left + paddingLeft + borderLeftWidth, top + height - paddingBottom - borderBottomWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingBottom).fill();\n};\nconst debugMargin = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    left,\n    top,\n    width,\n    height\n  } = node.box;\n  const {\n    marginLeft = 0,\n    marginTop = 0,\n    marginRight = 0,\n    marginBottom = 0\n  } = node.box;\n  ctx.fillColor(MARGIN_COLOR).opacity(0.5);\n  // Margin top\n  ctx.rect(left, top - marginTop, width, marginTop).fill();\n  // Margin left\n  ctx.rect(left - marginLeft, top - marginTop, marginLeft, height + marginTop + marginBottom).fill();\n  // Margin right\n  ctx.rect(left + width, top - marginTop, marginRight, height + marginTop + marginBottom).fill();\n  // Margin bottom\n  ctx.rect(left, top + height, width, marginBottom).fill();\n};\nconst debugText = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    left,\n    top,\n    width,\n    height\n  } = node.box;\n  const {\n    marginLeft = 0,\n    marginTop = 0,\n    marginRight = 0,\n    marginBottom = 0\n  } = node.box;\n  const roundedWidth = Math.round(width + marginLeft + marginRight);\n  const roundedHeight = Math.round(height + marginTop + marginBottom);\n  ctx.fontSize(6).opacity(1).fillColor('black').text(\"\".concat(roundedWidth, \" x \").concat(roundedHeight), left - marginLeft, Math.max(top - marginTop - 4, 1), {\n    width: Infinity\n  });\n};\nconst debugOrigin = (ctx, node) => {\n  if (node.origin) {\n    ctx.circle(node.origin.left, node.origin.top, 3).fill('red').circle(node.origin.left, node.origin.top, 5).stroke('red');\n  }\n};\nconst renderDebug = (ctx, node) => {\n  if (!node.props) return;\n  if (!('debug' in node.props) || !node.props.debug) return;\n  ctx.save();\n  debugContent(ctx, node);\n  debugPadding(ctx, node);\n  debugMargin(ctx, node);\n  debugText(ctx, node);\n  debugOrigin(ctx, node);\n  ctx.restore();\n};\nconst availableMethods = ['dash', 'clip', 'save', 'path', 'fill', 'font', 'text', 'rect', 'scale', 'moveTo', 'lineTo', 'stroke', 'rotate', 'circle', 'lineCap', 'opacity', 'ellipse', 'polygon', 'restore', 'lineJoin', 'fontSize', 'fillColor', 'lineWidth', 'translate', 'miterLimit', 'strokeColor', 'fillOpacity', 'roundedRect', 'fillAndStroke', 'strokeOpacity', 'bezierCurveTo', 'quadraticCurveTo', 'linearGradient', 'radialGradient'];\nconst painter = ctx => {\n  const p = availableMethods.reduce((acc, prop) => _objectSpread(_objectSpread({}, acc), {}, {\n    [prop]: function () {\n      // @ts-expect-error ctx[prop] is a function\n      ctx[prop](...arguments);\n      return p;\n    }\n  }), {});\n  return p;\n};\nconst renderCanvas = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const paddingTop = node.box.paddingTop || 0;\n  const paddingLeft = node.box.paddingLeft || 0;\n  const paddingRight = node.box.paddingRight || 0;\n  const paddingBottom = node.box.paddingBottom || 0;\n  const availableWidth = width - paddingLeft - paddingRight;\n  const availableHeight = height - paddingTop - paddingBottom;\n  if (!availableWidth || !availableHeight) {\n    console.warn('Canvas element has null width or height. Please provide valid values via the `style` prop in order to correctly render it.');\n  }\n  ctx.save().translate(left + paddingLeft, top + paddingTop);\n  if (node.props.paint) {\n    node.props.paint(painter(ctx), availableWidth, availableHeight);\n  }\n  ctx.restore();\n};\n\n// Ref: https://www.w3.org/TR/css-backgrounds-3/#borders\n// This constant is used to approximate a symmetrical arc using a cubic Bezier curve.\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst clipBorderTop = (ctx, layout, style, rtr, rtl) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n  // Clip outer top border edge\n  ctx.moveTo(left + rtl, top);\n  ctx.lineTo(left + width - rtr, top);\n  // Ellipse coefficients outer top right cap\n  const c0 = rtr * (1.0 - KAPPA);\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + width - c0, top, left + width, top + c0, left + width, top + rtr);\n  // Move down in case the margin exceedes the radius\n  const topRightYCoord = top + Math.max(borderTopWidth, rtr);\n  ctx.lineTo(left + width, topRightYCoord);\n  // Clip inner top right cap\n  ctx.lineTo(left + width - borderRightWidth, topRightYCoord);\n  // Ellipse coefficients inner top right cap\n  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  const c1 = innerTopRightRadiusX * (1.0 - KAPPA);\n  const c2 = innerTopRightRadiusY * (1.0 - KAPPA);\n  // Clip inner top right cap\n  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c2, left + width - borderRightWidth - c1, top + borderTopWidth, left + width - borderRightWidth - innerTopRightRadiusX, top + borderTopWidth);\n  // Clip inner top border edge\n  ctx.lineTo(left + Math.max(rtl, borderLeftWidth), top + borderTopWidth);\n  // Ellipse coefficients inner top left cap\n  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  const c3 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  const c4 = innerTopLeftRadiusY * (1.0 - KAPPA);\n  const topLeftYCoord = top + Math.max(borderTopWidth, rtl);\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + borderLeftWidth + c3, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c4, left + borderLeftWidth, topLeftYCoord);\n  ctx.lineTo(left, topLeftYCoord);\n  // Move down in case the margin exceedes the radius\n  ctx.lineTo(left, top + rtl);\n  // Ellipse coefficients outer top left cap\n  const c5 = rtl * (1.0 - KAPPA);\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left, top + c5, left + c5, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip();\n  // Clip border top cap joins\n  if (borderRightWidth) {\n    const trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderLeftWidth) {\n    const trSlope = -borderTopWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nconst fillBorderTop = (ctx, layout, style, rtr, rtl) => {\n  const {\n    top,\n    left,\n    width\n  } = layout;\n  const {\n    borderTopColor,\n    borderTopWidth,\n    borderTopStyle,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n  const c0 = rtl * (1.0 - KAPPA);\n  const c1 = rtr * (1.0 - KAPPA);\n  ctx.moveTo(left, top + Math.max(rtl, borderTopWidth));\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n  ctx.strokeColor(borderTopColor);\n  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderLeftWidth) * 2);\n  if (borderTopStyle === 'dashed') {\n    ctx.dash(borderTopWidth * 2, {\n      space: borderTopWidth * 1.2\n    });\n  } else if (borderTopStyle === 'dotted') {\n    ctx.dash(borderTopWidth, {\n      space: borderTopWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nconst clipBorderRight = (ctx, layout, style, rtr, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderRightWidth,\n    borderBottomWidth\n  } = style;\n  // Clip outer right border edge\n  ctx.moveTo(left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr);\n  // Ellipse coefficients outer bottom right cap\n  const c0 = rbr * (1.0 - KAPPA);\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n  // Move left in case the margin exceedes the radius\n  const topBottomXCoord = left + width - Math.max(borderRightWidth, rbr);\n  ctx.lineTo(topBottomXCoord, top + height);\n  // Clip inner bottom right cap\n  ctx.lineTo(topBottomXCoord, top + height - borderBottomWidth);\n  // Ellipse coefficients inner bottom right cap\n  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  const c1 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  const c2 = innerBottomRightRadiusY * (1.0 - KAPPA);\n  // Clip inner top right cap\n  ctx.bezierCurveTo(left + width - borderRightWidth - c1, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c2, left + width - borderRightWidth, top + height - Math.max(rbr, borderBottomWidth));\n  // Clip inner right border edge\n  ctx.lineTo(left + width - borderRightWidth, top + Math.max(rtr, borderTopWidth));\n  // Ellipse coefficients inner top right cap\n  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  const c3 = innerTopRightRadiusX * (1.0 - KAPPA);\n  const c4 = innerTopRightRadiusY * (1.0 - KAPPA);\n  const topRightXCoord = left + width - Math.max(rtr, borderRightWidth);\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c4, left + width - borderRightWidth - c3, top + borderTopWidth, topRightXCoord, top + borderTopWidth);\n  ctx.lineTo(topRightXCoord, top);\n  // Move right in case the margin exceedes the radius\n  ctx.lineTo(left + width - rtr, top);\n  // Ellipse coefficients outer top right cap\n  const c5 = rtr * (1.0 - KAPPA);\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + width - c5, top, left + width, top + c5, left + width, top + rtr);\n  ctx.closePath();\n  ctx.clip();\n  // Clip border right cap joins\n  if (borderTopWidth) {\n    const trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderBottomWidth) {\n    const brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nconst fillBorderRight = (ctx, layout, style, rtr, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderRightColor,\n    borderRightStyle,\n    borderRightWidth,\n    borderTopWidth,\n    borderBottomWidth\n  } = style;\n  const c0 = rbr * (1.0 - KAPPA);\n  const c1 = rtr * (1.0 - KAPPA);\n  ctx.moveTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n  ctx.strokeColor(borderRightColor);\n  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderBottomWidth) * 2);\n  if (borderRightStyle === 'dashed') {\n    ctx.dash(borderRightWidth * 2, {\n      space: borderRightWidth * 1.2\n    });\n  } else if (borderRightStyle === 'dotted') {\n    ctx.dash(borderRightWidth, {\n      space: borderRightWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nconst clipBorderBottom = (ctx, layout, style, rbl, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderBottomWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n  // Clip outer top border edge\n  ctx.moveTo(left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height);\n  // Ellipse coefficients outer top right cap\n  const c0 = rbl * (1.0 - KAPPA);\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  // Move up in case the margin exceedes the radius\n  const bottomLeftYCoord = top + height - Math.max(borderBottomWidth, rbl);\n  ctx.lineTo(left, bottomLeftYCoord);\n  // Clip inner bottom left cap\n  ctx.lineTo(left + borderLeftWidth, bottomLeftYCoord);\n  // Ellipse coefficients inner top right cap\n  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  const c1 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  const c2 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n  // Clip inner bottom left cap\n  ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c2, left + borderLeftWidth + c1, top + height - borderBottomWidth, left + borderLeftWidth + innerBottomLeftRadiusX, top + height - borderBottomWidth);\n  // Clip inner bottom border edge\n  ctx.lineTo(left + width - Math.max(rbr, borderRightWidth), top + height - borderBottomWidth);\n  // Ellipse coefficients inner top left cap\n  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  const c3 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  const c4 = innerBottomRightRadiusY * (1.0 - KAPPA);\n  const bottomRightYCoord = top + height - Math.max(borderBottomWidth, rbr);\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + width - borderRightWidth - c3, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c4, left + width - borderRightWidth, bottomRightYCoord);\n  ctx.lineTo(left + width, bottomRightYCoord);\n  // Move down in case the margin exceedes the radius\n  ctx.lineTo(left + width, top + height - rbr);\n  // Ellipse coefficients outer top left cap\n  const c5 = rbr * (1.0 - KAPPA);\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left + width, top + height - c5, left + width - c5, top + height, left + width - rbr, top + height);\n  ctx.closePath();\n  ctx.clip();\n  // Clip border bottom cap joins\n  if (borderRightWidth) {\n    const brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderLeftWidth) {\n    const trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nconst fillBorderBottom = (ctx, layout, style, rbl, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderBottomColor,\n    borderBottomStyle,\n    borderBottomWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n  const c0 = rbl * (1.0 - KAPPA);\n  const c1 = rbr * (1.0 - KAPPA);\n  ctx.moveTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - c1, left + width - c1, top + height, left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  ctx.strokeColor(borderBottomColor);\n  ctx.lineWidth(Math.max(borderBottomWidth, borderRightWidth, borderLeftWidth) * 2);\n  if (borderBottomStyle === 'dashed') {\n    ctx.dash(borderBottomWidth * 2, {\n      space: borderBottomWidth * 1.2\n    });\n  } else if (borderBottomStyle === 'dotted') {\n    ctx.dash(borderBottomWidth, {\n      space: borderBottomWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nconst clipBorderLeft = (ctx, layout, style, rbl, rtl) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderLeftWidth,\n    borderBottomWidth\n  } = style;\n  // Clip outer left border edge\n  ctx.moveTo(left, top + height - rbl);\n  ctx.lineTo(left, top + rtl);\n  // Ellipse coefficients outer top left cap\n  const c0 = rtl * (1.0 - KAPPA);\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n  // Move right in case the margin exceedes the radius\n  const topLeftCoordX = left + Math.max(borderLeftWidth, rtl);\n  ctx.lineTo(topLeftCoordX, top);\n  // Clip inner top left cap\n  ctx.lineTo(topLeftCoordX, top + borderTopWidth);\n  // Ellipse coefficients inner top left cap\n  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  const c1 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  const c2 = innerTopLeftRadiusY * (1.0 - KAPPA);\n  // Clip inner top right cap\n  ctx.bezierCurveTo(left + borderLeftWidth + c1, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c2, left + borderLeftWidth, top + Math.max(rtl, borderTopWidth));\n  // Clip inner left border edge\n  ctx.lineTo(left + borderLeftWidth, top + height - Math.max(rbl, borderBottomWidth));\n  // Ellipse coefficients inner bottom left cap\n  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  const c3 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  const c4 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n  const bottomLeftXCoord = left + Math.max(rbl, borderLeftWidth);\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c4, left + borderLeftWidth + c3, top + height - borderBottomWidth, bottomLeftXCoord, top + height - borderBottomWidth);\n  ctx.lineTo(bottomLeftXCoord, top + height);\n  // Move left in case the margin exceedes the radius\n  ctx.lineTo(left + rbl, top + height);\n  // Ellipse coefficients outer top right cap\n  const c5 = rbl * (1.0 - KAPPA);\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + c5, top + height, left, top + height - c5, left, top + height - rbl);\n  ctx.closePath();\n  ctx.clip();\n  // Clip border right cap joins\n  if (borderBottomWidth) {\n    const trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderBottomWidth) {\n    const trSlope = -borderTopWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nconst fillBorderLeft = (ctx, layout, style, rbl, rtl) => {\n  const {\n    top,\n    left,\n    height\n  } = layout;\n  const {\n    borderLeftColor,\n    borderLeftStyle,\n    borderLeftWidth,\n    borderTopWidth,\n    borderBottomWidth\n  } = style;\n  const c0 = rbl * (1.0 - KAPPA);\n  const c1 = rtl * (1.0 - KAPPA);\n  ctx.moveTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + c1, left + c1, top, left + rtl, top);\n  ctx.strokeColor(borderLeftColor);\n  ctx.lineWidth(Math.max(borderLeftWidth, borderTopWidth, borderBottomWidth) * 2);\n  if (borderLeftStyle === 'dashed') {\n    ctx.dash(borderLeftWidth * 2, {\n      space: borderLeftWidth * 1.2\n    });\n  } else if (borderLeftStyle === 'dotted') {\n    ctx.dash(borderLeftWidth, {\n      space: borderLeftWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nconst shouldRenderBorders = node => node.box && (node.box.borderTopWidth || node.box.borderRightWidth || node.box.borderBottomWidth || node.box.borderLeftWidth);\nconst renderBorders = (ctx, node) => {\n  if (!node.box) return;\n  if (!shouldRenderBorders(node)) return;\n  const {\n    width,\n    height,\n    borderTopWidth = 0,\n    borderLeftWidth = 0,\n    borderRightWidth = 0,\n    borderBottomWidth = 0\n  } = node.box;\n  const {\n    opacity = 1,\n    borderTopColor = 'black',\n    borderTopStyle = 'solid',\n    borderLeftColor = 'black',\n    borderLeftStyle = 'solid',\n    borderRightColor = 'black',\n    borderRightStyle = 'solid',\n    borderBottomColor = 'black',\n    borderBottomStyle = 'solid'\n  } = node.style;\n  // @ts-expect-error this is always a number due to resolve border radius step\n  const borderTopLeftRadius = node.style.borderTopLeftRadius || 0;\n  // @ts-expect-error this is always a number due to resolve border radius step\n  const borderTopRightRadius = node.style.borderTopRightRadius || 0;\n  // @ts-expect-error this is always a number due to resolve border radius step\n  const borderBottomLeftRadius = node.style.borderBottomLeftRadius || 0;\n  // @ts-expect-error this is always a number due to resolve border radius step\n  const borderBottomRightRadius = node.style.borderBottomRightRadius || 0;\n  const style = {\n    borderTopColor,\n    borderTopWidth,\n    borderTopStyle,\n    borderLeftColor,\n    borderLeftWidth,\n    borderLeftStyle,\n    borderRightColor,\n    borderRightWidth,\n    borderRightStyle,\n    borderBottomColor,\n    borderBottomWidth,\n    borderBottomStyle\n  };\n  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  ctx.save();\n  ctx.strokeOpacity(opacity);\n  if (borderTopWidth) {\n    ctx.save();\n    clipBorderTop(ctx, node.box, style, rtr, rtl);\n    fillBorderTop(ctx, node.box, style, rtr, rtl);\n    ctx.restore();\n  }\n  if (borderRightWidth) {\n    ctx.save();\n    clipBorderRight(ctx, node.box, style, rtr, rbr);\n    fillBorderRight(ctx, node.box, style, rtr, rbr);\n    ctx.restore();\n  }\n  if (borderBottomWidth) {\n    ctx.save();\n    clipBorderBottom(ctx, node.box, style, rbl, rbr);\n    fillBorderBottom(ctx, node.box, style, rbl, rbr);\n    ctx.restore();\n  }\n  if (borderLeftWidth) {\n    ctx.save();\n    clipBorderLeft(ctx, node.box, style, rbl, rtl);\n    fillBorderLeft(ctx, node.box, style, rbl, rtl);\n    ctx.restore();\n  }\n  ctx.restore();\n};\nconst drawBackground = (ctx, node) => {\n  var _node$style6;\n  if (!node.box) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const color = parseColor(node.style.backgroundColor);\n  const nodeOpacity = isNil((_node$style6 = node.style) === null || _node$style6 === void 0 ? void 0 : _node$style6.opacity) ? 1 : node.style.opacity;\n  const opacity = Math.min(color.opacity, nodeOpacity);\n  ctx.fillOpacity(opacity).fillColor(color.value).rect(left, top, width, height).fill();\n};\nconst renderBackground = (ctx, node) => {\n  var _node$style7;\n  const hasBackground = !!node.box && !!((_node$style7 = node.style) !== null && _node$style7 !== void 0 && _node$style7.backgroundColor);\n  if (hasBackground) {\n    ctx.save();\n    clipNode(ctx, node);\n    drawBackground(ctx, node);\n    ctx.restore();\n  }\n};\nconst isString = value => typeof value === 'string';\nconst isSrcId = value => /^#.+/.test(value);\nconst renderLink = (ctx, node, src) => {\n  if (!src || !node.box) return;\n  const isId = isSrcId(src);\n  const method = isId ? 'goTo' : 'link';\n  const value = isId ? src.slice(1) : src;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  ctx[method](left, top, width, height, value);\n};\nconst setLink = (ctx, node) => {\n  const props = node.props || {};\n  if ('src' in props && isString(props.src)) return renderLink(ctx, node, props.src);\n  if ('href' in props && isString(props.href)) return renderLink(ctx, node, props.href);\n};\nconst setDestination = (ctx, node) => {\n  if (!node.box) return;\n  if (!node.props) return;\n  if ('id' in node.props) {\n    ctx.addNamedDestination(node.props.id, 'XYZ', null, node.box.top, null);\n  }\n};\nconst clean = options => {\n  const opt = _objectSpread({}, options);\n  // We need to ensure the elements are no present if not true\n  Object.entries(opt).forEach(pair => {\n    if (!pair[1]) {\n      delete opt[pair[0]];\n    }\n  });\n  return opt;\n};\nconst parseCommonFormOptions = node => {\n  var _node$props33, _node$props34, _node$props35, _node$props36, _node$props37;\n  // Common Options\n  return {\n    required: ((_node$props33 = node.props) === null || _node$props33 === void 0 ? void 0 : _node$props33.required) || false,\n    noExport: ((_node$props34 = node.props) === null || _node$props34 === void 0 ? void 0 : _node$props34.noExport) || false,\n    readOnly: ((_node$props35 = node.props) === null || _node$props35 === void 0 ? void 0 : _node$props35.readOnly) || false,\n    value: ((_node$props36 = node.props) === null || _node$props36 === void 0 ? void 0 : _node$props36.value) || undefined,\n    defaultValue: ((_node$props37 = node.props) === null || _node$props37 === void 0 ? void 0 : _node$props37.defaultValue) || undefined\n  };\n};\nconst parseTextInputOptions = (node, fieldSet) => {\n  var _node$props38, _node$props39, _node$props40, _node$props41, _node$props42, _node$props43, _node$props44;\n  return clean(_objectSpread(_objectSpread({}, parseCommonFormOptions(node)), {}, {\n    parent: fieldSet || undefined,\n    align: ((_node$props38 = node.props) === null || _node$props38 === void 0 ? void 0 : _node$props38.align) || 'left',\n    multiline: ((_node$props39 = node.props) === null || _node$props39 === void 0 ? void 0 : _node$props39.multiline) || undefined,\n    password: ((_node$props40 = node.props) === null || _node$props40 === void 0 ? void 0 : _node$props40.password) || false,\n    noSpell: ((_node$props41 = node.props) === null || _node$props41 === void 0 ? void 0 : _node$props41.noSpell) || false,\n    format: ((_node$props42 = node.props) === null || _node$props42 === void 0 ? void 0 : _node$props42.format) || undefined,\n    fontSize: ((_node$props43 = node.props) === null || _node$props43 === void 0 ? void 0 : _node$props43.fontSize) || undefined,\n    MaxLen: ((_node$props44 = node.props) === null || _node$props44 === void 0 ? void 0 : _node$props44.maxLength) || undefined\n  }));\n};\nconst parseSelectAndListFieldOptions = node => {\n  var _node$props45, _node$props46, _node$props47, _node$props48, _node$props49;\n  return clean(_objectSpread(_objectSpread({}, parseCommonFormOptions(node)), {}, {\n    sort: ((_node$props45 = node.props) === null || _node$props45 === void 0 ? void 0 : _node$props45.sort) || false,\n    edit: ((_node$props46 = node.props) === null || _node$props46 === void 0 ? void 0 : _node$props46.edit) || false,\n    multiSelect: ((_node$props47 = node.props) === null || _node$props47 === void 0 ? void 0 : _node$props47.multiSelect) || false,\n    noSpell: ((_node$props48 = node.props) === null || _node$props48 === void 0 ? void 0 : _node$props48.noSpell) || false,\n    select: ((_node$props49 = node.props) === null || _node$props49 === void 0 ? void 0 : _node$props49.select) || ['']\n  }));\n};\nconst getAppearance = (ctx, codepoint, width, height) => {\n  const appearance = ctx.ref({\n    Type: 'XObject',\n    Subtype: 'Form',\n    BBox: [0, 0, width, height],\n    Resources: {\n      ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI'],\n      Font: {\n        ZaDi: ctx._acroform.fonts.ZaDi\n      }\n    }\n  });\n  appearance.initDeflate();\n  appearance.write(\"/Tx BMC\\nq\\n/ZaDi \".concat(height * 0.8, \" Tf\\nBT\\n\").concat(width * 0.45, \" \").concat(height / 4, \" Td (\").concat(codepoint, \") Tj\\nET\\nQ\\nEMC\"));\n  appearance.end(null);\n  return appearance;\n};\nconst parseCheckboxOptions = (ctx, node, fieldSet) => {\n  var _node$props50, _node$props51, _node$props52, _node$props53, _node$props54, _node$props55, _node$props56, _node$props57;\n  const {\n    width,\n    height\n  } = node.box || {};\n  const onOption = ((_node$props50 = node.props) === null || _node$props50 === void 0 ? void 0 : _node$props50.onState) || 'Yes';\n  const offOption = ((_node$props51 = node.props) === null || _node$props51 === void 0 ? void 0 : _node$props51.offState) || 'Off';\n  const xMark = ((_node$props52 = node.props) === null || _node$props52 === void 0 ? void 0 : _node$props52.xMark) || false;\n  if (!Object.prototype.hasOwnProperty.call(ctx._acroform.fonts, 'ZaDi')) {\n    const ref = ctx.ref({\n      Type: 'Font',\n      Subtype: 'Type1',\n      BaseFont: 'ZapfDingbats'\n    });\n    ctx._acroform.fonts.ZaDi = ref;\n    ref.end(null);\n  }\n  const normalAppearance = {\n    [onOption]: getAppearance(ctx, xMark ? '8' : '4', width, height),\n    [offOption]: getAppearance(ctx, xMark ? ' ' : '8', width, height)\n  };\n  return clean(_objectSpread(_objectSpread({}, parseCommonFormOptions(node)), {}, {\n    backgroundColor: ((_node$props53 = node.props) === null || _node$props53 === void 0 ? void 0 : _node$props53.backgroundColor) || undefined,\n    borderColor: ((_node$props54 = node.props) === null || _node$props54 === void 0 ? void 0 : _node$props54.borderColor) || undefined,\n    parent: fieldSet || undefined,\n    value: \"/\".concat(((_node$props55 = node.props) === null || _node$props55 === void 0 ? void 0 : _node$props55.checked) === true ? onOption : offOption),\n    defaultValue: \"/\".concat(((_node$props56 = node.props) === null || _node$props56 === void 0 ? void 0 : _node$props56.checked) === true ? onOption : offOption),\n    AS: ((_node$props57 = node.props) === null || _node$props57 === void 0 ? void 0 : _node$props57.checked) === true ? onOption : offOption,\n    AP: {\n      N: normalAppearance,\n      D: normalAppearance\n    }\n  }));\n};\nconst renderTextInput = (ctx, node, options) => {\n  var _node$props58, _options$fieldSets;\n  if (!node.box) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  // Element's name\n  const name = ((_node$props58 = node.props) === null || _node$props58 === void 0 ? void 0 : _node$props58.name) || '';\n  const fieldSetOptions = (_options$fieldSets = options.fieldSets) === null || _options$fieldSets === void 0 ? void 0 : _options$fieldSets.at(0);\n  if (!ctx._root.data.AcroForm) {\n    ctx.initForm();\n  }\n  ctx.formText(name, left, top, width, height, parseTextInputOptions(node, fieldSetOptions));\n};\nconst renderSelect = (ctx, node) => {\n  var _node$props59;\n  if (!node.box) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  // Element's name\n  const name = ((_node$props59 = node.props) === null || _node$props59 === void 0 ? void 0 : _node$props59.name) || '';\n  if (!ctx._root.data.AcroForm) {\n    ctx.initForm();\n  }\n  ctx.formCombo(name, left, top, width, height, parseSelectAndListFieldOptions(node));\n};\nconst renderFieldSet = (ctx, node, options) => {\n  var _node$props60;\n  const name = ((_node$props60 = node.props) === null || _node$props60 === void 0 ? void 0 : _node$props60.name) || '';\n  if (!ctx._root.data.AcroForm) {\n    ctx.initForm();\n  }\n  const formField = ctx.formField(name);\n  const option = options;\n  if (!option.fieldSets) {\n    option.fieldSets = [formField];\n  } else {\n    option.fieldSets.push(formField);\n  }\n};\nconst cleanUpFieldSet = (_ctx, _node, options) => {\n  options.fieldSets.pop();\n};\nconst renderList = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box || {};\n  // Element's name\n  const name = 'name' in node.props ? node.props.name || '' : '';\n  if (!ctx._root.data.AcroForm) {\n    ctx.initForm();\n  }\n  ctx.formList(name, left, top, width, height, parseSelectAndListFieldOptions(node));\n};\nconst renderCheckbox = (ctx, node, options) => {\n  var _node$props61, _options$fieldSets2;\n  if (!node.box) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  // Element's name\n  const name = ((_node$props61 = node.props) === null || _node$props61 === void 0 ? void 0 : _node$props61.name) || '';\n  const fieldSetOptions = (_options$fieldSets2 = options.fieldSets) === null || _options$fieldSets2 === void 0 ? void 0 : _options$fieldSets2.at(0);\n  if (!ctx._root.data.AcroForm) {\n    ctx.initForm();\n  }\n  ctx.formCheckbox(name, left, top, width, height, parseCheckboxOptions(ctx, node, fieldSetOptions));\n};\nconst isRecursiveNode = node => node.type !== P.Text && node.type !== P.Svg;\nconst renderChildren = (ctx, node, options) => {\n  ctx.save();\n  if (node.box) {\n    ctx.translate(node.box.left, node.box.top);\n  }\n  const children = node.children || [];\n  const renderChild = child => renderNode(ctx, child, options);\n  children.forEach(renderChild);\n  ctx.restore();\n};\nconst renderFns = {\n  [P.Text]: renderText,\n  [P.Note]: renderNote,\n  [P.Image]: renderImage,\n  [P.FieldSet]: renderFieldSet,\n  [P.TextInput]: renderTextInput,\n  [P.Select]: renderSelect,\n  [P.Checkbox]: renderCheckbox,\n  [P.List]: renderList,\n  [P.Canvas]: renderCanvas,\n  [P.Svg]: renderSvg,\n  [P.Link]: setLink\n};\nconst cleanUpFns = {\n  [P.FieldSet]: cleanUpFieldSet\n};\nconst renderNode = (ctx, node, options) => {\n  var _node$style8;\n  const overflowHidden = ((_node$style8 = node.style) === null || _node$style8 === void 0 ? void 0 : _node$style8.overflow) === 'hidden';\n  const shouldRenderChildren = isRecursiveNode(node);\n  if (node.type === P.Page) renderPage(ctx, node);\n  ctx.save();\n  if (overflowHidden) clipNode(ctx, node);\n  applyTransformations(ctx, node);\n  renderBackground(ctx, node);\n  renderBorders(ctx, node);\n  const renderFn = renderFns[node.type];\n  if (renderFn) renderFn(ctx, node, options);\n  if (shouldRenderChildren) renderChildren(ctx, node, options);\n  const cleanUpFn = cleanUpFns[node.type];\n  if (cleanUpFn) cleanUpFn(ctx, node, options);\n  setDestination(ctx, node);\n  renderDebug(ctx, node);\n  ctx.restore();\n};\nconst addNodeBookmark = (ctx, node, pageNumber, registry) => {\n  if (!node.box) return;\n  if (!node.props) return;\n  if ('bookmark' in node.props && node.props.bookmark) {\n    const bookmark = node.props.bookmark;\n    const {\n      title,\n      parent,\n      expanded,\n      zoom,\n      fit\n    } = bookmark;\n    const outline = registry[parent] || ctx.outline;\n    const top = bookmark.top || node.box.top;\n    const left = bookmark.left || node.box.left;\n    const instance = outline.addItem(title, {\n      pageNumber,\n      expanded,\n      top,\n      left,\n      zoom,\n      fit\n    });\n    registry[bookmark.ref] = instance;\n  }\n  if (!node.children) return;\n  node.children.forEach(child => addNodeBookmark(ctx, child, pageNumber, registry));\n};\nconst addBookmarks = (ctx, root) => {\n  const registry = {};\n  const pages = root.children || [];\n  pages.forEach((page, i) => {\n    addNodeBookmark(ctx, page, i, registry);\n  });\n};\nconst render = (ctx, doc) => {\n  const pages = doc.children || [];\n  const options = {\n    imageCache: new Map(),\n    fieldSets: []\n  };\n  pages.forEach(page => renderNode(ctx, page, options));\n  addBookmarks(ctx, doc);\n  ctx.end();\n  return ctx;\n};\nexport { render as default };","map":{"version":3,"names":["P","isNil","matchPercent","absPath","parsePath","normalizePath","colorString","renderPath","ctx","node","_node$props","d","props","path","KAPPA$3","Math","sqrt","renderRect","_node$props2","_node$props3","_node$props4","_node$props5","_node$props6","_node$props7","x","y","rx","ry","width","height","krx","kry","moveTo","lineTo","bezierCurveTo","closePath","renderLine$1","x1","x2","y1","y2","renderGroup","KAPPA$2","drawEllipse","cx","arguments","length","undefined","cy","ox","oy","xe","ye","xm","ym","renderEllipse","renderCircle","_node$props8","_node$props9","_node$props0","r","number","n","round","Error","concat","_renderGlyphs","encoded","positions","commands","scale","_fontSize","i","last","hadOffset","save","transform","page","fonts","_font","id","ref","addContent","addSegment","cur","hex","slice","join","advance","xAdvance","advanceWidth","push","flush","s","pos","xOffset","yOffset","restore","renderGlyphs","glyphs","unitsPerEm","font","advanceWidthScale","encodedGlyphs","encodeGlyphs","encodedPositions","map","yAdvance","renderRun$1","run","_run$attributes$font","runAdvanceWidth","attributes","fontSize","color","opacity","fillColor","fillOpacity","type","fullName","error","console","log","translate","renderSpan","line","textAnchor","dominantBaseline","_line$box","_line$box2","_line$runs$","_line$runs$2","box","runs","ascent","xHeight","descent","capHeight","xTranslate","yTranslate","forEach","renderSvgText","children","span","lines","pairs","values","result","parsePoints","points","trim","replace","split","mappedValues","parseFloat","drawPolyline","p","renderPolyline","renderPolygon","renderImage$1","_node$image","image","data","style","paddingTop","paddingLeft","warn","href","KAPPA$1","clipNode","top","left","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","rtr","min","ctr","rbr","cbr","rbl","cbl","rtl","ctl","clip","applySingleTransformation","origin","operation","value","scaleX","scaleY","angle","rotate","xAngle","yAngle","radx","PI","rady","tanx","tan","tany","Array","from","applyTransformations","propsTransform","operations","getPathBoundingBox","_node$props1","bounds","Infinity","l","j","getCircleBoundingBox","_node$props10","_node$props11","_node$props12","getEllipseBoundingBox","_node$props13","_node$props14","_node$props15","_node$props16","getLineBoundingBox","_node$props17","_node$props18","_node$props19","_node$props20","max","getRectBoundingBox","_node$props21","_node$props22","_node$props23","_node$props24","getPolylineBoundingBox","_node$props25","xValues","yValues","boundingBoxFns","Rect","Line","Path","Circle","Ellipse","Polygon","Polyline","getBoundingBox","boundingBoxFn","setStrokeWidth","lineWidth","strokeWidth","setStrokeColor","strokeColor","stroke","setOpacity","setFillOpacity","setStrokeOpacity","_node$props26","strokeOpacity","setLineJoin","lineJoin","strokeLinejoin","setLineCap","_node$props27","lineCap","strokeLinecap","setLineDash","_node$props28","strokeDasharray","dash","Number","hasLinearGradientFill","_node$props$fill","fill","LinearGradient","hasRadialGradientFill","_node$props$fill2","RadialGradient","multiplyMatrices","m1","m2","a","b","c","e","f","transformGradient","grad","transforms","bbox","units","matrices","cos","sin","matrix","reduce","setTransform","setLinearGradientFill","_node$props29","_gradient$children","gradient","gradientUnits","gradientTransform","m0","m3","m4","m5","linearGradient","stop","offset","stopColor","stopOpacity","setRadialGradientFill","_node$props30","_gradient$children2","fx","fy","radialGradient","setFillColor","_node$props31","setFill","draw","fillAndStroke","fillRule","noop","renderFns$1","Tspan","TextInstance","G","Text","Image","renderNode$1","renderFn","drawNode","clipPath","child","drawChildren","resolveAspectRatio","viewBox","preserveAspectRatio","meetOrSlice","align","minX","minY","logicalWidth","maxX","logicalHeight","maxY","logicalRatio","physicalRatio","moveToOrigin","renderSvg","black","parseColor","parsed","get","to","DEST_REGEXP","isSrcId$1","src","match","renderAttachment","attachment","fit","valign","renderAttachments","_run$attributes$font2","space","glyphForCodePoint","objectReplacement","attachmentAdvance","position","glyph","renderRun","_run$attributes$font3","link","goTo","renderBackground$1","rect","backgroundColor","renderDecorationLine","decorationLine","test","dist","step","stepCount","floor","remainingWidth","adjustment","cp1y","cp2y","renderLine","lineAscent","isLastRun","_run$xAdvance","_line$overflowRight","overflowRight","backgroundRect","decorationLines","renderBlock","block","renderText","_node$box","_node$box2","blocks","initialY","offsetX","alignOffset","renderPage","_node$props32","dpi","userUnit","addPage","size","margin","renderNote","_node$children","_node$style","note","embedImage","_imageRegistry","openImage","obj","embed","isNumeric","isNaN","isFinite","applyContainObjectFit","cw","ch","iw","ih","px","py","cr","ir","pxp","pyp","pxv","percent","pyv","applyNoneObjectFit","applyCoverObjectFit","applyScaleDownObjectFit","containDimension","noneDimension","applyFillObjectFit","resolveObjectFit","drawImage","options","_node$style2","_node$style3","_node$style4","_node$style5","objectFit","objectPositionX","objectPositionY","paddingRight","paddingBottom","imageCache","Map","cacheKey","key","set","imageOpacity","JSON","stringify","source","renderImage","CONTENT_COLOR","PADDING_COLOR","MARGIN_COLOR","debugContent","borderLeftWidth","borderTopWidth","borderRightWidth","borderBottomWidth","debugPadding","debugMargin","marginLeft","marginTop","marginRight","marginBottom","debugText","roundedWidth","roundedHeight","text","debugOrigin","circle","renderDebug","debug","availableMethods","painter","acc","prop","_objectSpread","renderCanvas","availableWidth","availableHeight","paint","KAPPA","clipBorderTop","layout","c0","topRightYCoord","innerTopRightRadiusX","innerTopRightRadiusY","c1","c2","innerTopLeftRadiusX","innerTopLeftRadiusY","c3","c4","topLeftYCoord","c5","trSlope","fillBorderTop","borderTopColor","borderTopStyle","undash","clipBorderRight","topBottomXCoord","innerBottomRightRadiusX","innerBottomRightRadiusY","topRightXCoord","brSlope","fillBorderRight","borderRightColor","borderRightStyle","clipBorderBottom","bottomLeftYCoord","innerBottomLeftRadiusX","innerBottomLeftRadiusY","bottomRightYCoord","fillBorderBottom","borderBottomColor","borderBottomStyle","clipBorderLeft","topLeftCoordX","bottomLeftXCoord","fillBorderLeft","borderLeftColor","borderLeftStyle","shouldRenderBorders","renderBorders","drawBackground","_node$style6","nodeOpacity","renderBackground","_node$style7","hasBackground","isString","isSrcId","renderLink","isId","method","setLink","setDestination","addNamedDestination","clean","opt","Object","entries","pair","parseCommonFormOptions","_node$props33","_node$props34","_node$props35","_node$props36","_node$props37","required","noExport","readOnly","defaultValue","parseTextInputOptions","fieldSet","_node$props38","_node$props39","_node$props40","_node$props41","_node$props42","_node$props43","_node$props44","parent","multiline","password","noSpell","format","MaxLen","maxLength","parseSelectAndListFieldOptions","_node$props45","_node$props46","_node$props47","_node$props48","_node$props49","sort","edit","multiSelect","select","getAppearance","codepoint","appearance","Type","Subtype","BBox","Resources","ProcSet","Font","ZaDi","_acroform","initDeflate","write","end","parseCheckboxOptions","_node$props50","_node$props51","_node$props52","_node$props53","_node$props54","_node$props55","_node$props56","_node$props57","onOption","onState","offOption","offState","xMark","prototype","hasOwnProperty","call","BaseFont","normalAppearance","borderColor","checked","AS","AP","N","D","renderTextInput","_node$props58","_options$fieldSets","name","fieldSetOptions","fieldSets","at","_root","AcroForm","initForm","formText","renderSelect","_node$props59","formCombo","renderFieldSet","_node$props60","formField","option","cleanUpFieldSet","_ctx","_node","pop","renderList","formList","renderCheckbox","_node$props61","_options$fieldSets2","formCheckbox","isRecursiveNode","Svg","renderChildren","renderChild","renderNode","renderFns","Note","FieldSet","TextInput","Select","Checkbox","List","Canvas","Link","cleanUpFns","_node$style8","overflowHidden","overflow","shouldRenderChildren","Page","cleanUpFn","addNodeBookmark","pageNumber","registry","bookmark","title","expanded","zoom","outline","instance","addItem","addBookmarks","root","pages","render","doc","default"],"sources":["C:/PreventaWeb/FrontEnd/node_modules/@react-pdf/render/lib/index.js"],"sourcesContent":["import * as P from '@react-pdf/primitives';\nimport { isNil, matchPercent } from '@react-pdf/fns';\nimport absPath from 'abs-svg-path';\nimport parsePath from 'parse-svg-path';\nimport normalizePath from 'normalize-svg-path';\nimport colorString from 'color-string';\n\nconst renderPath = (ctx, node) => {\n    const d = node.props?.d;\n    if (d)\n        ctx.path(node.props.d);\n};\n\nconst KAPPA$3 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst renderRect = (ctx, node) => {\n    const x = node.props?.x || 0;\n    const y = node.props?.y || 0;\n    const rx = node.props?.rx || 0;\n    const ry = node.props?.ry || 0;\n    const width = node.props?.width || 0;\n    const height = node.props?.height || 0;\n    if (!width || !height)\n        return;\n    if (rx && ry) {\n        const krx = rx * KAPPA$3;\n        const kry = ry * KAPPA$3;\n        ctx.moveTo(x + rx, y);\n        ctx.lineTo(x - rx + width, y);\n        ctx.bezierCurveTo(x - rx + width + krx, y, x + width, y + ry - kry, x + width, y + ry);\n        ctx.lineTo(x + width, y + height - ry);\n        ctx.bezierCurveTo(x + width, y + height - ry + kry, x - rx + width + krx, y + height, x - rx + width, y + height);\n        ctx.lineTo(x + rx, y + height);\n        ctx.bezierCurveTo(x + rx - krx, y + height, x, y + height - ry + kry, x, y + height - ry);\n        ctx.lineTo(x, y + ry);\n        ctx.bezierCurveTo(x, y + ry - kry, x + rx - krx, y, x + rx, y);\n    }\n    else {\n        ctx.moveTo(x, y);\n        ctx.lineTo(x + width, y);\n        ctx.lineTo(x + width, y + height);\n        ctx.lineTo(x, y + height);\n    }\n    ctx.closePath();\n};\n\nconst renderLine$1 = (ctx, node) => {\n    const { x1, x2, y1, y2 } = node.props || {};\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n};\n\nconst renderGroup = () => {\n    // noop\n};\n\nconst KAPPA$2 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst drawEllipse = (ctx, rx, ry, cx = 0, cy = 0) => {\n    const x = cx - rx;\n    const y = cy - ry;\n    const ox = rx * KAPPA$2;\n    const oy = ry * KAPPA$2;\n    const xe = x + rx * 2;\n    const ye = y + ry * 2;\n    const xm = x + rx;\n    const ym = y + ry;\n    ctx.moveTo(x, ym);\n    ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n    ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n    ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n    ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n    ctx.closePath();\n};\nconst renderEllipse = (ctx, node) => {\n    const { cx, cy, rx, ry } = node.props || {};\n    drawEllipse(ctx, rx, ry, cx, cy);\n};\n\nconst renderCircle = (ctx, node) => {\n    const cx = node.props?.cx;\n    const cy = node.props?.cy;\n    const r = node.props?.r;\n    drawEllipse(ctx, r, r, cx, cy);\n};\n\n/* eslint-disable no-return-assign */\nconst number = (n) => {\n    if (n > -1e21 && n < 1e21) {\n        return Math.round(n * 1e6) / 1e6;\n    }\n    throw new Error(`unsupported number: ${n}`);\n};\nconst _renderGlyphs = (ctx, encoded, positions, x, y) => {\n    const commands = [];\n    const scale = ctx._fontSize / 1000;\n    let i;\n    let last = 0;\n    let hadOffset = false;\n    ctx.save();\n    // flip coordinate system\n    ctx.transform(1, 0, 0, -1, 0, ctx.page.height);\n    y = ctx.page.height - y;\n    // add current font to page if necessary\n    if (ctx.page.fonts[ctx._font.id] == null) {\n        ctx.page.fonts[ctx._font.id] = ctx._font.ref();\n    }\n    // begin the text object\n    ctx.addContent('BT');\n    // text position\n    ctx.addContent(`1 0 0 1 ${number(x)} ${number(y)} Tm`);\n    // font and font size\n    ctx.addContent(`/${ctx._font.id} ${number(ctx._fontSize)} Tf`);\n    // Adds a segment of text to the TJ command buffer\n    const addSegment = (cur) => {\n        if (last < cur) {\n            const hex = encoded.slice(last, cur).join('');\n            const advance = positions[cur - 1].xAdvance - positions[cur - 1].advanceWidth;\n            commands.push(`<${hex}> ${number(-advance)}`);\n        }\n        return (last = cur);\n    };\n    // Flushes the current TJ commands to the output stream\n    const flush = (s) => {\n        addSegment(s);\n        if (commands.length > 0) {\n            ctx.addContent(`[${commands.join(' ')}] TJ`);\n            return (commands.length = 0);\n        }\n    };\n    for (i = 0; i < positions.length; i += 1) {\n        // If we have an x or y offset, we have to break out of the current TJ command\n        // so we can move the text position.\n        const pos = positions[i];\n        if (pos.xOffset || pos.yOffset) {\n            // Flush the current buffer\n            flush(i);\n            // Move the text position and flush just the current character\n            ctx.addContent(`1 0 0 1 ${number(x + pos.xOffset * scale)} ${number(y + pos.yOffset * scale)} Tm`);\n            flush(i + 1);\n            hadOffset = true;\n        }\n        else {\n            // If the last character had an offset, reset the text position\n            if (hadOffset) {\n                ctx.addContent(`1 0 0 1 ${number(x)} ${number(y)} Tm`);\n                hadOffset = false;\n            }\n            // Group segments that don't have any advance adjustments\n            if (pos.xAdvance - pos.advanceWidth !== 0) {\n                addSegment(i + 1);\n            }\n        }\n        x += pos.xAdvance * scale;\n    }\n    // Flush any remaining commands\n    flush(i);\n    // end the text object\n    ctx.addContent('ET');\n    // restore flipped coordinate system\n    return ctx.restore();\n};\nconst renderGlyphs = (ctx, glyphs, positions, x, y) => {\n    const scale = 1000 / ctx._fontSize;\n    const unitsPerEm = ctx._font.font.unitsPerEm || 1000;\n    const advanceWidthScale = 1000 / unitsPerEm;\n    // Glyph encoding and positioning\n    const encodedGlyphs = ctx._font.encodeGlyphs(glyphs);\n    const encodedPositions = positions.map((pos, i) => ({\n        xAdvance: pos.xAdvance * scale,\n        yAdvance: pos.yAdvance * scale,\n        xOffset: pos.xOffset,\n        yOffset: pos.yOffset,\n        advanceWidth: glyphs[i].advanceWidth * advanceWidthScale,\n    }));\n    return _renderGlyphs(ctx, encodedGlyphs, encodedPositions, x, y);\n};\n\nconst renderRun$1 = (ctx, run) => {\n    if (!run.glyphs)\n        return;\n    if (!run.positions)\n        return;\n    const runAdvanceWidth = run.xAdvance;\n    const font = run.attributes.font?.[0];\n    const { fontSize, color, opacity } = run.attributes;\n    if (color)\n        ctx.fillColor(color);\n    ctx.fillOpacity(opacity);\n    if (font) {\n        ctx.font(font.type === 'STANDARD' ? font.fullName : font, fontSize);\n    }\n    try {\n        renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);\n    }\n    catch (error) {\n        console.log(error);\n    }\n    ctx.translate(runAdvanceWidth, 0);\n};\nconst renderSpan = (ctx, line, textAnchor, dominantBaseline) => {\n    ctx.save();\n    const x = line.box?.x || 0;\n    const y = line.box?.y || 0;\n    const font = line.runs[0]?.attributes.font?.[0];\n    const scale = line.runs[0]?.attributes?.scale || 1;\n    const width = line.xAdvance;\n    if (!font)\n        return;\n    const ascent = font.ascent * scale;\n    const xHeight = font.xHeight * scale;\n    const descent = font.descent * scale;\n    const capHeight = font.capHeight * scale;\n    let xTranslate = x;\n    let yTranslate = y;\n    switch (textAnchor) {\n        case 'middle':\n            xTranslate = x - width / 2;\n            break;\n        case 'end':\n            xTranslate = x - width;\n            break;\n        default:\n            xTranslate = x;\n            break;\n    }\n    switch (dominantBaseline) {\n        case 'middle':\n        case 'central':\n            yTranslate = y + capHeight / 2;\n            break;\n        case 'hanging':\n            yTranslate = y + capHeight;\n            break;\n        case 'mathematical':\n            yTranslate = y + xHeight;\n            break;\n        case 'text-after-edge':\n            yTranslate = y + descent;\n            break;\n        case 'text-before-edge':\n            yTranslate = y + ascent;\n            break;\n        default:\n            yTranslate = y;\n            break;\n    }\n    ctx.translate(xTranslate, yTranslate);\n    line.runs.forEach((run) => renderRun$1(ctx, run));\n    ctx.restore();\n};\nconst renderSvgText = (ctx, node) => {\n    const children = node.children;\n    children.forEach((span) => renderSpan(ctx, span.lines[0], span.props.textAnchor, span.props.dominantBaseline));\n};\n\nconst pairs = (values) => {\n    const result = [];\n    for (let i = 0; i < values.length; i += 2) {\n        result.push([values[i], values[i + 1]]);\n    }\n    return result;\n};\n/**\n * Parse svg-like points into number arrays\n *\n * @param points string ex. \"20,30 50,60\"\n * @returns points array ex. [[20, 30], [50, 60]]\n */\nconst parsePoints = (points) => {\n    let values = (points || '')\n        .trim()\n        .replace(/,/g, ' ')\n        .replace(/(\\d)-(\\d)/g, '$1 -$2')\n        .split(/\\s+/);\n    if (values.length % 2 !== 0) {\n        values = values.slice(0, -1);\n    }\n    const mappedValues = values.map(parseFloat);\n    return pairs(mappedValues);\n};\n\nconst drawPolyline = (ctx, points) => {\n    if (points.length > 0) {\n        ctx.moveTo(points[0][0], points[0][1]);\n        points.slice(1).forEach((p) => ctx.lineTo(p[0], p[1]));\n    }\n};\nconst renderPolyline = (ctx, node) => {\n    const points = parsePoints(node.props.points || '');\n    drawPolyline(ctx, points);\n};\n\nconst renderPolygon = (ctx, node) => {\n    const points = parsePoints(node.props.points || '');\n    drawPolyline(ctx, points);\n    ctx.closePath();\n};\n\nconst renderImage$1 = (ctx, node) => {\n    if (!node.box)\n        return;\n    if (!node.image?.data)\n        return;\n    const { x = 0, y = 0 } = node.props;\n    const { width, height, opacity } = node.style;\n    const paddingTop = node.box.paddingLeft || 0;\n    const paddingLeft = node.box.paddingLeft || 0;\n    if (width === 0 || height === 0) {\n        console.warn(`Image with src '${node.props.href}' skipped due to invalid dimensions`);\n        return;\n    }\n    if (typeof width === 'string' || typeof height === 'string') {\n        console.warn(`Image with src '${node.props.href}' skipped due to percentage width or height`);\n        return;\n    }\n    ctx.save();\n    ctx\n        .fillOpacity(opacity || 1)\n        .image(node.image.data, x + paddingLeft, y + paddingTop, {\n        width,\n        height,\n    });\n    ctx.restore();\n};\n\n// This constant is used to approximate a symmetrical arc using a cubic\n// Bezier curve.\nconst KAPPA$1 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst clipNode = (ctx, node) => {\n    if (!node.box)\n        return;\n    if (!node.style)\n        return;\n    const { top, left, width, height } = node.box;\n    const { borderTopLeftRadius = 0, borderTopRightRadius = 0, borderBottomRightRadius = 0, borderBottomLeftRadius = 0, } = node.style;\n    // Border top\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n    const ctr = rtr * (1.0 - KAPPA$1);\n    ctx.moveTo(left + rtr, top);\n    ctx.lineTo(left + width - rtr, top);\n    ctx.bezierCurveTo(left + width - ctr, top, left + width, top + ctr, left + width, top + rtr);\n    // Border right\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n    const cbr = rbr * (1.0 - KAPPA$1);\n    ctx.lineTo(left + width, top + height - rbr);\n    ctx.bezierCurveTo(left + width, top + height - cbr, left + width - cbr, top + height, left + width - rbr, top + height);\n    // Border bottom\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n    const cbl = rbl * (1.0 - KAPPA$1);\n    ctx.lineTo(left + rbl, top + height);\n    ctx.bezierCurveTo(left + cbl, top + height, left, top + height - cbl, left, top + height - rbl);\n    // Border left\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n    const ctl = rtl * (1.0 - KAPPA$1);\n    ctx.lineTo(left, top + rtl);\n    ctx.bezierCurveTo(left, top + ctl, left + ctl, top, left + rtl, top);\n    ctx.closePath();\n    ctx.clip();\n};\n\nconst applySingleTransformation = (ctx, transform, origin) => {\n    const { operation, value } = transform;\n    switch (operation) {\n        case 'scale': {\n            const [scaleX, scaleY] = value;\n            ctx.scale(scaleX, scaleY, { origin });\n            break;\n        }\n        case 'rotate': {\n            const [angle] = value;\n            ctx.rotate(angle, { origin });\n            break;\n        }\n        case 'translate': {\n            const [x, y = 0] = value;\n            ctx.translate(x, y, { origin });\n            break;\n        }\n        case 'skew': {\n            const [xAngle = 0, yAngle = 0] = value;\n            const radx = (xAngle * Math.PI) / 180;\n            const rady = (yAngle * Math.PI) / 180;\n            const tanx = Math.tan(radx);\n            const tany = Math.tan(rady);\n            let x = 0;\n            let y = 0;\n            if (origin != null) {\n                [x, y] = Array.from(origin);\n                const x1 = x + tanx * y;\n                const y1 = y + tany * x;\n                x -= x1;\n                y -= y1;\n            }\n            ctx.transform(1, tany, tanx, 1, x, y);\n            break;\n        }\n        case 'matrix': {\n            ctx.transform(...value);\n            break;\n        }\n        default: {\n            console.error(`Transform operation: '${operation}' doesn't supported`);\n        }\n    }\n};\nconst applyTransformations = (ctx, node) => {\n    if (!node.origin)\n        return;\n    const { props, style } = node;\n    const origin = [node.origin.left, node.origin.top];\n    const propsTransform = 'transform' in props ? props.transform : undefined;\n    const operations = style?.transform || propsTransform || [];\n    operations.forEach((operation) => {\n        applySingleTransformation(ctx, operation, origin);\n    });\n};\n\n// From https://github.com/dy/svg-path-bounds/blob/master/index.js\nconst getPathBoundingBox = (node) => {\n    const path = normalizePath(absPath(parsePath(node.props?.d || '')));\n    if (!path.length)\n        return [0, 0, 0, 0];\n    const bounds = [Infinity, Infinity, -Infinity, -Infinity];\n    for (let i = 0, l = path.length; i < l; i += 1) {\n        const points = path[i].slice(1);\n        for (let j = 0; j < points.length; j += 2) {\n            if (points[j + 0] < bounds[0])\n                bounds[0] = points[j + 0];\n            if (points[j + 1] < bounds[1])\n                bounds[1] = points[j + 1];\n            if (points[j + 0] > bounds[2])\n                bounds[2] = points[j + 0];\n            if (points[j + 1] > bounds[3])\n                bounds[3] = points[j + 1];\n        }\n    }\n    return bounds;\n};\nconst getCircleBoundingBox = (node) => {\n    const r = node.props?.r || 0;\n    const cx = node.props?.cx || 0;\n    const cy = node.props?.cy || 0;\n    return [cx - r, cy - r, cx + r, cy + r];\n};\nconst getEllipseBoundingBox = (node) => {\n    const cx = node.props?.cx || 0;\n    const cy = node.props?.cy || 0;\n    const rx = node.props?.rx || 0;\n    const ry = node.props?.ry || 0;\n    return [cx - rx, cy - ry, cx + rx, cy + ry];\n};\nconst getLineBoundingBox = (node) => {\n    const x1 = node.props?.x1 || 0;\n    const y1 = node.props?.y1 || 0;\n    const x2 = node.props?.x2 || 0;\n    const y2 = node.props?.y2 || 0;\n    return [\n        Math.min(x1, x2),\n        Math.min(y1, y2),\n        Math.max(x1, x2),\n        Math.max(y1, y2),\n    ];\n};\nconst getRectBoundingBox = (node) => {\n    const x = node.props?.x || 0;\n    const y = node.props?.y || 0;\n    const width = node.props?.width || 0;\n    const height = node.props?.height || 0;\n    return [x, y, x + width, y + height];\n};\nconst max = (values) => Math.max(-Infinity, ...values);\nconst min = (values) => Math.min(Infinity, ...values);\nconst getPolylineBoundingBox = (node) => {\n    const points = parsePoints(node.props?.points);\n    const xValues = points.map((p) => p[0]);\n    const yValues = points.map((p) => p[1]);\n    return [min(xValues), min(yValues), max(xValues), max(yValues)];\n};\nconst boundingBoxFns = {\n    [P.Rect]: getRectBoundingBox,\n    [P.Line]: getLineBoundingBox,\n    [P.Path]: getPathBoundingBox,\n    [P.Circle]: getCircleBoundingBox,\n    [P.Ellipse]: getEllipseBoundingBox,\n    [P.Polygon]: getPolylineBoundingBox,\n    [P.Polyline]: getPolylineBoundingBox,\n};\nconst getBoundingBox = (node) => {\n    const boundingBoxFn = boundingBoxFns[node.type];\n    return boundingBoxFn ? boundingBoxFn(node) : [0, 0, 0, 0];\n};\n\nconst setStrokeWidth = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('strokeWidth' in node.props))\n        return;\n    const lineWidth = node.props.strokeWidth;\n    if (lineWidth)\n        ctx.lineWidth(lineWidth);\n};\nconst setStrokeColor = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('stroke' in node.props))\n        return;\n    const strokeColor = node.props.stroke;\n    if (strokeColor)\n        ctx.strokeColor(strokeColor);\n};\nconst setOpacity = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('opacity' in node.props))\n        return;\n    const opacity = node.props.opacity;\n    if (!isNil(opacity))\n        ctx.opacity(opacity);\n};\nconst setFillOpacity = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('fillOpacity' in node.props))\n        return;\n    const fillOpacity = node.props.fillOpacity || null;\n    if (!isNil(fillOpacity))\n        ctx.fillOpacity(fillOpacity);\n};\nconst setStrokeOpacity = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('strokeOpacity' in node.props))\n        return;\n    const strokeOpacity = node.props?.strokeOpacity;\n    if (!isNil(strokeOpacity))\n        ctx.strokeOpacity(strokeOpacity);\n};\nconst setLineJoin = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('strokeLinejoin' in node.props))\n        return;\n    const lineJoin = node.props.strokeLinejoin;\n    if (lineJoin)\n        ctx.lineJoin(lineJoin);\n};\nconst setLineCap = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('strokeLinecap' in node.props))\n        return;\n    const lineCap = node.props?.strokeLinecap;\n    if (lineCap)\n        ctx.lineCap(lineCap);\n};\nconst setLineDash = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('strokeDasharray' in node.props))\n        return;\n    const value = node.props?.strokeDasharray || null;\n    // @ts-expect-error check this works as expected\n    if (value)\n        ctx.dash(value.split(/[\\s,]+/).map(Number));\n};\nconst hasLinearGradientFill = (node) => {\n    if (!node.props)\n        return false;\n    if (!('fill' in node.props))\n        return false;\n    if (typeof node.props.fill === 'string')\n        return false;\n    return node.props.fill?.type === P.LinearGradient;\n};\nconst hasRadialGradientFill = (node) => {\n    if (!node.props)\n        return false;\n    if (!('fill' in node.props))\n        return false;\n    if (typeof node.props.fill === 'string')\n        return false;\n    return node.props.fill?.type === P.RadialGradient;\n};\nfunction multiplyMatrices(m1, m2) {\n    const a = m1[0] * m2[0] + m1[2] * m2[1];\n    const b = m1[1] * m2[0] + m1[3] * m2[1];\n    const c = m1[0] * m2[2] + m1[2] * m2[3];\n    const d = m1[1] * m2[2] + m1[3] * m2[3];\n    const e = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n    const f = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n    return [a, b, c, d, e, f];\n}\nconst transformGradient = (grad, transforms, bbox, units) => {\n    const matrices = transforms.map((transform) => {\n        switch (transform.operation) {\n            case 'scale': {\n                const value = transform.value;\n                return [value[0], 0, 0, value[1], 0, 0];\n            }\n            case 'translate': {\n                const value = transform.value;\n                let x = value[0] || 0;\n                let y = value[1] || 0;\n                if (units === 'objectBoundingBox') {\n                    x = (bbox[2] - bbox[0]) * x;\n                    y = (bbox[3] - bbox[1]) * y;\n                }\n                return [1, 0, 0, 1, x, y];\n            }\n            case 'rotate': {\n                const value = transform.value;\n                const cos = Math.cos(value[0]);\n                const sin = Math.sin(value[0]);\n                return [cos, sin, -sin, cos, 0, 0];\n            }\n            case 'skew': {\n                const value = transform.value;\n                return [1, Math.tan(value[0]), Math.tan(value[1]), 1, 0, 0];\n            }\n            case 'matrix': {\n                const value = transform.value;\n                let x = value[4] || 0;\n                let y = value[5] || 0;\n                if (units === 'objectBoundingBox') {\n                    x = (bbox[2] - bbox[0]) * x;\n                    y = (bbox[3] - bbox[1]) * y;\n                }\n                return [value[0], value[1], value[2], value[3], x, y];\n            }\n            default:\n                return [1, 0, 0, 1, 0, 0];\n        }\n    });\n    const matrix = matrices.reduce(multiplyMatrices, [1, 0, 0, 1, 0, 0]);\n    grad.setTransform(...matrix);\n};\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L104\nconst setLinearGradientFill = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('fill' in node.props))\n        return;\n    const bbox = getBoundingBox(node);\n    const gradient = node.props?.fill;\n    if (!gradient)\n        return;\n    const units = gradient.props.gradientUnits || 'objectBoundingBox';\n    const transforms = gradient.props.gradientTransform || [];\n    let x1 = gradient.props.x1 || 0;\n    let y1 = gradient.props.y1 || 0;\n    let x2 = gradient.props.x2 || 1;\n    let y2 = gradient.props.y2 || 0;\n    if (units === 'objectBoundingBox') {\n        const m0 = bbox[2] - bbox[0];\n        const m3 = bbox[3] - bbox[1];\n        const m4 = bbox[0];\n        const m5 = bbox[1];\n        x1 = m0 * x1 + m4;\n        y1 = m3 * y1 + m5;\n        x2 = m0 * x2 + m4;\n        y2 = m3 * y2 + m5;\n    }\n    const grad = ctx.linearGradient(x1, y1, x2, y2);\n    transformGradient(grad, transforms, bbox, units);\n    gradient.children?.forEach((stop) => {\n        grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n    });\n    ctx.fill(grad);\n};\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L155\nconst setRadialGradientFill = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('fill' in node.props))\n        return;\n    const bbox = getBoundingBox(node);\n    const gradient = node.props?.fill;\n    if (!gradient)\n        return;\n    const units = gradient.props.gradientUnits || 'objectBoundingBox';\n    const transforms = gradient.props.gradientTransform || [];\n    let r = gradient.props.r || 0.5;\n    let cx = gradient.props.cx || 0.5;\n    let cy = gradient.props.cy || 0.5;\n    let fx = gradient.props.fx || cx;\n    let fy = gradient.props.fy || cy;\n    if (units === 'objectBoundingBox') {\n        const m0 = bbox[2] - bbox[0];\n        const m3 = bbox[3] - bbox[1];\n        const m4 = bbox[0];\n        const m5 = bbox[1];\n        r = r * m0;\n        cx = m0 * cx + m4;\n        cy = m3 * cy + m5;\n        fx = m0 * fx + m4;\n        fy = m3 * fy + m5;\n    }\n    const grad = ctx.radialGradient(cx, cy, 0, fx, fy, r);\n    transformGradient(grad, transforms, bbox, units);\n    gradient.children?.forEach((stop) => {\n        grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n    });\n    ctx.fill(grad);\n};\nconst setFillColor = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('fill' in node.props))\n        return;\n    const fillColor = node.props?.fill;\n    if (fillColor)\n        ctx.fillColor(fillColor);\n};\nconst setFill = (ctx, node) => {\n    if (hasLinearGradientFill(node))\n        return setLinearGradientFill(ctx, node);\n    if (hasRadialGradientFill(node))\n        return setRadialGradientFill(ctx, node);\n    return setFillColor(ctx, node);\n};\nconst draw = (ctx, node) => {\n    const props = node.props || {};\n    if ('fill' in props && 'stroke' in props && props.fill && props.stroke) {\n        ctx.fillAndStroke(props.fillRule);\n    }\n    else if ('fill' in props && props.fill) {\n        ctx.fill(props.fillRule);\n    }\n    else if ('stroke' in props && props.stroke) {\n        ctx.stroke();\n    }\n    else {\n        ctx.save();\n        ctx.opacity(0);\n        ctx.fill(null);\n        ctx.restore();\n    }\n};\nconst noop = () => { };\nconst renderFns$1 = {\n    [P.Tspan]: noop,\n    [P.TextInstance]: noop,\n    [P.Path]: renderPath,\n    [P.Rect]: renderRect,\n    [P.Line]: renderLine$1,\n    [P.G]: renderGroup,\n    [P.Text]: renderSvgText,\n    [P.Circle]: renderCircle,\n    [P.Image]: renderImage$1,\n    [P.Ellipse]: renderEllipse,\n    [P.Polygon]: renderPolygon,\n    [P.Polyline]: renderPolyline,\n};\nconst renderNode$1 = (ctx, node) => {\n    const renderFn = renderFns$1[node.type];\n    if (renderFn) {\n        renderFn(ctx, node);\n    }\n    else {\n        console.warn(`SVG node of type ${node.type} is not currently supported`);\n    }\n};\nconst drawNode = (ctx, node) => {\n    setLineCap(ctx, node);\n    setLineDash(ctx, node);\n    setLineJoin(ctx, node);\n    setStrokeWidth(ctx, node);\n    setStrokeColor(ctx, node);\n    setFill(ctx, node);\n    setStrokeOpacity(ctx, node);\n    setFillOpacity(ctx, node);\n    setOpacity(ctx, node);\n    applyTransformations(ctx, node);\n    renderNode$1(ctx, node);\n    draw(ctx, node);\n};\nconst clipPath = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('clipPath' in node.props))\n        return;\n    const value = node.props.clipPath;\n    if (value) {\n        const children = value.children || [];\n        children.forEach((child) => renderNode$1(ctx, child));\n        ctx.clip();\n    }\n};\nconst drawChildren = (ctx, node) => {\n    const children = node.children || [];\n    children.forEach((child) => {\n        ctx.save();\n        clipPath(ctx, child);\n        drawNode(ctx, child);\n        drawChildren(ctx, child);\n        ctx.restore();\n    });\n};\nconst resolveAspectRatio = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { width, height } = node.box;\n    const { viewBox, preserveAspectRatio } = node.props;\n    const { meetOrSlice = 'meet', align = 'xMidYMid' } = preserveAspectRatio || {};\n    if (viewBox == null || width == null || height == null)\n        return;\n    const x = viewBox?.minX || 0;\n    const y = viewBox?.minY || 0;\n    const logicalWidth = viewBox?.maxX || width;\n    const logicalHeight = viewBox?.maxY || height;\n    const logicalRatio = logicalWidth / logicalHeight;\n    const physicalRatio = width / height;\n    const scaleX = width / logicalWidth;\n    const scaleY = height / logicalHeight;\n    if (align === 'none') {\n        ctx.scale(scaleX, scaleY);\n        ctx.translate(-x, -y);\n        return;\n    }\n    if ((logicalRatio < physicalRatio && meetOrSlice === 'meet') ||\n        (logicalRatio >= physicalRatio && meetOrSlice === 'slice')) {\n        ctx.scale(scaleY, scaleY);\n        switch (align) {\n            case 'xMinYMin':\n            case 'xMinYMid':\n            case 'xMinYMax':\n                ctx.translate(-x, -y);\n                break;\n            case 'xMidYMin':\n            case 'xMidYMid':\n            case 'xMidYMax':\n                ctx.translate(-x - (logicalWidth - (width * logicalHeight) / height) / 2, -y);\n                break;\n            default:\n                ctx.translate(-x - (logicalWidth - (width * logicalHeight) / height), -y);\n        }\n    }\n    else {\n        ctx.scale(scaleX, scaleX);\n        switch (align) {\n            case 'xMinYMin':\n            case 'xMidYMin':\n            case 'xMaxYMin':\n                ctx.translate(-x, -y);\n                break;\n            case 'xMinYMid':\n            case 'xMidYMid':\n            case 'xMaxYMid':\n                ctx.translate(-x, -y - (logicalHeight - (height * logicalWidth) / width) / 2);\n                break;\n            default:\n                ctx.translate(-x, -y - (logicalHeight - (height * logicalWidth) / width));\n        }\n    }\n};\nconst moveToOrigin = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left } = node.box;\n    const paddingLeft = node.box.paddingLeft || 0;\n    const paddingTop = node.box.paddingTop || 0;\n    ctx.translate(left + paddingLeft, top + paddingTop);\n};\nconst renderSvg = (ctx, node) => {\n    ctx.save();\n    clipNode(ctx, node);\n    moveToOrigin(ctx, node);\n    resolveAspectRatio(ctx, node);\n    drawChildren(ctx, node);\n    ctx.restore();\n};\n\nconst black = { value: '#000', opacity: 1 };\n// TODO: parse to number[] in layout to avoid this step\nconst parseColor = (hex) => {\n    if (!hex)\n        return black;\n    const parsed = colorString.get(hex);\n    if (!parsed)\n        return black;\n    const value = colorString.to.hex(parsed.value.slice(0, 3));\n    const opacity = parsed.value[3];\n    return { value, opacity };\n};\n\nconst DEST_REGEXP = /^#.+/;\nconst isSrcId$1 = (src) => src.match(DEST_REGEXP);\nconst renderAttachment = (ctx, attachment) => {\n    const { xOffset = 0, yOffset = 0, width, height, image } = attachment;\n    ctx.translate(-width + xOffset, -height + yOffset);\n    ctx.image(image, 0, 0, {\n        fit: [width, height],\n        align: 'center',\n        valign: 'bottom',\n    });\n};\nconst renderAttachments = (ctx, run) => {\n    if (!run.glyphs)\n        return;\n    if (!run.positions)\n        return;\n    const font = run.attributes.font?.[0];\n    if (!font)\n        return;\n    ctx.save();\n    const space = font.glyphForCodePoint(0x20);\n    const objectReplacement = font.glyphForCodePoint(0xfffc);\n    let attachmentAdvance = 0;\n    for (let i = 0; i < run.glyphs.length; i += 1) {\n        const position = run.positions[i];\n        const glyph = run.glyphs[i];\n        attachmentAdvance += position.xAdvance || 0;\n        if (glyph.id === objectReplacement.id && run.attributes.attachment) {\n            ctx.translate(attachmentAdvance, position.yOffset || 0);\n            renderAttachment(ctx, run.attributes.attachment);\n            run.glyphs[i] = space;\n            attachmentAdvance = 0;\n        }\n    }\n    ctx.restore();\n};\nconst renderRun = (ctx, run) => {\n    if (!run.glyphs)\n        return;\n    if (!run.positions)\n        return;\n    const font = run.attributes.font?.[0];\n    if (!font)\n        return;\n    const { fontSize, link } = run.attributes;\n    const color = parseColor(run.attributes.color);\n    const opacity = isNil(run.attributes.opacity)\n        ? color.opacity\n        : run.attributes.opacity;\n    const { height = 0, descent = 0, xAdvance = 0 } = run;\n    ctx.fillColor(color.value);\n    ctx.fillOpacity(opacity);\n    if (link) {\n        if (isSrcId$1(link)) {\n            ctx.goTo(0, -height - descent, xAdvance, height, link.slice(1));\n        }\n        else {\n            ctx.link(0, -height - descent, xAdvance, height, link);\n        }\n    }\n    renderAttachments(ctx, run);\n    ctx.font(font.type === 'STANDARD' ? font.fullName : font, fontSize);\n    try {\n        renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);\n    }\n    catch (error) {\n        console.log(error);\n    }\n    ctx.translate(xAdvance, 0);\n};\nconst renderBackground$1 = (ctx, rect, backgroundColor) => {\n    const color = parseColor(backgroundColor);\n    ctx.save();\n    ctx.fillOpacity(color.opacity);\n    ctx.rect(rect.x, rect.y, rect.width, rect.height);\n    ctx.fill(color.value);\n    ctx.restore();\n};\nconst renderDecorationLine = (ctx, decorationLine) => {\n    ctx.save();\n    ctx.lineWidth(decorationLine.rect.height);\n    ctx.strokeOpacity(decorationLine.opacity);\n    if (/dashed/.test(decorationLine.style)) {\n        ctx.dash(3 * decorationLine.rect.height, {});\n    }\n    else if (/dotted/.test(decorationLine.style)) {\n        ctx.dash(decorationLine.rect.height, {});\n    }\n    if (/wavy/.test(decorationLine.style)) {\n        const dist = Math.max(2, decorationLine.rect.height);\n        let step = 1.1 * dist;\n        const stepCount = Math.floor(decorationLine.rect.width / (2 * step));\n        // Adjust step to fill entire width\n        const remainingWidth = decorationLine.rect.width - stepCount * 2 * step;\n        const adjustment = remainingWidth / stepCount / 2;\n        step += adjustment;\n        const cp1y = decorationLine.rect.y + dist;\n        const cp2y = decorationLine.rect.y - dist;\n        let { x } = decorationLine.rect;\n        ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y);\n        for (let i = 0; i < stepCount; i += 1) {\n            ctx.bezierCurveTo(x + step, cp1y, x + step, cp2y, x + 2 * step, decorationLine.rect.y);\n            x += 2 * step;\n        }\n    }\n    else {\n        ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y);\n        ctx.lineTo(decorationLine.rect.x + decorationLine.rect.width, decorationLine.rect.y);\n        if (/double/.test(decorationLine.style)) {\n            ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y + decorationLine.rect.height * 2);\n            ctx.lineTo(decorationLine.rect.x + decorationLine.rect.width, decorationLine.rect.y + decorationLine.rect.height * 2);\n        }\n    }\n    ctx.stroke(decorationLine.color);\n    ctx.restore();\n};\nconst renderLine = (ctx, line) => {\n    if (!line.box)\n        return;\n    const lineAscent = line.ascent || 0;\n    ctx.save();\n    ctx.translate(line.box.x, line.box.y + lineAscent);\n    for (let i = 0; i < line.runs.length; i += 1) {\n        const run = line.runs[i];\n        const isLastRun = i === line.runs.length - 1;\n        if (run.attributes.backgroundColor) {\n            const xAdvance = run.xAdvance ?? 0;\n            const overflowRight = isLastRun ? line.overflowRight ?? 0 : 0;\n            const backgroundRect = {\n                x: 0,\n                y: -lineAscent,\n                height: line.box.height,\n                width: xAdvance - overflowRight,\n            };\n            renderBackground$1(ctx, backgroundRect, run.attributes.backgroundColor);\n        }\n        renderRun(ctx, run);\n    }\n    ctx.restore();\n    ctx.save();\n    ctx.translate(line.box.x, line.box.y);\n    if (line.decorationLines) {\n        for (let i = 0; i < line.decorationLines.length; i += 1) {\n            const decorationLine = line.decorationLines[i];\n            renderDecorationLine(ctx, decorationLine);\n        }\n    }\n    ctx.restore();\n};\nconst renderBlock = (ctx, block) => {\n    block.forEach((line) => {\n        renderLine(ctx, line);\n    });\n};\nconst renderText = (ctx, node) => {\n    if (!node.box)\n        return;\n    if (!node.lines)\n        return;\n    const { top, left } = node.box;\n    const blocks = [node.lines];\n    const paddingTop = node.box?.paddingTop || 0;\n    const paddingLeft = node.box?.paddingLeft || 0;\n    const initialY = node.lines[0] ? node.lines[0].box.y : 0;\n    const offsetX = node.alignOffset || 0;\n    ctx.save();\n    ctx.translate(left + paddingLeft - offsetX, top + paddingTop - initialY);\n    blocks.forEach((block) => {\n        renderBlock(ctx, block);\n    });\n    ctx.restore();\n};\n\nconst renderPage = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { width, height } = node.box;\n    const dpi = node.props?.dpi || 72;\n    const userUnit = dpi / 72;\n    ctx.addPage({ size: [width, height], margin: 0, userUnit });\n};\n\nconst renderNote = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left } = node.box;\n    const value = node?.children?.[0].value || '';\n    const color = node.style?.backgroundColor;\n    ctx.note(left, top, 0, 0, value, { color });\n};\n\nconst embedImage = (ctx, node) => {\n    const src = node.image.data;\n    let image;\n    if (typeof src === 'string') {\n        image = ctx._imageRegistry[src];\n    }\n    if (!image) {\n        image = ctx.openImage(src);\n    }\n    if (!image.obj) {\n        image.embed(ctx);\n    }\n    return image;\n};\n\nconst isNumeric = (n) => {\n    return !Number.isNaN(parseFloat(n)) && Number.isFinite(n);\n};\nconst applyContainObjectFit = (cw, ch, iw, ih, px, py) => {\n    const cr = cw / ch;\n    const ir = iw / ih;\n    const pxp = matchPercent(px ?? null);\n    const pyp = matchPercent(py ?? null);\n    const pxv = pxp ? pxp.percent : 0.5;\n    const pyv = pyp ? pyp.percent : 0.5;\n    if (cr > ir) {\n        const height = ch;\n        const width = height * ir;\n        const yOffset = isNumeric(py) ? py : 0;\n        const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n        return { width, height, xOffset, yOffset };\n    }\n    const width = cw;\n    const height = width / ir;\n    const xOffset = isNumeric(px) ? px : 0;\n    const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n    return { width, height, yOffset, xOffset };\n};\nconst applyNoneObjectFit = (cw, ch, iw, ih, px, py) => {\n    const width = iw;\n    const height = ih;\n    const pxp = matchPercent(px ?? null);\n    const pyp = matchPercent(py ?? null);\n    const pxv = pxp ? pxp.percent : 0.5;\n    const pyv = pyp ? pyp.percent : 0.5;\n    const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n    const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n    return { width, height, xOffset, yOffset };\n};\nconst applyCoverObjectFit = (cw, ch, iw, ih, px, py) => {\n    const ir = iw / ih;\n    const cr = cw / ch;\n    const pxp = matchPercent(px ?? null);\n    const pyp = matchPercent(py ?? null);\n    const pxv = pxp ? pxp.percent : 0.5;\n    const pyv = pyp ? pyp.percent : 0.5;\n    if (cr > ir) {\n        const width = cw;\n        const height = width / ir;\n        const xOffset = isNumeric(px) ? px : 0;\n        const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n        return { width, height, yOffset, xOffset };\n    }\n    const height = ch;\n    const width = height * ir;\n    const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n    const yOffset = isNumeric(py) ? py : 0;\n    return { width, height, xOffset, yOffset };\n};\nconst applyScaleDownObjectFit = (cw, ch, iw, ih, px, py) => {\n    const containDimension = applyContainObjectFit(cw, ch, iw, ih, px, py);\n    const noneDimension = applyNoneObjectFit(cw, ch, iw, ih, px, py);\n    return containDimension.width < noneDimension.width\n        ? containDimension\n        : noneDimension;\n};\nconst applyFillObjectFit = (cw, ch, px, py) => {\n    return {\n        width: cw,\n        height: ch,\n        xOffset: matchPercent(px ?? null) ? 0 : px || 0,\n        yOffset: matchPercent(py ?? null) ? 0 : py || 0,\n    };\n};\nconst resolveObjectFit = (type = 'fill', cw, ch, iw, ih, px, py) => {\n    switch (type) {\n        case 'contain':\n            return applyContainObjectFit(cw, ch, iw, ih, px, py);\n        case 'cover':\n            return applyCoverObjectFit(cw, ch, iw, ih, px, py);\n        case 'none':\n            return applyNoneObjectFit(cw, ch, iw, ih, px, py);\n        case 'scale-down':\n            return applyScaleDownObjectFit(cw, ch, iw, ih, px, py);\n        default:\n            return applyFillObjectFit(cw, ch, px, py);\n    }\n};\n\nconst drawImage = (ctx, node, options) => {\n    if (!node.box)\n        return;\n    if (!node.image)\n        return;\n    const { left, top } = node.box;\n    const opacity = node.style?.opacity;\n    const objectFit = node.style?.objectFit;\n    const objectPositionX = node.style?.objectPositionX;\n    const objectPositionY = node.style?.objectPositionY;\n    const paddingTop = node.box.paddingTop || 0;\n    const paddingRight = node.box.paddingRight || 0;\n    const paddingBottom = node.box.paddingBottom || 0;\n    const paddingLeft = node.box.paddingLeft || 0;\n    const imageCache = options.imageCache || new Map();\n    const { width, height, xOffset, yOffset } = resolveObjectFit(objectFit, node.box.width - paddingLeft - paddingRight, node.box.height - paddingTop - paddingBottom, node.image.width, node.image.height, objectPositionX, objectPositionY);\n    if (node.image.data) {\n        if (width !== 0 && height !== 0) {\n            const cacheKey = node.image.key;\n            const image = imageCache.get(cacheKey) || embedImage(ctx, node);\n            if (cacheKey)\n                imageCache.set(cacheKey, image);\n            const imageOpacity = isNil(opacity) ? 1 : opacity;\n            ctx\n                .fillOpacity(imageOpacity)\n                .image(image, left + paddingLeft + xOffset, top + paddingTop + yOffset, {\n                width,\n                height,\n            });\n        }\n        else {\n            console.warn(`Image with src '${JSON.stringify(node.props.src || node.props.source)}' skipped due to invalid dimensions`);\n        }\n    }\n};\nconst renderImage = (ctx, node, options) => {\n    ctx.save();\n    clipNode(ctx, node);\n    drawImage(ctx, node, options);\n    ctx.restore();\n};\n\nconst CONTENT_COLOR = '#a1c6e7';\nconst PADDING_COLOR = '#c4deb9';\nconst MARGIN_COLOR = '#f8cca1';\n// TODO: Draw debug boxes using clipping to enhance quality\nconst debugContent = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { left, top, width, height, paddingLeft = 0, paddingTop = 0, paddingRight = 0, paddingBottom = 0, borderLeftWidth = 0, borderTopWidth = 0, borderRightWidth = 0, borderBottomWidth = 0, } = node.box;\n    ctx\n        .fillColor(CONTENT_COLOR)\n        .opacity(0.5)\n        .rect(left + paddingLeft + borderLeftWidth, top + paddingTop + borderTopWidth, width - paddingLeft - paddingRight - borderRightWidth - borderLeftWidth, height - paddingTop - paddingBottom - borderTopWidth - borderBottomWidth)\n        .fill();\n};\nconst debugPadding = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { left, top, width, height, paddingLeft = 0, paddingTop = 0, paddingRight = 0, paddingBottom = 0, borderLeftWidth = 0, borderTopWidth = 0, borderRightWidth = 0, borderBottomWidth = 0, } = node.box;\n    ctx.fillColor(PADDING_COLOR).opacity(0.5);\n    // Padding top\n    ctx\n        .rect(left + paddingLeft + borderLeftWidth, top + borderTopWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingTop)\n        .fill();\n    // Padding left\n    ctx\n        .rect(left + borderLeftWidth, top + borderTopWidth, paddingLeft, height - borderTopWidth - borderBottomWidth)\n        .fill();\n    // Padding right\n    ctx\n        .rect(left + width - paddingRight - borderRightWidth, top + borderTopWidth, paddingRight, height - borderTopWidth - borderBottomWidth)\n        .fill();\n    // Padding bottom\n    ctx\n        .rect(left + paddingLeft + borderLeftWidth, top + height - paddingBottom - borderBottomWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingBottom)\n        .fill();\n};\nconst debugMargin = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { left, top, width, height } = node.box;\n    const { marginLeft = 0, marginTop = 0, marginRight = 0, marginBottom = 0, } = node.box;\n    ctx.fillColor(MARGIN_COLOR).opacity(0.5);\n    // Margin top\n    ctx.rect(left, top - marginTop, width, marginTop).fill();\n    // Margin left\n    ctx\n        .rect(left - marginLeft, top - marginTop, marginLeft, height + marginTop + marginBottom)\n        .fill();\n    // Margin right\n    ctx\n        .rect(left + width, top - marginTop, marginRight, height + marginTop + marginBottom)\n        .fill();\n    // Margin bottom\n    ctx.rect(left, top + height, width, marginBottom).fill();\n};\nconst debugText = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { left, top, width, height } = node.box;\n    const { marginLeft = 0, marginTop = 0, marginRight = 0, marginBottom = 0, } = node.box;\n    const roundedWidth = Math.round(width + marginLeft + marginRight);\n    const roundedHeight = Math.round(height + marginTop + marginBottom);\n    ctx\n        .fontSize(6)\n        .opacity(1)\n        .fillColor('black')\n        .text(`${roundedWidth} x ${roundedHeight}`, left - marginLeft, Math.max(top - marginTop - 4, 1), { width: Infinity });\n};\nconst debugOrigin = (ctx, node) => {\n    if (node.origin) {\n        ctx\n            .circle(node.origin.left, node.origin.top, 3)\n            .fill('red')\n            .circle(node.origin.left, node.origin.top, 5)\n            .stroke('red');\n    }\n};\nconst renderDebug = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('debug' in node.props) || !node.props.debug)\n        return;\n    ctx.save();\n    debugContent(ctx, node);\n    debugPadding(ctx, node);\n    debugMargin(ctx, node);\n    debugText(ctx, node);\n    debugOrigin(ctx, node);\n    ctx.restore();\n};\n\nconst availableMethods = [\n    'dash',\n    'clip',\n    'save',\n    'path',\n    'fill',\n    'font',\n    'text',\n    'rect',\n    'scale',\n    'moveTo',\n    'lineTo',\n    'stroke',\n    'rotate',\n    'circle',\n    'lineCap',\n    'opacity',\n    'ellipse',\n    'polygon',\n    'restore',\n    'lineJoin',\n    'fontSize',\n    'fillColor',\n    'lineWidth',\n    'translate',\n    'miterLimit',\n    'strokeColor',\n    'fillOpacity',\n    'roundedRect',\n    'fillAndStroke',\n    'strokeOpacity',\n    'bezierCurveTo',\n    'quadraticCurveTo',\n    'linearGradient',\n    'radialGradient',\n];\nconst painter = (ctx) => {\n    const p = availableMethods.reduce((acc, prop) => ({\n        ...acc,\n        [prop]: (...args) => {\n            // @ts-expect-error ctx[prop] is a function\n            ctx[prop](...args);\n            return p;\n        },\n    }), {});\n    return p;\n};\nconst renderCanvas = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box;\n    const paddingTop = node.box.paddingTop || 0;\n    const paddingLeft = node.box.paddingLeft || 0;\n    const paddingRight = node.box.paddingRight || 0;\n    const paddingBottom = node.box.paddingBottom || 0;\n    const availableWidth = width - paddingLeft - paddingRight;\n    const availableHeight = height - paddingTop - paddingBottom;\n    if (!availableWidth || !availableHeight) {\n        console.warn('Canvas element has null width or height. Please provide valid values via the `style` prop in order to correctly render it.');\n    }\n    ctx.save().translate(left + paddingLeft, top + paddingTop);\n    if (node.props.paint) {\n        node.props.paint(painter(ctx), availableWidth, availableHeight);\n    }\n    ctx.restore();\n};\n\n// Ref: https://www.w3.org/TR/css-backgrounds-3/#borders\n// This constant is used to approximate a symmetrical arc using a cubic Bezier curve.\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst clipBorderTop = (ctx, layout, style, rtr, rtl) => {\n    const { top, left, width, height } = layout;\n    const { borderTopWidth, borderRightWidth, borderLeftWidth } = style;\n    // Clip outer top border edge\n    ctx.moveTo(left + rtl, top);\n    ctx.lineTo(left + width - rtr, top);\n    // Ellipse coefficients outer top right cap\n    const c0 = rtr * (1.0 - KAPPA);\n    // Clip outer top right cap\n    ctx.bezierCurveTo(left + width - c0, top, left + width, top + c0, left + width, top + rtr);\n    // Move down in case the margin exceedes the radius\n    const topRightYCoord = top + Math.max(borderTopWidth, rtr);\n    ctx.lineTo(left + width, topRightYCoord);\n    // Clip inner top right cap\n    ctx.lineTo(left + width - borderRightWidth, topRightYCoord);\n    // Ellipse coefficients inner top right cap\n    const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n    const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n    const c1 = innerTopRightRadiusX * (1.0 - KAPPA);\n    const c2 = innerTopRightRadiusY * (1.0 - KAPPA);\n    // Clip inner top right cap\n    ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c2, left + width - borderRightWidth - c1, top + borderTopWidth, left + width - borderRightWidth - innerTopRightRadiusX, top + borderTopWidth);\n    // Clip inner top border edge\n    ctx.lineTo(left + Math.max(rtl, borderLeftWidth), top + borderTopWidth);\n    // Ellipse coefficients inner top left cap\n    const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n    const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n    const c3 = innerTopLeftRadiusX * (1.0 - KAPPA);\n    const c4 = innerTopLeftRadiusY * (1.0 - KAPPA);\n    const topLeftYCoord = top + Math.max(borderTopWidth, rtl);\n    // Clip inner top left cap\n    ctx.bezierCurveTo(left + borderLeftWidth + c3, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c4, left + borderLeftWidth, topLeftYCoord);\n    ctx.lineTo(left, topLeftYCoord);\n    // Move down in case the margin exceedes the radius\n    ctx.lineTo(left, top + rtl);\n    // Ellipse coefficients outer top left cap\n    const c5 = rtl * (1.0 - KAPPA);\n    // Clip outer top left cap\n    ctx.bezierCurveTo(left, top + c5, left + c5, top, left + rtl, top);\n    ctx.closePath();\n    ctx.clip();\n    // Clip border top cap joins\n    if (borderRightWidth) {\n        const trSlope = -borderTopWidth / borderRightWidth;\n        ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n        ctx.lineTo(left + width, top);\n        ctx.lineTo(left, top);\n        ctx.lineTo(left, top + height);\n        ctx.closePath();\n        ctx.clip();\n    }\n    if (borderLeftWidth) {\n        const trSlope = -borderTopWidth / borderLeftWidth;\n        ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n        ctx.lineTo(left, top);\n        ctx.lineTo(left + width, top);\n        ctx.lineTo(left + width, top + height);\n        ctx.closePath();\n        ctx.clip();\n    }\n};\nconst fillBorderTop = (ctx, layout, style, rtr, rtl) => {\n    const { top, left, width } = layout;\n    const { borderTopColor, borderTopWidth, borderTopStyle, borderRightWidth, borderLeftWidth, } = style;\n    const c0 = rtl * (1.0 - KAPPA);\n    const c1 = rtr * (1.0 - KAPPA);\n    ctx.moveTo(left, top + Math.max(rtl, borderTopWidth));\n    ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n    ctx.lineTo(left + width - rtr, top);\n    ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n    ctx.strokeColor(borderTopColor);\n    ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderLeftWidth) * 2);\n    if (borderTopStyle === 'dashed') {\n        ctx.dash(borderTopWidth * 2, { space: borderTopWidth * 1.2 });\n    }\n    else if (borderTopStyle === 'dotted') {\n        ctx.dash(borderTopWidth, { space: borderTopWidth * 1.2 });\n    }\n    ctx.stroke();\n    ctx.undash();\n};\nconst clipBorderRight = (ctx, layout, style, rtr, rbr) => {\n    const { top, left, width, height } = layout;\n    const { borderTopWidth, borderRightWidth, borderBottomWidth } = style;\n    // Clip outer right border edge\n    ctx.moveTo(left + width, top + rtr);\n    ctx.lineTo(left + width, top + height - rbr);\n    // Ellipse coefficients outer bottom right cap\n    const c0 = rbr * (1.0 - KAPPA);\n    // Clip outer top right cap\n    ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n    // Move left in case the margin exceedes the radius\n    const topBottomXCoord = left + width - Math.max(borderRightWidth, rbr);\n    ctx.lineTo(topBottomXCoord, top + height);\n    // Clip inner bottom right cap\n    ctx.lineTo(topBottomXCoord, top + height - borderBottomWidth);\n    // Ellipse coefficients inner bottom right cap\n    const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n    const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n    const c1 = innerBottomRightRadiusX * (1.0 - KAPPA);\n    const c2 = innerBottomRightRadiusY * (1.0 - KAPPA);\n    // Clip inner top right cap\n    ctx.bezierCurveTo(left + width - borderRightWidth - c1, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c2, left + width - borderRightWidth, top + height - Math.max(rbr, borderBottomWidth));\n    // Clip inner right border edge\n    ctx.lineTo(left + width - borderRightWidth, top + Math.max(rtr, borderTopWidth));\n    // Ellipse coefficients inner top right cap\n    const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n    const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n    const c3 = innerTopRightRadiusX * (1.0 - KAPPA);\n    const c4 = innerTopRightRadiusY * (1.0 - KAPPA);\n    const topRightXCoord = left + width - Math.max(rtr, borderRightWidth);\n    // Clip inner top left cap\n    ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c4, left + width - borderRightWidth - c3, top + borderTopWidth, topRightXCoord, top + borderTopWidth);\n    ctx.lineTo(topRightXCoord, top);\n    // Move right in case the margin exceedes the radius\n    ctx.lineTo(left + width - rtr, top);\n    // Ellipse coefficients outer top right cap\n    const c5 = rtr * (1.0 - KAPPA);\n    // Clip outer top right cap\n    ctx.bezierCurveTo(left + width - c5, top, left + width, top + c5, left + width, top + rtr);\n    ctx.closePath();\n    ctx.clip();\n    // Clip border right cap joins\n    if (borderTopWidth) {\n        const trSlope = -borderTopWidth / borderRightWidth;\n        ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n        ctx.lineTo(left + width, top);\n        ctx.lineTo(left + width, top + height);\n        ctx.lineTo(left, top + height);\n        ctx.closePath();\n        ctx.clip();\n    }\n    if (borderBottomWidth) {\n        const brSlope = borderBottomWidth / borderRightWidth;\n        ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n        ctx.lineTo(left + width, top + height);\n        ctx.lineTo(left + width, top);\n        ctx.lineTo(left, top);\n        ctx.closePath();\n        ctx.clip();\n    }\n};\nconst fillBorderRight = (ctx, layout, style, rtr, rbr) => {\n    const { top, left, width, height } = layout;\n    const { borderRightColor, borderRightStyle, borderRightWidth, borderTopWidth, borderBottomWidth, } = style;\n    const c0 = rbr * (1.0 - KAPPA);\n    const c1 = rtr * (1.0 - KAPPA);\n    ctx.moveTo(left + width - rtr, top);\n    ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n    ctx.lineTo(left + width, top + height - rbr);\n    ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n    ctx.strokeColor(borderRightColor);\n    ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderBottomWidth) * 2);\n    if (borderRightStyle === 'dashed') {\n        ctx.dash(borderRightWidth * 2, { space: borderRightWidth * 1.2 });\n    }\n    else if (borderRightStyle === 'dotted') {\n        ctx.dash(borderRightWidth, { space: borderRightWidth * 1.2 });\n    }\n    ctx.stroke();\n    ctx.undash();\n};\nconst clipBorderBottom = (ctx, layout, style, rbl, rbr) => {\n    const { top, left, width, height } = layout;\n    const { borderBottomWidth, borderRightWidth, borderLeftWidth } = style;\n    // Clip outer top border edge\n    ctx.moveTo(left + width - rbr, top + height);\n    ctx.lineTo(left + rbl, top + height);\n    // Ellipse coefficients outer top right cap\n    const c0 = rbl * (1.0 - KAPPA);\n    // Clip outer top right cap\n    ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n    // Move up in case the margin exceedes the radius\n    const bottomLeftYCoord = top + height - Math.max(borderBottomWidth, rbl);\n    ctx.lineTo(left, bottomLeftYCoord);\n    // Clip inner bottom left cap\n    ctx.lineTo(left + borderLeftWidth, bottomLeftYCoord);\n    // Ellipse coefficients inner top right cap\n    const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n    const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n    const c1 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n    const c2 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n    // Clip inner bottom left cap\n    ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c2, left + borderLeftWidth + c1, top + height - borderBottomWidth, left + borderLeftWidth + innerBottomLeftRadiusX, top + height - borderBottomWidth);\n    // Clip inner bottom border edge\n    ctx.lineTo(left + width - Math.max(rbr, borderRightWidth), top + height - borderBottomWidth);\n    // Ellipse coefficients inner top left cap\n    const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n    const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n    const c3 = innerBottomRightRadiusX * (1.0 - KAPPA);\n    const c4 = innerBottomRightRadiusY * (1.0 - KAPPA);\n    const bottomRightYCoord = top + height - Math.max(borderBottomWidth, rbr);\n    // Clip inner top left cap\n    ctx.bezierCurveTo(left + width - borderRightWidth - c3, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c4, left + width - borderRightWidth, bottomRightYCoord);\n    ctx.lineTo(left + width, bottomRightYCoord);\n    // Move down in case the margin exceedes the radius\n    ctx.lineTo(left + width, top + height - rbr);\n    // Ellipse coefficients outer top left cap\n    const c5 = rbr * (1.0 - KAPPA);\n    // Clip outer top left cap\n    ctx.bezierCurveTo(left + width, top + height - c5, left + width - c5, top + height, left + width - rbr, top + height);\n    ctx.closePath();\n    ctx.clip();\n    // Clip border bottom cap joins\n    if (borderRightWidth) {\n        const brSlope = borderBottomWidth / borderRightWidth;\n        ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n        ctx.lineTo(left + width, top + height);\n        ctx.lineTo(left, top + height);\n        ctx.lineTo(left, top);\n        ctx.closePath();\n        ctx.clip();\n    }\n    if (borderLeftWidth) {\n        const trSlope = -borderBottomWidth / borderLeftWidth;\n        ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n        ctx.lineTo(left, top + height);\n        ctx.lineTo(left + width, top + height);\n        ctx.lineTo(left + width, top);\n        ctx.closePath();\n        ctx.clip();\n    }\n};\nconst fillBorderBottom = (ctx, layout, style, rbl, rbr) => {\n    const { top, left, width, height } = layout;\n    const { borderBottomColor, borderBottomStyle, borderBottomWidth, borderRightWidth, borderLeftWidth, } = style;\n    const c0 = rbl * (1.0 - KAPPA);\n    const c1 = rbr * (1.0 - KAPPA);\n    ctx.moveTo(left + width, top + height - rbr);\n    ctx.bezierCurveTo(left + width, top + height - c1, left + width - c1, top + height, left + width - rbr, top + height);\n    ctx.lineTo(left + rbl, top + height);\n    ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n    ctx.strokeColor(borderBottomColor);\n    ctx.lineWidth(Math.max(borderBottomWidth, borderRightWidth, borderLeftWidth) * 2);\n    if (borderBottomStyle === 'dashed') {\n        ctx.dash(borderBottomWidth * 2, { space: borderBottomWidth * 1.2 });\n    }\n    else if (borderBottomStyle === 'dotted') {\n        ctx.dash(borderBottomWidth, { space: borderBottomWidth * 1.2 });\n    }\n    ctx.stroke();\n    ctx.undash();\n};\nconst clipBorderLeft = (ctx, layout, style, rbl, rtl) => {\n    const { top, left, width, height } = layout;\n    const { borderTopWidth, borderLeftWidth, borderBottomWidth } = style;\n    // Clip outer left border edge\n    ctx.moveTo(left, top + height - rbl);\n    ctx.lineTo(left, top + rtl);\n    // Ellipse coefficients outer top left cap\n    const c0 = rtl * (1.0 - KAPPA);\n    // Clip outer top left cap\n    ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n    // Move right in case the margin exceedes the radius\n    const topLeftCoordX = left + Math.max(borderLeftWidth, rtl);\n    ctx.lineTo(topLeftCoordX, top);\n    // Clip inner top left cap\n    ctx.lineTo(topLeftCoordX, top + borderTopWidth);\n    // Ellipse coefficients inner top left cap\n    const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n    const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n    const c1 = innerTopLeftRadiusX * (1.0 - KAPPA);\n    const c2 = innerTopLeftRadiusY * (1.0 - KAPPA);\n    // Clip inner top right cap\n    ctx.bezierCurveTo(left + borderLeftWidth + c1, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c2, left + borderLeftWidth, top + Math.max(rtl, borderTopWidth));\n    // Clip inner left border edge\n    ctx.lineTo(left + borderLeftWidth, top + height - Math.max(rbl, borderBottomWidth));\n    // Ellipse coefficients inner bottom left cap\n    const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n    const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n    const c3 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n    const c4 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n    const bottomLeftXCoord = left + Math.max(rbl, borderLeftWidth);\n    // Clip inner top left cap\n    ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c4, left + borderLeftWidth + c3, top + height - borderBottomWidth, bottomLeftXCoord, top + height - borderBottomWidth);\n    ctx.lineTo(bottomLeftXCoord, top + height);\n    // Move left in case the margin exceedes the radius\n    ctx.lineTo(left + rbl, top + height);\n    // Ellipse coefficients outer top right cap\n    const c5 = rbl * (1.0 - KAPPA);\n    // Clip outer top right cap\n    ctx.bezierCurveTo(left + c5, top + height, left, top + height - c5, left, top + height - rbl);\n    ctx.closePath();\n    ctx.clip();\n    // Clip border right cap joins\n    if (borderBottomWidth) {\n        const trSlope = -borderBottomWidth / borderLeftWidth;\n        ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n        ctx.lineTo(left, top + height);\n        ctx.lineTo(left, top);\n        ctx.lineTo(left + width, top);\n        ctx.closePath();\n        ctx.clip();\n    }\n    if (borderBottomWidth) {\n        const trSlope = -borderTopWidth / borderLeftWidth;\n        ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n        ctx.lineTo(left, top);\n        ctx.lineTo(left, top + height);\n        ctx.lineTo(left + width, top + height);\n        ctx.closePath();\n        ctx.clip();\n    }\n};\nconst fillBorderLeft = (ctx, layout, style, rbl, rtl) => {\n    const { top, left, height } = layout;\n    const { borderLeftColor, borderLeftStyle, borderLeftWidth, borderTopWidth, borderBottomWidth, } = style;\n    const c0 = rbl * (1.0 - KAPPA);\n    const c1 = rtl * (1.0 - KAPPA);\n    ctx.moveTo(left + rbl, top + height);\n    ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n    ctx.lineTo(left, top + rtl);\n    ctx.bezierCurveTo(left, top + c1, left + c1, top, left + rtl, top);\n    ctx.strokeColor(borderLeftColor);\n    ctx.lineWidth(Math.max(borderLeftWidth, borderTopWidth, borderBottomWidth) * 2);\n    if (borderLeftStyle === 'dashed') {\n        ctx.dash(borderLeftWidth * 2, { space: borderLeftWidth * 1.2 });\n    }\n    else if (borderLeftStyle === 'dotted') {\n        ctx.dash(borderLeftWidth, { space: borderLeftWidth * 1.2 });\n    }\n    ctx.stroke();\n    ctx.undash();\n};\nconst shouldRenderBorders = (node) => node.box &&\n    (node.box.borderTopWidth ||\n        node.box.borderRightWidth ||\n        node.box.borderBottomWidth ||\n        node.box.borderLeftWidth);\nconst renderBorders = (ctx, node) => {\n    if (!node.box)\n        return;\n    if (!shouldRenderBorders(node))\n        return;\n    const { width, height, borderTopWidth = 0, borderLeftWidth = 0, borderRightWidth = 0, borderBottomWidth = 0, } = node.box;\n    const { opacity = 1, borderTopColor = 'black', borderTopStyle = 'solid', borderLeftColor = 'black', borderLeftStyle = 'solid', borderRightColor = 'black', borderRightStyle = 'solid', borderBottomColor = 'black', borderBottomStyle = 'solid', } = node.style;\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const borderTopLeftRadius = node.style.borderTopLeftRadius || 0;\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const borderTopRightRadius = node.style.borderTopRightRadius || 0;\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const borderBottomLeftRadius = node.style.borderBottomLeftRadius || 0;\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const borderBottomRightRadius = node.style.borderBottomRightRadius || 0;\n    const style = {\n        borderTopColor,\n        borderTopWidth,\n        borderTopStyle,\n        borderLeftColor,\n        borderLeftWidth,\n        borderLeftStyle,\n        borderRightColor,\n        borderRightWidth,\n        borderRightStyle,\n        borderBottomColor,\n        borderBottomWidth,\n        borderBottomStyle};\n    const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n    const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n    const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n    const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n    ctx.save();\n    ctx.strokeOpacity(opacity);\n    if (borderTopWidth) {\n        ctx.save();\n        clipBorderTop(ctx, node.box, style, rtr, rtl);\n        fillBorderTop(ctx, node.box, style, rtr, rtl);\n        ctx.restore();\n    }\n    if (borderRightWidth) {\n        ctx.save();\n        clipBorderRight(ctx, node.box, style, rtr, rbr);\n        fillBorderRight(ctx, node.box, style, rtr, rbr);\n        ctx.restore();\n    }\n    if (borderBottomWidth) {\n        ctx.save();\n        clipBorderBottom(ctx, node.box, style, rbl, rbr);\n        fillBorderBottom(ctx, node.box, style, rbl, rbr);\n        ctx.restore();\n    }\n    if (borderLeftWidth) {\n        ctx.save();\n        clipBorderLeft(ctx, node.box, style, rbl, rtl);\n        fillBorderLeft(ctx, node.box, style, rbl, rtl);\n        ctx.restore();\n    }\n    ctx.restore();\n};\n\nconst drawBackground = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box;\n    const color = parseColor(node.style.backgroundColor);\n    const nodeOpacity = isNil(node.style?.opacity) ? 1 : node.style.opacity;\n    const opacity = Math.min(color.opacity, nodeOpacity);\n    ctx\n        .fillOpacity(opacity)\n        .fillColor(color.value)\n        .rect(left, top, width, height)\n        .fill();\n};\nconst renderBackground = (ctx, node) => {\n    const hasBackground = !!node.box && !!node.style?.backgroundColor;\n    if (hasBackground) {\n        ctx.save();\n        clipNode(ctx, node);\n        drawBackground(ctx, node);\n        ctx.restore();\n    }\n};\n\nconst isString = (value) => typeof value === 'string';\nconst isSrcId = (value) => /^#.+/.test(value);\nconst renderLink = (ctx, node, src) => {\n    if (!src || !node.box)\n        return;\n    const isId = isSrcId(src);\n    const method = isId ? 'goTo' : 'link';\n    const value = isId ? src.slice(1) : src;\n    const { top, left, width, height } = node.box;\n    ctx[method](left, top, width, height, value);\n};\nconst setLink = (ctx, node) => {\n    const props = node.props || {};\n    if ('src' in props && isString(props.src))\n        return renderLink(ctx, node, props.src);\n    if ('href' in props && isString(props.href))\n        return renderLink(ctx, node, props.href);\n};\n\nconst setDestination = (ctx, node) => {\n    if (!node.box)\n        return;\n    if (!node.props)\n        return;\n    if ('id' in node.props) {\n        ctx.addNamedDestination(node.props.id, 'XYZ', null, node.box.top, null);\n    }\n};\n\nconst clean = (options) => {\n    const opt = { ...options };\n    // We need to ensure the elements are no present if not true\n    Object.entries(opt).forEach((pair) => {\n        if (!pair[1]) {\n            delete opt[pair[0]];\n        }\n    });\n    return opt;\n};\nconst parseCommonFormOptions = (node) => {\n    // Common Options\n    return {\n        required: node.props?.required || false,\n        noExport: node.props?.noExport || false,\n        readOnly: node.props?.readOnly || false,\n        value: node.props?.value || undefined,\n        defaultValue: node.props?.defaultValue || undefined,\n    };\n};\nconst parseTextInputOptions = (node, fieldSet) => {\n    return clean({\n        ...parseCommonFormOptions(node),\n        parent: fieldSet || undefined,\n        align: node.props?.align || 'left',\n        multiline: node.props?.multiline || undefined,\n        password: node.props?.password || false,\n        noSpell: node.props?.noSpell || false,\n        format: node.props?.format || undefined,\n        fontSize: node.props?.fontSize || undefined,\n        MaxLen: node.props?.maxLength || undefined,\n    });\n};\nconst parseSelectAndListFieldOptions = (node) => {\n    return clean({\n        ...parseCommonFormOptions(node),\n        sort: node.props?.sort || false,\n        edit: node.props?.edit || false,\n        multiSelect: node.props?.multiSelect || false,\n        noSpell: node.props?.noSpell || false,\n        select: node.props?.select || [''],\n    });\n};\nconst getAppearance = (ctx, codepoint, width, height) => {\n    const appearance = ctx.ref({\n        Type: 'XObject',\n        Subtype: 'Form',\n        BBox: [0, 0, width, height],\n        Resources: {\n            ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI'],\n            Font: {\n                ZaDi: ctx._acroform.fonts.ZaDi,\n            },\n        },\n    });\n    appearance.initDeflate();\n    appearance.write(`/Tx BMC\\nq\\n/ZaDi ${height * 0.8} Tf\\nBT\\n${width * 0.45} ${height / 4} Td (${codepoint}) Tj\\nET\\nQ\\nEMC`);\n    appearance.end(null);\n    return appearance;\n};\nconst parseCheckboxOptions = (ctx, node, fieldSet) => {\n    const { width, height } = node.box || {};\n    const onOption = node.props?.onState || 'Yes';\n    const offOption = node.props?.offState || 'Off';\n    const xMark = node.props?.xMark || false;\n    if (!Object.prototype.hasOwnProperty.call(ctx._acroform.fonts, 'ZaDi')) {\n        const ref = ctx.ref({\n            Type: 'Font',\n            Subtype: 'Type1',\n            BaseFont: 'ZapfDingbats',\n        });\n        ctx._acroform.fonts.ZaDi = ref;\n        ref.end(null);\n    }\n    const normalAppearance = {\n        [onOption]: getAppearance(ctx, xMark ? '8' : '4', width, height),\n        [offOption]: getAppearance(ctx, xMark ? ' ' : '8', width, height),\n    };\n    return clean({\n        ...parseCommonFormOptions(node),\n        backgroundColor: node.props?.backgroundColor || undefined,\n        borderColor: node.props?.borderColor || undefined,\n        parent: fieldSet || undefined,\n        value: `/${node.props?.checked === true ? onOption : offOption}`,\n        defaultValue: `/${node.props?.checked === true ? onOption : offOption}`,\n        AS: node.props?.checked === true ? onOption : offOption,\n        AP: { N: normalAppearance, D: normalAppearance },\n    });\n};\n\nconst renderTextInput = (ctx, node, options) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box;\n    // Element's name\n    const name = node.props?.name || '';\n    const fieldSetOptions = options.fieldSets?.at(0);\n    if (!ctx._root.data.AcroForm) {\n        ctx.initForm();\n    }\n    ctx.formText(name, left, top, width, height, parseTextInputOptions(node, fieldSetOptions));\n};\n\nconst renderSelect = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box;\n    // Element's name\n    const name = node.props?.name || '';\n    if (!ctx._root.data.AcroForm) {\n        ctx.initForm();\n    }\n    ctx.formCombo(name, left, top, width, height, parseSelectAndListFieldOptions(node));\n};\n\nconst renderFieldSet = (ctx, node, options) => {\n    const name = node.props?.name || '';\n    if (!ctx._root.data.AcroForm) {\n        ctx.initForm();\n    }\n    const formField = ctx.formField(name);\n    const option = options;\n    if (!option.fieldSets) {\n        option.fieldSets = [formField];\n    }\n    else {\n        option.fieldSets.push(formField);\n    }\n};\nconst cleanUpFieldSet = (_ctx, _node, options) => {\n    options.fieldSets.pop();\n};\n\nconst renderList = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box || {};\n    // Element's name\n    const name = ('name' in node.props ? node.props.name || '' : '');\n    if (!ctx._root.data.AcroForm) {\n        ctx.initForm();\n    }\n    ctx.formList(name, left, top, width, height, parseSelectAndListFieldOptions(node));\n};\n\nconst renderCheckbox = (ctx, node, options) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box;\n    // Element's name\n    const name = node.props?.name || '';\n    const fieldSetOptions = options.fieldSets?.at(0);\n    if (!ctx._root.data.AcroForm) {\n        ctx.initForm();\n    }\n    ctx.formCheckbox(name, left, top, width, height, parseCheckboxOptions(ctx, node, fieldSetOptions));\n};\n\nconst isRecursiveNode = (node) => node.type !== P.Text && node.type !== P.Svg;\nconst renderChildren = (ctx, node, options) => {\n    ctx.save();\n    if (node.box) {\n        ctx.translate(node.box.left, node.box.top);\n    }\n    const children = node.children || [];\n    const renderChild = (child) => renderNode(ctx, child, options);\n    children.forEach(renderChild);\n    ctx.restore();\n};\nconst renderFns = {\n    [P.Text]: renderText,\n    [P.Note]: renderNote,\n    [P.Image]: renderImage,\n    [P.FieldSet]: renderFieldSet,\n    [P.TextInput]: renderTextInput,\n    [P.Select]: renderSelect,\n    [P.Checkbox]: renderCheckbox,\n    [P.List]: renderList,\n    [P.Canvas]: renderCanvas,\n    [P.Svg]: renderSvg,\n    [P.Link]: setLink,\n};\nconst cleanUpFns = {\n    [P.FieldSet]: cleanUpFieldSet,\n};\nconst renderNode = (ctx, node, options) => {\n    const overflowHidden = node.style?.overflow === 'hidden';\n    const shouldRenderChildren = isRecursiveNode(node);\n    if (node.type === P.Page)\n        renderPage(ctx, node);\n    ctx.save();\n    if (overflowHidden)\n        clipNode(ctx, node);\n    applyTransformations(ctx, node);\n    renderBackground(ctx, node);\n    renderBorders(ctx, node);\n    const renderFn = renderFns[node.type];\n    if (renderFn)\n        renderFn(ctx, node, options);\n    if (shouldRenderChildren)\n        renderChildren(ctx, node, options);\n    const cleanUpFn = cleanUpFns[node.type];\n    if (cleanUpFn)\n        cleanUpFn(ctx, node, options);\n    setDestination(ctx, node);\n    renderDebug(ctx, node);\n    ctx.restore();\n};\n\nconst addNodeBookmark = (ctx, node, pageNumber, registry) => {\n    if (!node.box)\n        return;\n    if (!node.props)\n        return;\n    if ('bookmark' in node.props && node.props.bookmark) {\n        const bookmark = node.props.bookmark;\n        const { title, parent, expanded, zoom, fit } = bookmark;\n        const outline = registry[parent] || ctx.outline;\n        const top = bookmark.top || node.box.top;\n        const left = bookmark.left || node.box.left;\n        const instance = outline.addItem(title, {\n            pageNumber,\n            expanded,\n            top,\n            left,\n            zoom,\n            fit,\n        });\n        registry[bookmark.ref] = instance;\n    }\n    if (!node.children)\n        return;\n    node.children.forEach((child) => addNodeBookmark(ctx, child, pageNumber, registry));\n};\nconst addBookmarks = (ctx, root) => {\n    const registry = {};\n    const pages = root.children || [];\n    pages.forEach((page, i) => {\n        addNodeBookmark(ctx, page, i, registry);\n    });\n};\n\nconst render = (ctx, doc) => {\n    const pages = doc.children || [];\n    const options = { imageCache: new Map(), fieldSets: [] };\n    pages.forEach((page) => renderNode(ctx, page, options));\n    addBookmarks(ctx, doc);\n    ctx.end();\n    return ctx;\n};\n\nexport { render as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
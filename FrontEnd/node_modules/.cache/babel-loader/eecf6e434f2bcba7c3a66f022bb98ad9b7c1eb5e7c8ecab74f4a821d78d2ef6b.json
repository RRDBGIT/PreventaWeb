{"ast":null,"code":"import _objectSpread from \"C:/PreventaWeb/FrontEnd/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { compose, castArray, parseFloat as parseFloat$1, matchPercent } from '@react-pdf/fns';\nimport matchMedia from 'media-engine';\nimport hlsToHex from 'hsl-to-hex';\nimport colorString from 'color-string';\nimport parse$1 from 'postcss-value-parser/lib/parse.js';\nimport parseUnit from 'postcss-value-parser/lib/unit.js';\n\n/**\n * Remove nil values from array\n *\n * @param array - Style array\n * @returns Style array without nils\n */\nconst compact = array => array.filter(Boolean);\n/**\n * Merges style objects array\n *\n * @param styles - Style array\n * @returns Merged style object\n */\nconst mergeStyles = styles => styles.reduce((acc, style) => {\n  const s = Array.isArray(style) ? flatten(style) : style;\n  Object.keys(s).forEach(key => {\n    if (s[key] !== null && s[key] !== undefined) {\n      acc[key] = s[key];\n    }\n  });\n  return acc;\n}, {});\n/**\n * Flattens an array of style objects, into one aggregated style object.\n *\n * @param styles - Style or style array\n * @returns Flattened style object\n */\nconst flatten = compose(mergeStyles, compact, castArray);\n\n/**\n * Resolves media queries in styles object\n *\n * @param container - Container for which styles are resolved\n * @param style - Style description\n * @returns Resolved style object\n */\nconst resolveMediaQueries = (container, style) => {\n  return Object.keys(style).reduce((acc, key) => {\n    if (/@media/.test(key)) {\n      return _objectSpread(_objectSpread({}, acc), matchMedia({\n        [key]: style[key]\n      }, container));\n    }\n    return _objectSpread(_objectSpread({}, acc), {}, {\n      [key]: style[key]\n    });\n  }, {});\n};\nconst isRgb = value => /rgba?/g.test(value);\nconst isHsl = value => /hsla?/g.test(value);\n/**\n * Transform rgb color to hexa\n *\n * @param value - Styles value\n * @returns Transformed value\n */\nconst parseRgb = value => {\n  const rgb = colorString.get.rgb(value);\n  return colorString.to.hex(rgb);\n};\n/**\n * Transform Hsl color to hexa\n *\n * @param value - Styles value\n * @returns Transformed value\n */\nconst parseHsl = value => {\n  const hsl = colorString.get.hsl(value).map(Math.round);\n  const hex = hlsToHex(...hsl);\n  return hex.toUpperCase();\n};\n/**\n * Transform given color to hexa\n *\n * @param value - Styles value\n * @returns Transformed value\n */\nconst transformColor = value => {\n  if (isRgb(value)) return parseRgb(value);\n  if (isHsl(value)) return parseHsl(value);\n  return value;\n};\n\n/**\n * Parses scalar value in value and unit pairs\n *\n * @param value - Scalar value\n * @returns Parsed value\n */\nconst parseValue = value => {\n  if (typeof value === 'number') return {\n    value,\n    unit: undefined\n  };\n  const match = /^(-?\\d*\\.?\\d+)(in|mm|cm|pt|vh|vw|px|rem)?$/g.exec(value);\n  return match ? {\n    value: parseFloat(match[1]),\n    unit: match[2] || 'pt'\n  } : {\n    value,\n    unit: undefined\n  };\n};\n/**\n * Transform given scalar value\n *\n * @param container\n * @param value - Styles value\n * @returns Transformed value\n */\nconst transformUnit = (container, value) => {\n  const scalar = parseValue(value);\n  const outputDpi = 72;\n  const inputDpi = container.dpi || 72;\n  const mmFactor = 1 / 25.4 * outputDpi;\n  const cmFactor = 1 / 2.54 * outputDpi;\n  if (typeof scalar.value !== 'number') return scalar.value;\n  switch (scalar.unit) {\n    case 'rem':\n      return scalar.value * (container.remBase || 18);\n    case 'in':\n      return scalar.value * outputDpi;\n    case 'mm':\n      return scalar.value * mmFactor;\n    case 'cm':\n      return scalar.value * cmFactor;\n    case 'vh':\n      return scalar.value * (container.height / 100);\n    case 'vw':\n      return scalar.value * (container.width / 100);\n    case 'px':\n      return Math.round(scalar.value * (outputDpi / inputDpi));\n    default:\n      return scalar.value;\n  }\n};\nconst processNumberValue = (key, value) => ({\n  [key]: parseFloat$1(value)\n});\nconst processUnitValue = (key, value, container) => ({\n  [key]: transformUnit(container, value)\n});\nconst processColorValue = (key, value) => {\n  const result = {\n    [key]: transformColor(value)\n  };\n  return result;\n};\nconst processNoopValue = (key, value) => ({\n  [key]: value\n});\nconst BORDER_SHORTHAND_REGEX = /(-?\\d+(\\.\\d+)?(in|mm|cm|pt|vw|vh|px|rem)?)\\s(\\S+)\\s(.+)/;\nconst matchBorderShorthand = value => value.match(BORDER_SHORTHAND_REGEX) || [];\nconst resolveBorderShorthand = (key, value, container) => {\n  const match = matchBorderShorthand(\"\".concat(value));\n  if (match) {\n    const widthMatch = match[1] || value;\n    const styleMatch = match[4] || value;\n    const colorMatch = match[5] || value;\n    const style = styleMatch;\n    const color = colorMatch ? transformColor(colorMatch) : undefined;\n    const width = widthMatch ? transformUnit(container, widthMatch) : undefined;\n    if (key.match(/(Top|Right|Bottom|Left)$/)) {\n      return {\n        [\"\".concat(key, \"Color\")]: color,\n        [\"\".concat(key, \"Style\")]: style,\n        [\"\".concat(key, \"Width\")]: width\n      };\n    }\n    if (key.match(/Color$/)) {\n      return {\n        borderTopColor: color,\n        borderRightColor: color,\n        borderBottomColor: color,\n        borderLeftColor: color\n      };\n    }\n    if (key.match(/Style$/)) {\n      if (typeof style === 'number') throw new Error(\"Invalid border style: \".concat(style));\n      return {\n        borderTopStyle: style,\n        borderRightStyle: style,\n        borderBottomStyle: style,\n        borderLeftStyle: style\n      };\n    }\n    if (key.match(/Width$/)) {\n      if (typeof width !== 'number') throw new Error(\"Invalid border width: \".concat(width));\n      return {\n        borderTopWidth: width,\n        borderRightWidth: width,\n        borderBottomWidth: width,\n        borderLeftWidth: width\n      };\n    }\n    if (key.match(/Radius$/)) {\n      const radius = value ? transformUnit(container, value) : undefined;\n      if (typeof radius !== 'number') throw new Error(\"Invalid border radius: \".concat(radius));\n      return {\n        borderTopLeftRadius: radius,\n        borderTopRightRadius: radius,\n        borderBottomRightRadius: radius,\n        borderBottomLeftRadius: radius\n      };\n    }\n    if (typeof width !== 'number') throw new Error(\"Invalid border width: \".concat(width));\n    if (typeof style === 'number') throw new Error(\"Invalid border style: \".concat(style));\n    return {\n      borderTopColor: color,\n      borderTopStyle: style,\n      borderTopWidth: width,\n      borderRightColor: color,\n      borderRightStyle: style,\n      borderRightWidth: width,\n      borderBottomColor: color,\n      borderBottomStyle: style,\n      borderBottomWidth: width,\n      borderLeftColor: color,\n      borderLeftStyle: style,\n      borderLeftWidth: width\n    };\n  }\n  return {\n    [key]: value\n  };\n};\nconst handlers$b = {\n  border: resolveBorderShorthand,\n  borderBottom: resolveBorderShorthand,\n  borderBottomColor: processColorValue,\n  borderBottomLeftRadius: processUnitValue,\n  borderBottomRightRadius: processUnitValue,\n  borderBottomStyle: processNoopValue,\n  borderBottomWidth: processUnitValue,\n  borderColor: resolveBorderShorthand,\n  borderLeft: resolveBorderShorthand,\n  borderLeftColor: processColorValue,\n  borderLeftStyle: processNoopValue,\n  borderLeftWidth: processUnitValue,\n  borderRadius: resolveBorderShorthand,\n  borderRight: resolveBorderShorthand,\n  borderRightColor: processColorValue,\n  borderRightStyle: processNoopValue,\n  borderRightWidth: processUnitValue,\n  borderStyle: resolveBorderShorthand,\n  borderTop: resolveBorderShorthand,\n  borderTopColor: processColorValue,\n  borderTopLeftRadius: processUnitValue,\n  borderTopRightRadius: processUnitValue,\n  borderTopStyle: processNoopValue,\n  borderTopWidth: processUnitValue,\n  borderWidth: resolveBorderShorthand\n};\nconst handlers$a = {\n  backgroundColor: processColorValue,\n  color: processColorValue,\n  opacity: processNumberValue\n};\nconst handlers$9 = {\n  height: processUnitValue,\n  maxHeight: processUnitValue,\n  maxWidth: processUnitValue,\n  minHeight: processUnitValue,\n  minWidth: processUnitValue,\n  width: processUnitValue\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/CSS/flex#values\n// TODO: change flex defaults to [0, 1, 'auto'] as in spec in next major release\nconst flexDefaults = [1, 1, 0];\nconst flexAuto = [1, 1, 'auto'];\nconst processFlexShorthand = (key, value, container) => {\n  let defaults = flexDefaults;\n  let matches = [];\n  if (value === 'auto') {\n    defaults = flexAuto;\n  } else {\n    matches = \"\".concat(value).split(' ');\n  }\n  const flexGrow = parseFloat$1(matches[0] || defaults[0]);\n  const flexShrink = parseFloat$1(matches[1] || defaults[1]);\n  const flexBasis = transformUnit(container, matches[2] || defaults[2]);\n  return {\n    flexGrow,\n    flexShrink,\n    flexBasis\n  };\n};\nconst handlers$8 = {\n  alignContent: processNoopValue,\n  alignItems: processNoopValue,\n  alignSelf: processNoopValue,\n  flex: processFlexShorthand,\n  flexBasis: processUnitValue,\n  flexDirection: processNoopValue,\n  flexFlow: processNoopValue,\n  flexGrow: processNumberValue,\n  flexShrink: processNumberValue,\n  flexWrap: processNoopValue,\n  justifyContent: processNoopValue,\n  justifySelf: processNoopValue\n};\nconst processGapShorthand = (key, value, container) => {\n  const match = \"\".concat(value).split(' ');\n  const rowGap = transformUnit(container, (match === null || match === void 0 ? void 0 : match[0]) || value);\n  const columnGap = transformUnit(container, (match === null || match === void 0 ? void 0 : match[1]) || value);\n  return {\n    rowGap,\n    columnGap\n  };\n};\nconst handlers$7 = {\n  gap: processGapShorthand,\n  columnGap: processUnitValue,\n  rowGap: processUnitValue\n};\nconst handlers$6 = {\n  aspectRatio: processNumberValue,\n  bottom: processUnitValue,\n  display: processNoopValue,\n  left: processUnitValue,\n  position: processNoopValue,\n  right: processUnitValue,\n  top: processUnitValue,\n  overflow: processNoopValue,\n  zIndex: processNumberValue\n};\nconst BOX_MODEL_UNITS = 'px,in,mm,cm,pt,%,vw,vh';\nconst logError = (style, value) => {\n  const name = style.toString();\n  // eslint-disable-next-line no-console\n  console.error(\"\\n    @react-pdf/stylesheet parsing error:\\n    \".concat(name, \": \").concat(value, \",\\n    \").concat(' '.repeat(name.length + 2), \"^\\n    Unsupported \").concat(name, \" value format\\n  \"));\n};\n/**\n * @param options\n * @param [options.expandsTo]\n * @param [options.maxValues]\n * @param [options.autoSupported]\n */\nconst expandBoxModel = function () {\n  let {\n    expandsTo,\n    maxValues = 1,\n    autoSupported = false\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return (model, value, container) => {\n    const nodes = parse$1(\"\".concat(value));\n    const parts = [];\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      // value contains `calc`, `url` or other css function\n      // `,`, `/` or strings that unsupported by margin and padding\n      if (node.type === 'function' || node.type === 'string' || node.type === 'div') {\n        logError(model, value);\n        return {};\n      }\n      if (node.type === 'word') {\n        if (node.value === 'auto' && autoSupported) {\n          parts.push(node.value);\n        } else {\n          const result = parseUnit(node.value);\n          // when unit isn't specified this condition is true\n          if (result && BOX_MODEL_UNITS.includes(result.unit)) {\n            parts.push(node.value);\n          } else {\n            logError(model, value);\n            return {};\n          }\n        }\n      }\n    }\n    // checks that we have enough parsed values\n    if (parts.length > maxValues) {\n      logError(model, value);\n      return {};\n    }\n    const first = transformUnit(container, parts[0]);\n    if (expandsTo) {\n      const second = transformUnit(container, parts[1] || parts[0]);\n      const third = transformUnit(container, parts[2] || parts[0]);\n      const fourth = transformUnit(container, parts[3] || parts[1] || parts[0]);\n      return expandsTo({\n        first,\n        second,\n        third,\n        fourth\n      });\n    }\n    return {\n      [model]: first\n    };\n  };\n};\nconst processMargin = expandBoxModel({\n  expandsTo: _ref => {\n    let {\n      first,\n      second,\n      third,\n      fourth\n    } = _ref;\n    return {\n      marginTop: first,\n      marginRight: second,\n      marginBottom: third,\n      marginLeft: fourth\n    };\n  },\n  maxValues: 4,\n  autoSupported: true\n});\nconst processMarginVertical = expandBoxModel({\n  expandsTo: _ref2 => {\n    let {\n      first,\n      second\n    } = _ref2;\n    return {\n      marginTop: first,\n      marginBottom: second\n    };\n  },\n  maxValues: 2,\n  autoSupported: true\n});\nconst processMarginHorizontal = expandBoxModel({\n  expandsTo: _ref3 => {\n    let {\n      first,\n      second\n    } = _ref3;\n    return {\n      marginRight: first,\n      marginLeft: second\n    };\n  },\n  maxValues: 2,\n  autoSupported: true\n});\nconst processMarginSingle = expandBoxModel({\n  autoSupported: true\n});\nconst handlers$5 = {\n  margin: processMargin,\n  marginBottom: processMarginSingle,\n  marginHorizontal: processMarginHorizontal,\n  marginLeft: processMarginSingle,\n  marginRight: processMarginSingle,\n  marginTop: processMarginSingle,\n  marginVertical: processMarginVertical\n};\nconst processPadding = expandBoxModel({\n  expandsTo: _ref4 => {\n    let {\n      first,\n      second,\n      third,\n      fourth\n    } = _ref4;\n    return {\n      paddingTop: first,\n      paddingRight: second,\n      paddingBottom: third,\n      paddingLeft: fourth\n    };\n  },\n  maxValues: 4\n});\nconst processPaddingVertical = expandBoxModel({\n  expandsTo: _ref5 => {\n    let {\n      first,\n      second\n    } = _ref5;\n    return {\n      paddingTop: first,\n      paddingBottom: second\n    };\n  },\n  maxValues: 2\n});\nconst processPaddingHorizontal = expandBoxModel({\n  expandsTo: _ref6 => {\n    let {\n      first,\n      second\n    } = _ref6;\n    return {\n      paddingRight: first,\n      paddingLeft: second\n    };\n  },\n  maxValues: 2\n});\nconst processPaddingSingle = expandBoxModel();\nconst handlers$4 = {\n  padding: processPadding,\n  paddingBottom: processPaddingSingle,\n  paddingHorizontal: processPaddingHorizontal,\n  paddingLeft: processPaddingSingle,\n  paddingRight: processPaddingSingle,\n  paddingTop: processPaddingSingle,\n  paddingVertical: processPaddingVertical\n};\nconst offsetKeyword = value => {\n  switch (value) {\n    case 'top':\n    case 'left':\n      return '0%';\n    case 'right':\n    case 'bottom':\n      return '100%';\n    case 'center':\n      return '50%';\n    default:\n      return value;\n  }\n};\nconst processObjectPosition = (key, value, container) => {\n  const match = \"\".concat(value).split(' ');\n  const objectPositionX = offsetKeyword(transformUnit(container, (match === null || match === void 0 ? void 0 : match[0]) || value));\n  const objectPositionY = offsetKeyword(transformUnit(container, (match === null || match === void 0 ? void 0 : match[1]) || value));\n  return {\n    objectPositionX,\n    objectPositionY\n  };\n};\nconst processObjectPositionValue = (key, value, container) => ({\n  [key]: offsetKeyword(transformUnit(container, value))\n});\nconst handlers$3 = {\n  objectPosition: processObjectPosition,\n  objectPositionX: processObjectPositionValue,\n  objectPositionY: processObjectPositionValue,\n  objectFit: processNoopValue\n};\nconst castInt = value => {\n  if (typeof value === 'number') return value;\n  return parseInt(value, 10);\n};\nconst FONT_WEIGHTS = {\n  thin: 100,\n  hairline: 100,\n  ultralight: 200,\n  extralight: 200,\n  light: 300,\n  normal: 400,\n  medium: 500,\n  semibold: 600,\n  demibold: 600,\n  bold: 700,\n  ultrabold: 800,\n  extrabold: 800,\n  heavy: 900,\n  black: 900\n};\nconst transformFontWeight = value => {\n  if (!value) return FONT_WEIGHTS.normal;\n  if (typeof value === 'number') return value;\n  const lv = value.toLowerCase();\n  if (FONT_WEIGHTS[lv]) return FONT_WEIGHTS[lv];\n  return castInt(value);\n};\nconst processFontWeight = (key, value) => {\n  return {\n    [key]: transformFontWeight(value)\n  };\n};\nconst transformLineHeight = (value, styles, container) => {\n  if (value === '') return value;\n  const fontSize = transformUnit(container, styles.fontSize || 18);\n  const lineHeight = transformUnit(container, value);\n  // Percent values: use this number multiplied by the element's font size\n  const {\n    percent\n  } = matchPercent(lineHeight) || {};\n  if (percent) return percent * fontSize;\n  // Unitless values: use this number multiplied by the element's font size\n  return isNaN(value) ? lineHeight : lineHeight * fontSize;\n};\nconst processLineHeight = (key, value, container, styles) => {\n  return {\n    [key]: transformLineHeight(value, styles, container)\n  };\n};\nconst handlers$2 = {\n  direction: processNoopValue,\n  fontFamily: processNoopValue,\n  fontSize: processUnitValue,\n  fontStyle: processNoopValue,\n  fontWeight: processFontWeight,\n  letterSpacing: processUnitValue,\n  lineHeight: processLineHeight,\n  maxLines: processNumberValue,\n  textAlign: processNoopValue,\n  textDecoration: processNoopValue,\n  textDecorationColor: processColorValue,\n  textDecorationStyle: processNoopValue,\n  textIndent: processNoopValue,\n  textOverflow: processNoopValue,\n  textTransform: processNoopValue,\n  verticalAlign: processNoopValue\n};\nconst matchNumber = value => typeof value === 'string' && /^-?\\d*\\.?\\d*$/.test(value);\nconst castFloat = value => {\n  if (typeof value !== 'string') return value;\n  if (matchNumber(value)) return parseFloat(value);\n  return value;\n};\nconst parse = transformString => {\n  const transforms = transformString.trim().split(/\\)[ ,]|\\)/);\n  // Handle \"initial\", \"inherit\", \"unset\".\n  if (transforms.length === 1) {\n    return [[transforms[0], true]];\n  }\n  const parsed = [];\n  for (let i = 0; i < transforms.length; i += 1) {\n    const transform = transforms[i];\n    if (transform) {\n      const [name, rawValue] = transform.split('(');\n      const splitChar = rawValue.indexOf(',') >= 0 ? ',' : ' ';\n      const value = rawValue.split(splitChar).map(val => val.trim());\n      parsed.push({\n        operation: name.trim(),\n        value\n      });\n    }\n  }\n  return parsed;\n};\nconst parseAngle = value => {\n  const unitsRegexp = /(-?\\d*\\.?\\d*)(\\w*)?/i;\n  const [, angle, unit] = unitsRegexp.exec(value);\n  const number = Number.parseFloat(angle);\n  return unit === 'rad' ? number * 180 / Math.PI : number;\n};\nconst normalizeTransformOperation = _ref7 => {\n  let {\n    operation,\n    value\n  } = _ref7;\n  switch (operation) {\n    case 'scale':\n      {\n        const [scaleX, scaleY = scaleX] = value.map(num => Number.parseFloat(num));\n        return {\n          operation: 'scale',\n          value: [scaleX, scaleY]\n        };\n      }\n    case 'scaleX':\n      {\n        return {\n          operation: 'scale',\n          value: [Number.parseFloat(value), 1]\n        };\n      }\n    case 'scaleY':\n      {\n        return {\n          operation: 'scale',\n          value: [1, Number.parseFloat(value)]\n        };\n      }\n    case 'rotate':\n      {\n        return {\n          operation: 'rotate',\n          value: [parseAngle(value)]\n        };\n      }\n    case 'translate':\n      {\n        return {\n          operation: 'translate',\n          value: value.map(num => Number.parseFloat(num))\n        };\n      }\n    case 'translateX':\n      {\n        return {\n          operation: 'translate',\n          value: [Number.parseFloat(value), 0]\n        };\n      }\n    case 'translateY':\n      {\n        return {\n          operation: 'translate',\n          value: [0, Number.parseFloat(value)]\n        };\n      }\n    case 'skew':\n      {\n        return {\n          operation: 'skew',\n          value: value.map(parseAngle)\n        };\n      }\n    case 'skewX':\n      {\n        return {\n          operation: 'skew',\n          value: [parseAngle(value), 0]\n        };\n      }\n    case 'skewY':\n      {\n        return {\n          operation: 'skew',\n          value: [0, parseAngle(value)]\n        };\n      }\n    default:\n      {\n        return {\n          operation,\n          value: value.map(num => Number.parseFloat(num))\n        };\n      }\n  }\n};\nconst normalize = operations => {\n  return operations.map(operation => normalizeTransformOperation(operation));\n};\nconst processTransform = (key, value) => {\n  if (typeof value !== 'string') return {\n    [key]: value\n  };\n  return {\n    [key]: normalize(parse(value))\n  };\n};\nconst Y_AXIS_SHORTHANDS = {\n  top: true,\n  bottom: true\n};\nconst sortTransformOriginPair = (a, b) => {\n  if (Y_AXIS_SHORTHANDS[a]) return 1;\n  if (Y_AXIS_SHORTHANDS[b]) return -1;\n  return 0;\n};\nconst getTransformOriginPair = values => {\n  if (!values || values.length === 0) return ['center', 'center'];\n  const pair = values.length === 1 ? [values[0], 'center'] : values;\n  return pair.sort(sortTransformOriginPair);\n};\n// Transforms shorthand transformOrigin values\nconst processTransformOriginShorthand = (key, value, container) => {\n  const match = \"\".concat(value).split(' ');\n  const pair = getTransformOriginPair(match);\n  const transformOriginX = transformUnit(container, pair[0]);\n  const transformOriginY = transformUnit(container, pair[1]);\n  return {\n    transformOriginX: offsetKeyword(transformOriginX) || castFloat(transformOriginX),\n    transformOriginY: offsetKeyword(transformOriginY) || castFloat(transformOriginY)\n  };\n};\nconst processTransformOriginValue = (key, value, container) => {\n  const v = transformUnit(container, value);\n  return {\n    [key]: offsetKeyword(v) || castFloat(v)\n  };\n};\nconst handlers$1 = {\n  transform: processTransform,\n  gradientTransform: processTransform,\n  transformOrigin: processTransformOriginShorthand,\n  transformOriginX: processTransformOriginValue,\n  transformOriginY: processTransformOriginValue\n};\nconst handlers = {\n  fill: processColorValue,\n  stroke: processColorValue,\n  strokeDasharray: processNoopValue,\n  strokeWidth: processUnitValue,\n  fillOpacity: processNumberValue,\n  strokeOpacity: processNumberValue,\n  fillRule: processNoopValue,\n  textAnchor: processNoopValue,\n  strokeLinecap: processNoopValue,\n  strokeLinejoin: processNoopValue,\n  visibility: processNoopValue,\n  clipPath: processNoopValue,\n  dominantBaseline: processNoopValue\n};\nconst shorthands = _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, handlers$b), handlers$a), handlers$9), handlers$8), handlers$7), handlers$6), handlers$5), handlers$4), handlers$3), handlers$2), handlers$1), handlers);\n/**\n * Expand the shorthand properties.\n *\n * @param style - Style object\n * @returns Expanded style object\n */\nconst resolve = container => style => {\n  const propsArray = Object.keys(style);\n  const resolvedStyle = {};\n  for (let i = 0; i < propsArray.length; i += 1) {\n    const key = propsArray[i];\n    const value = style[key];\n    if (!shorthands[key]) {\n      resolvedStyle[key] = value;\n      continue;\n    }\n    const resolved = shorthands[key](key, value, container, style);\n    const keys = Object.keys(resolved);\n    for (let j = 0; j < keys.length; j += 1) {\n      const propName = keys[j];\n      const propValue = resolved[propName];\n      resolvedStyle[propName] = propValue;\n    }\n  }\n  return resolvedStyle;\n};\n\n/**\n * Resolves styles\n *\n * @param container\n * @param style - Style\n * @returns Resolved style\n */\nconst resolveStyles = (container, style) => {\n  const computeMediaQueries = value => resolveMediaQueries(container, value);\n  return compose(resolve(container), computeMediaQueries, flatten)(style);\n};\nexport { resolveStyles as default, flatten, transformColor };","map":{"version":3,"names":["compose","castArray","parseFloat","parseFloat$1","matchPercent","matchMedia","hlsToHex","colorString","parse$1","parseUnit","compact","array","filter","Boolean","mergeStyles","styles","reduce","acc","style","s","Array","isArray","flatten","Object","keys","forEach","key","undefined","resolveMediaQueries","container","test","_objectSpread","isRgb","value","isHsl","parseRgb","rgb","get","to","hex","parseHsl","hsl","map","Math","round","toUpperCase","transformColor","parseValue","unit","match","exec","transformUnit","scalar","outputDpi","inputDpi","dpi","mmFactor","cmFactor","remBase","height","width","processNumberValue","processUnitValue","processColorValue","result","processNoopValue","BORDER_SHORTHAND_REGEX","matchBorderShorthand","resolveBorderShorthand","concat","widthMatch","styleMatch","colorMatch","color","borderTopColor","borderRightColor","borderBottomColor","borderLeftColor","Error","borderTopStyle","borderRightStyle","borderBottomStyle","borderLeftStyle","borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth","radius","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","handlers$b","border","borderBottom","borderColor","borderLeft","borderRadius","borderRight","borderStyle","borderTop","borderWidth","handlers$a","backgroundColor","opacity","handlers$9","maxHeight","maxWidth","minHeight","minWidth","flexDefaults","flexAuto","processFlexShorthand","defaults","matches","split","flexGrow","flexShrink","flexBasis","handlers$8","alignContent","alignItems","alignSelf","flex","flexDirection","flexFlow","flexWrap","justifyContent","justifySelf","processGapShorthand","rowGap","columnGap","handlers$7","gap","handlers$6","aspectRatio","bottom","display","left","position","right","top","overflow","zIndex","BOX_MODEL_UNITS","logError","name","toString","console","error","repeat","length","expandBoxModel","expandsTo","maxValues","autoSupported","arguments","model","nodes","parts","i","node","type","push","includes","first","second","third","fourth","processMargin","_ref","marginTop","marginRight","marginBottom","marginLeft","processMarginVertical","_ref2","processMarginHorizontal","_ref3","processMarginSingle","handlers$5","margin","marginHorizontal","marginVertical","processPadding","_ref4","paddingTop","paddingRight","paddingBottom","paddingLeft","processPaddingVertical","_ref5","processPaddingHorizontal","_ref6","processPaddingSingle","handlers$4","padding","paddingHorizontal","paddingVertical","offsetKeyword","processObjectPosition","objectPositionX","objectPositionY","processObjectPositionValue","handlers$3","objectPosition","objectFit","castInt","parseInt","FONT_WEIGHTS","thin","hairline","ultralight","extralight","light","normal","medium","semibold","demibold","bold","ultrabold","extrabold","heavy","black","transformFontWeight","lv","toLowerCase","processFontWeight","transformLineHeight","fontSize","lineHeight","percent","isNaN","processLineHeight","handlers$2","direction","fontFamily","fontStyle","fontWeight","letterSpacing","maxLines","textAlign","textDecoration","textDecorationColor","textDecorationStyle","textIndent","textOverflow","textTransform","verticalAlign","matchNumber","castFloat","parse","transformString","transforms","trim","parsed","transform","rawValue","splitChar","indexOf","val","operation","parseAngle","unitsRegexp","angle","number","Number","PI","normalizeTransformOperation","_ref7","scaleX","scaleY","num","normalize","operations","processTransform","Y_AXIS_SHORTHANDS","sortTransformOriginPair","a","b","getTransformOriginPair","values","pair","sort","processTransformOriginShorthand","transformOriginX","transformOriginY","processTransformOriginValue","v","handlers$1","gradientTransform","transformOrigin","handlers","fill","stroke","strokeDasharray","strokeWidth","fillOpacity","strokeOpacity","fillRule","textAnchor","strokeLinecap","strokeLinejoin","visibility","clipPath","dominantBaseline","shorthands","resolve","propsArray","resolvedStyle","resolved","j","propName","propValue","resolveStyles","computeMediaQueries","default"],"sources":["C:/PreventaWeb/FrontEnd/node_modules/@react-pdf/stylesheet/lib/index.js"],"sourcesContent":["import { compose, castArray, parseFloat as parseFloat$1, matchPercent } from '@react-pdf/fns';\nimport matchMedia from 'media-engine';\nimport hlsToHex from 'hsl-to-hex';\nimport colorString from 'color-string';\nimport parse$1 from 'postcss-value-parser/lib/parse.js';\nimport parseUnit from 'postcss-value-parser/lib/unit.js';\n\n/**\n * Remove nil values from array\n *\n * @param array - Style array\n * @returns Style array without nils\n */\nconst compact = (array) => array.filter(Boolean);\n/**\n * Merges style objects array\n *\n * @param styles - Style array\n * @returns Merged style object\n */\nconst mergeStyles = (styles) => styles.reduce((acc, style) => {\n    const s = Array.isArray(style) ? flatten(style) : style;\n    Object.keys(s).forEach((key) => {\n        if (s[key] !== null && s[key] !== undefined) {\n            acc[key] = s[key];\n        }\n    });\n    return acc;\n}, {});\n/**\n * Flattens an array of style objects, into one aggregated style object.\n *\n * @param styles - Style or style array\n * @returns Flattened style object\n */\nconst flatten = compose(mergeStyles, compact, (castArray));\n\n/**\n * Resolves media queries in styles object\n *\n * @param container - Container for which styles are resolved\n * @param style - Style description\n * @returns Resolved style object\n */\nconst resolveMediaQueries = (container, style) => {\n    return Object.keys(style).reduce((acc, key) => {\n        if (/@media/.test(key)) {\n            return {\n                ...acc,\n                ...matchMedia({ [key]: style[key] }, container),\n            };\n        }\n        return { ...acc, [key]: style[key] };\n    }, {});\n};\n\nconst isRgb = (value) => /rgba?/g.test(value);\nconst isHsl = (value) => /hsla?/g.test(value);\n/**\n * Transform rgb color to hexa\n *\n * @param value - Styles value\n * @returns Transformed value\n */\nconst parseRgb = (value) => {\n    const rgb = colorString.get.rgb(value);\n    return colorString.to.hex(rgb);\n};\n/**\n * Transform Hsl color to hexa\n *\n * @param value - Styles value\n * @returns Transformed value\n */\nconst parseHsl = (value) => {\n    const hsl = colorString.get.hsl(value).map(Math.round);\n    const hex = hlsToHex(...hsl);\n    return hex.toUpperCase();\n};\n/**\n * Transform given color to hexa\n *\n * @param value - Styles value\n * @returns Transformed value\n */\nconst transformColor = (value) => {\n    if (isRgb(value))\n        return parseRgb(value);\n    if (isHsl(value))\n        return parseHsl(value);\n    return value;\n};\n\n/**\n * Parses scalar value in value and unit pairs\n *\n * @param value - Scalar value\n * @returns Parsed value\n */\nconst parseValue = (value) => {\n    if (typeof value === 'number')\n        return { value, unit: undefined };\n    const match = /^(-?\\d*\\.?\\d+)(in|mm|cm|pt|vh|vw|px|rem)?$/g.exec(value);\n    return match\n        ? { value: parseFloat(match[1]), unit: match[2] || 'pt' }\n        : { value, unit: undefined };\n};\n/**\n * Transform given scalar value\n *\n * @param container\n * @param value - Styles value\n * @returns Transformed value\n */\nconst transformUnit = (container, value) => {\n    const scalar = parseValue(value);\n    const outputDpi = 72;\n    const inputDpi = container.dpi || 72;\n    const mmFactor = (1 / 25.4) * outputDpi;\n    const cmFactor = (1 / 2.54) * outputDpi;\n    if (typeof scalar.value !== 'number')\n        return scalar.value;\n    switch (scalar.unit) {\n        case 'rem':\n            return scalar.value * (container.remBase || 18);\n        case 'in':\n            return scalar.value * outputDpi;\n        case 'mm':\n            return scalar.value * mmFactor;\n        case 'cm':\n            return scalar.value * cmFactor;\n        case 'vh':\n            return scalar.value * (container.height / 100);\n        case 'vw':\n            return scalar.value * (container.width / 100);\n        case 'px':\n            return Math.round(scalar.value * (outputDpi / inputDpi));\n        default:\n            return scalar.value;\n    }\n};\n\nconst processNumberValue = (key, value) => ({\n    [key]: parseFloat$1(value),\n});\nconst processUnitValue = (key, value, container) => ({\n    [key]: transformUnit(container, value),\n});\nconst processColorValue = (key, value) => {\n    const result = { [key]: transformColor(value) };\n    return result;\n};\nconst processNoopValue = (key, value) => ({\n    [key]: value,\n});\n\nconst BORDER_SHORTHAND_REGEX = /(-?\\d+(\\.\\d+)?(in|mm|cm|pt|vw|vh|px|rem)?)\\s(\\S+)\\s(.+)/;\nconst matchBorderShorthand = (value) => value.match(BORDER_SHORTHAND_REGEX) || [];\nconst resolveBorderShorthand = (key, value, container) => {\n    const match = matchBorderShorthand(`${value}`);\n    if (match) {\n        const widthMatch = match[1] || value;\n        const styleMatch = match[4] || value;\n        const colorMatch = match[5] || value;\n        const style = styleMatch;\n        const color = colorMatch ? transformColor(colorMatch) : undefined;\n        const width = widthMatch ? transformUnit(container, widthMatch) : undefined;\n        if (key.match(/(Top|Right|Bottom|Left)$/)) {\n            return {\n                [`${key}Color`]: color,\n                [`${key}Style`]: style,\n                [`${key}Width`]: width,\n            };\n        }\n        if (key.match(/Color$/)) {\n            return {\n                borderTopColor: color,\n                borderRightColor: color,\n                borderBottomColor: color,\n                borderLeftColor: color,\n            };\n        }\n        if (key.match(/Style$/)) {\n            if (typeof style === 'number')\n                throw new Error(`Invalid border style: ${style}`);\n            return {\n                borderTopStyle: style,\n                borderRightStyle: style,\n                borderBottomStyle: style,\n                borderLeftStyle: style,\n            };\n        }\n        if (key.match(/Width$/)) {\n            if (typeof width !== 'number')\n                throw new Error(`Invalid border width: ${width}`);\n            return {\n                borderTopWidth: width,\n                borderRightWidth: width,\n                borderBottomWidth: width,\n                borderLeftWidth: width,\n            };\n        }\n        if (key.match(/Radius$/)) {\n            const radius = value ? transformUnit(container, value) : undefined;\n            if (typeof radius !== 'number')\n                throw new Error(`Invalid border radius: ${radius}`);\n            return {\n                borderTopLeftRadius: radius,\n                borderTopRightRadius: radius,\n                borderBottomRightRadius: radius,\n                borderBottomLeftRadius: radius,\n            };\n        }\n        if (typeof width !== 'number')\n            throw new Error(`Invalid border width: ${width}`);\n        if (typeof style === 'number')\n            throw new Error(`Invalid border style: ${style}`);\n        return {\n            borderTopColor: color,\n            borderTopStyle: style,\n            borderTopWidth: width,\n            borderRightColor: color,\n            borderRightStyle: style,\n            borderRightWidth: width,\n            borderBottomColor: color,\n            borderBottomStyle: style,\n            borderBottomWidth: width,\n            borderLeftColor: color,\n            borderLeftStyle: style,\n            borderLeftWidth: width,\n        };\n    }\n    return { [key]: value };\n};\nconst handlers$b = {\n    border: (resolveBorderShorthand),\n    borderBottom: (resolveBorderShorthand),\n    borderBottomColor: (processColorValue),\n    borderBottomLeftRadius: (processUnitValue),\n    borderBottomRightRadius: (processUnitValue),\n    borderBottomStyle: (processNoopValue),\n    borderBottomWidth: (processUnitValue),\n    borderColor: (resolveBorderShorthand),\n    borderLeft: (resolveBorderShorthand),\n    borderLeftColor: (processColorValue),\n    borderLeftStyle: (processNoopValue),\n    borderLeftWidth: (processUnitValue),\n    borderRadius: (resolveBorderShorthand),\n    borderRight: (resolveBorderShorthand),\n    borderRightColor: (processColorValue),\n    borderRightStyle: (processNoopValue),\n    borderRightWidth: (processUnitValue),\n    borderStyle: (resolveBorderShorthand),\n    borderTop: (resolveBorderShorthand),\n    borderTopColor: (processColorValue),\n    borderTopLeftRadius: (processUnitValue),\n    borderTopRightRadius: (processUnitValue),\n    borderTopStyle: (processNoopValue),\n    borderTopWidth: (processUnitValue),\n    borderWidth: (resolveBorderShorthand),\n};\n\nconst handlers$a = {\n    backgroundColor: (processColorValue),\n    color: (processColorValue),\n    opacity: (processNumberValue),\n};\n\nconst handlers$9 = {\n    height: (processUnitValue),\n    maxHeight: (processUnitValue),\n    maxWidth: (processUnitValue),\n    minHeight: (processUnitValue),\n    minWidth: (processUnitValue),\n    width: (processUnitValue),\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/CSS/flex#values\n// TODO: change flex defaults to [0, 1, 'auto'] as in spec in next major release\nconst flexDefaults = [1, 1, 0];\nconst flexAuto = [1, 1, 'auto'];\nconst processFlexShorthand = (key, value, container) => {\n    let defaults = flexDefaults;\n    let matches = [];\n    if (value === 'auto') {\n        defaults = flexAuto;\n    }\n    else {\n        matches = `${value}`.split(' ');\n    }\n    const flexGrow = parseFloat$1(matches[0] || defaults[0]);\n    const flexShrink = parseFloat$1(matches[1] || defaults[1]);\n    const flexBasis = transformUnit(container, matches[2] || defaults[2]);\n    return { flexGrow, flexShrink, flexBasis };\n};\nconst handlers$8 = {\n    alignContent: (processNoopValue),\n    alignItems: (processNoopValue),\n    alignSelf: (processNoopValue),\n    flex: (processFlexShorthand),\n    flexBasis: (processUnitValue),\n    flexDirection: (processNoopValue),\n    flexFlow: (processNoopValue),\n    flexGrow: (processNumberValue),\n    flexShrink: (processNumberValue),\n    flexWrap: (processNoopValue),\n    justifyContent: (processNoopValue),\n    justifySelf: (processNoopValue),\n};\n\nconst processGapShorthand = (key, value, container) => {\n    const match = `${value}`.split(' ');\n    const rowGap = transformUnit(container, match?.[0] || value);\n    const columnGap = transformUnit(container, match?.[1] || value);\n    return { rowGap, columnGap };\n};\nconst handlers$7 = {\n    gap: (processGapShorthand),\n    columnGap: (processUnitValue),\n    rowGap: (processUnitValue),\n};\n\nconst handlers$6 = {\n    aspectRatio: (processNumberValue),\n    bottom: (processUnitValue),\n    display: (processNoopValue),\n    left: (processUnitValue),\n    position: (processNoopValue),\n    right: (processUnitValue),\n    top: (processUnitValue),\n    overflow: (processNoopValue),\n    zIndex: (processNumberValue),\n};\n\nconst BOX_MODEL_UNITS = 'px,in,mm,cm,pt,%,vw,vh';\nconst logError = (style, value) => {\n    const name = style.toString();\n    // eslint-disable-next-line no-console\n    console.error(`\n    @react-pdf/stylesheet parsing error:\n    ${name}: ${value},\n    ${' '.repeat(name.length + 2)}^\n    Unsupported ${name} value format\n  `);\n};\n/**\n * @param options\n * @param [options.expandsTo]\n * @param [options.maxValues]\n * @param [options.autoSupported]\n */\nconst expandBoxModel = ({ expandsTo, maxValues = 1, autoSupported = false, } = {}) => (model, value, container) => {\n    const nodes = parse$1(`${value}`);\n    const parts = [];\n    for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        // value contains `calc`, `url` or other css function\n        // `,`, `/` or strings that unsupported by margin and padding\n        if (node.type === 'function' ||\n            node.type === 'string' ||\n            node.type === 'div') {\n            logError(model, value);\n            return {};\n        }\n        if (node.type === 'word') {\n            if (node.value === 'auto' && autoSupported) {\n                parts.push(node.value);\n            }\n            else {\n                const result = parseUnit(node.value);\n                // when unit isn't specified this condition is true\n                if (result && BOX_MODEL_UNITS.includes(result.unit)) {\n                    parts.push(node.value);\n                }\n                else {\n                    logError(model, value);\n                    return {};\n                }\n            }\n        }\n    }\n    // checks that we have enough parsed values\n    if (parts.length > maxValues) {\n        logError(model, value);\n        return {};\n    }\n    const first = transformUnit(container, parts[0]);\n    if (expandsTo) {\n        const second = transformUnit(container, parts[1] || parts[0]);\n        const third = transformUnit(container, parts[2] || parts[0]);\n        const fourth = transformUnit(container, parts[3] || parts[1] || parts[0]);\n        return expandsTo({ first, second, third, fourth });\n    }\n    return {\n        [model]: first,\n    };\n};\n\nconst processMargin = expandBoxModel({\n    expandsTo: ({ first, second, third, fourth }) => ({\n        marginTop: first,\n        marginRight: second,\n        marginBottom: third,\n        marginLeft: fourth,\n    }),\n    maxValues: 4,\n    autoSupported: true,\n});\nconst processMarginVertical = expandBoxModel({\n    expandsTo: ({ first, second }) => ({\n        marginTop: first,\n        marginBottom: second,\n    }),\n    maxValues: 2,\n    autoSupported: true,\n});\nconst processMarginHorizontal = expandBoxModel({\n    expandsTo: ({ first, second }) => ({\n        marginRight: first,\n        marginLeft: second,\n    }),\n    maxValues: 2,\n    autoSupported: true,\n});\nconst processMarginSingle = expandBoxModel({\n    autoSupported: true,\n});\nconst handlers$5 = {\n    margin: (processMargin),\n    marginBottom: (processMarginSingle),\n    marginHorizontal: (processMarginHorizontal),\n    marginLeft: (processMarginSingle),\n    marginRight: (processMarginSingle),\n    marginTop: (processMarginSingle),\n    marginVertical: (processMarginVertical),\n};\n\nconst processPadding = expandBoxModel({\n    expandsTo: ({ first, second, third, fourth }) => ({\n        paddingTop: first,\n        paddingRight: second,\n        paddingBottom: third,\n        paddingLeft: fourth,\n    }),\n    maxValues: 4,\n});\nconst processPaddingVertical = expandBoxModel({\n    expandsTo: ({ first, second }) => ({\n        paddingTop: first,\n        paddingBottom: second,\n    }),\n    maxValues: 2,\n});\nconst processPaddingHorizontal = expandBoxModel({\n    expandsTo: ({ first, second }) => ({\n        paddingRight: first,\n        paddingLeft: second,\n    }),\n    maxValues: 2,\n});\nconst processPaddingSingle = expandBoxModel();\nconst handlers$4 = {\n    padding: (processPadding),\n    paddingBottom: (processPaddingSingle),\n    paddingHorizontal: (processPaddingHorizontal),\n    paddingLeft: (processPaddingSingle),\n    paddingRight: (processPaddingSingle),\n    paddingTop: (processPaddingSingle),\n    paddingVertical: (processPaddingVertical),\n};\n\nconst offsetKeyword = (value) => {\n    switch (value) {\n        case 'top':\n        case 'left':\n            return '0%';\n        case 'right':\n        case 'bottom':\n            return '100%';\n        case 'center':\n            return '50%';\n        default:\n            return value;\n    }\n};\n\nconst processObjectPosition = (key, value, container) => {\n    const match = `${value}`.split(' ');\n    const objectPositionX = offsetKeyword(transformUnit(container, match?.[0] || value));\n    const objectPositionY = offsetKeyword(transformUnit(container, match?.[1] || value));\n    return { objectPositionX, objectPositionY };\n};\nconst processObjectPositionValue = (key, value, container) => ({\n    [key]: offsetKeyword(transformUnit(container, value)),\n});\nconst handlers$3 = {\n    objectPosition: (processObjectPosition),\n    objectPositionX: (processObjectPositionValue),\n    objectPositionY: (processObjectPositionValue),\n    objectFit: (processNoopValue),\n};\n\nconst castInt = (value) => {\n    if (typeof value === 'number')\n        return value;\n    return parseInt(value, 10);\n};\n\nconst FONT_WEIGHTS = {\n    thin: 100,\n    hairline: 100,\n    ultralight: 200,\n    extralight: 200,\n    light: 300,\n    normal: 400,\n    medium: 500,\n    semibold: 600,\n    demibold: 600,\n    bold: 700,\n    ultrabold: 800,\n    extrabold: 800,\n    heavy: 900,\n    black: 900,\n};\nconst transformFontWeight = (value) => {\n    if (!value)\n        return FONT_WEIGHTS.normal;\n    if (typeof value === 'number')\n        return value;\n    const lv = value.toLowerCase();\n    if (FONT_WEIGHTS[lv])\n        return FONT_WEIGHTS[lv];\n    return castInt(value);\n};\nconst processFontWeight = (key, value) => {\n    return { [key]: transformFontWeight(value) };\n};\nconst transformLineHeight = (value, styles, container) => {\n    if (value === '')\n        return value;\n    const fontSize = transformUnit(container, styles.fontSize || 18);\n    const lineHeight = transformUnit(container, value);\n    // Percent values: use this number multiplied by the element's font size\n    const { percent } = matchPercent(lineHeight) || {};\n    if (percent)\n        return percent * fontSize;\n    // Unitless values: use this number multiplied by the element's font size\n    return isNaN(value) ? lineHeight : lineHeight * fontSize;\n};\nconst processLineHeight = (key, value, container, styles) => {\n    return {\n        [key]: transformLineHeight(value, styles, container),\n    };\n};\nconst handlers$2 = {\n    direction: (processNoopValue),\n    fontFamily: (processNoopValue),\n    fontSize: (processUnitValue),\n    fontStyle: (processNoopValue),\n    fontWeight: (processFontWeight),\n    letterSpacing: (processUnitValue),\n    lineHeight: (processLineHeight),\n    maxLines: (processNumberValue),\n    textAlign: (processNoopValue),\n    textDecoration: (processNoopValue),\n    textDecorationColor: (processColorValue),\n    textDecorationStyle: (processNoopValue),\n    textIndent: (processNoopValue),\n    textOverflow: (processNoopValue),\n    textTransform: (processNoopValue),\n    verticalAlign: (processNoopValue),\n};\n\nconst matchNumber = (value) => typeof value === 'string' && /^-?\\d*\\.?\\d*$/.test(value);\nconst castFloat = (value) => {\n    if (typeof value !== 'string')\n        return value;\n    if (matchNumber(value))\n        return parseFloat(value);\n    return value;\n};\n\nconst parse = (transformString) => {\n    const transforms = transformString.trim().split(/\\)[ ,]|\\)/);\n    // Handle \"initial\", \"inherit\", \"unset\".\n    if (transforms.length === 1) {\n        return [[transforms[0], true]];\n    }\n    const parsed = [];\n    for (let i = 0; i < transforms.length; i += 1) {\n        const transform = transforms[i];\n        if (transform) {\n            const [name, rawValue] = transform.split('(');\n            const splitChar = rawValue.indexOf(',') >= 0 ? ',' : ' ';\n            const value = rawValue.split(splitChar).map((val) => val.trim());\n            parsed.push({ operation: name.trim(), value });\n        }\n    }\n    return parsed;\n};\nconst parseAngle = (value) => {\n    const unitsRegexp = /(-?\\d*\\.?\\d*)(\\w*)?/i;\n    const [, angle, unit] = unitsRegexp.exec(value);\n    const number = Number.parseFloat(angle);\n    return unit === 'rad' ? (number * 180) / Math.PI : number;\n};\nconst normalizeTransformOperation = ({ operation, value }) => {\n    switch (operation) {\n        case 'scale': {\n            const [scaleX, scaleY = scaleX] = value.map((num) => Number.parseFloat(num));\n            return { operation: 'scale', value: [scaleX, scaleY] };\n        }\n        case 'scaleX': {\n            return { operation: 'scale', value: [Number.parseFloat(value), 1] };\n        }\n        case 'scaleY': {\n            return { operation: 'scale', value: [1, Number.parseFloat(value)] };\n        }\n        case 'rotate': {\n            return { operation: 'rotate', value: [parseAngle(value)] };\n        }\n        case 'translate': {\n            return {\n                operation: 'translate',\n                value: value.map((num) => Number.parseFloat(num)),\n            };\n        }\n        case 'translateX': {\n            return {\n                operation: 'translate',\n                value: [Number.parseFloat(value), 0],\n            };\n        }\n        case 'translateY': {\n            return { operation: 'translate', value: [0, Number.parseFloat(value)] };\n        }\n        case 'skew': {\n            return { operation: 'skew', value: value.map(parseAngle) };\n        }\n        case 'skewX': {\n            return { operation: 'skew', value: [parseAngle(value), 0] };\n        }\n        case 'skewY': {\n            return { operation: 'skew', value: [0, parseAngle(value)] };\n        }\n        default: {\n            return { operation, value: value.map((num) => Number.parseFloat(num)) };\n        }\n    }\n};\nconst normalize = (operations) => {\n    return operations.map((operation) => normalizeTransformOperation(operation));\n};\nconst processTransform = (key, value) => {\n    if (typeof value !== 'string')\n        return { [key]: value };\n    return { [key]: normalize(parse(value)) };\n};\nconst Y_AXIS_SHORTHANDS = { top: true, bottom: true };\nconst sortTransformOriginPair = (a, b) => {\n    if (Y_AXIS_SHORTHANDS[a])\n        return 1;\n    if (Y_AXIS_SHORTHANDS[b])\n        return -1;\n    return 0;\n};\nconst getTransformOriginPair = (values) => {\n    if (!values || values.length === 0)\n        return ['center', 'center'];\n    const pair = values.length === 1 ? [values[0], 'center'] : values;\n    return pair.sort(sortTransformOriginPair);\n};\n// Transforms shorthand transformOrigin values\nconst processTransformOriginShorthand = (key, value, container) => {\n    const match = `${value}`.split(' ');\n    const pair = getTransformOriginPair(match);\n    const transformOriginX = transformUnit(container, pair[0]);\n    const transformOriginY = transformUnit(container, pair[1]);\n    return {\n        transformOriginX: offsetKeyword(transformOriginX) || castFloat(transformOriginX),\n        transformOriginY: offsetKeyword(transformOriginY) || castFloat(transformOriginY),\n    };\n};\nconst processTransformOriginValue = (key, value, container) => {\n    const v = transformUnit(container, value);\n    return { [key]: offsetKeyword(v) || castFloat(v) };\n};\nconst handlers$1 = {\n    transform: processTransform,\n    gradientTransform: processTransform,\n    transformOrigin: (processTransformOriginShorthand),\n    transformOriginX: (processTransformOriginValue),\n    transformOriginY: (processTransformOriginValue),\n};\n\nconst handlers = {\n    fill: (processColorValue),\n    stroke: (processColorValue),\n    strokeDasharray: (processNoopValue),\n    strokeWidth: (processUnitValue),\n    fillOpacity: (processNumberValue),\n    strokeOpacity: (processNumberValue),\n    fillRule: (processNoopValue),\n    textAnchor: (processNoopValue),\n    strokeLinecap: (processNoopValue),\n    strokeLinejoin: (processNoopValue),\n    visibility: (processNoopValue),\n    clipPath: (processNoopValue),\n    dominantBaseline: (processNoopValue),\n};\n\nconst shorthands = {\n    ...handlers$b,\n    ...handlers$a,\n    ...handlers$9,\n    ...handlers$8,\n    ...handlers$7,\n    ...handlers$6,\n    ...handlers$5,\n    ...handlers$4,\n    ...handlers$3,\n    ...handlers$2,\n    ...handlers$1,\n    ...handlers,\n};\n/**\n * Expand the shorthand properties.\n *\n * @param style - Style object\n * @returns Expanded style object\n */\nconst resolve = (container) => (style) => {\n    const propsArray = Object.keys(style);\n    const resolvedStyle = {};\n    for (let i = 0; i < propsArray.length; i += 1) {\n        const key = propsArray[i];\n        const value = style[key];\n        if (!shorthands[key]) {\n            resolvedStyle[key] = value;\n            continue;\n        }\n        const resolved = shorthands[key](key, value, container, style);\n        const keys = Object.keys(resolved);\n        for (let j = 0; j < keys.length; j += 1) {\n            const propName = keys[j];\n            const propValue = resolved[propName];\n            resolvedStyle[propName] = propValue;\n        }\n    }\n    return resolvedStyle;\n};\n\n/**\n * Resolves styles\n *\n * @param container\n * @param style - Style\n * @returns Resolved style\n */\nconst resolveStyles = (container, style) => {\n    const computeMediaQueries = (value) => resolveMediaQueries(container, value);\n    return compose(resolve(container), computeMediaQueries, flatten)(style);\n};\n\nexport { resolveStyles as default, flatten, transformColor };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}